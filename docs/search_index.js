var documenterSearchIndex = {"docs":
[{"location":"qstart.html#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"CurrentModule = VerilogWriter\nDocTestSetup = quote\n    using VerilogWriter\nend","category":"page"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"Here we show an example of fully building a verilog module using VerilogWriter.jl.","category":"page"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"note: Note\nSemicolons at the end of each line in the code blocks below is needed only for formatting this document, and thus not needed in actual codes. However, semicolons inside macro arguments (e.g. @ports (@in A\";\"@in B)) are strictly required to indicate that the argument is a series of expressions.","category":"page"},{"location":"qstart.html#Define-the-Name-of-a-Module","page":"Quick Start","title":"Define the Name of a Module","text":"","category":"section"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"We offer a type Vmodule, which imitates Verilog modules. Instantiate it defining its name.","category":"page"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"julia> m = Vmodule(\"test\");\n\njulia> vshow(m)\nmodule test ();\n\nendmodule\ntype: Vmodule","category":"page"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"A module named test is generated here.","category":"page"},{"location":"qstart.html#Define-Ports,-Parameters,-Localparams,-and-Wires","page":"Quick Start","title":"Define Ports, Parameters, Localparams, and Wires","text":"","category":"section"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"Define ports, parameters, localparams, and wire/reg/logics as a Julia type we offer. Details on the types are at Basic Types.","category":"page"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"Add them to the module test calling vpush!.","category":"page"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"julia> pa = @parameters (dummy = 10 << 2);\n\njulia> po = @ports (\n       @in CLK, RST; \n       @in 8 din; \n       @out @reg -1 dout\n       );\n\njulia> lp = @localparams (\n       A = 1; \n       B = 2; \n       C = A + B\n       );\n\njulia> ds = @decls (\n       @reg dumreg; \n       @wire A+B<<C dumwire\n       );\n\njulia> vpush!.(m, (pa, po, lp, ds));\n\njulia> vshow(m);\nmodule test #(\n    parameter dummy = (10 << 2)\n)(\n    input CLK,\n    input RST,\n    input [7:0] din,\n    output reg [unknown] dout\n);\n    localparam A = 1;\n    localparam B = 2;\n    localparam C = (A + B);\n\n    reg dumreg;\n    wire [(A + (B << C))-1:0] dumwire;\n\n\nendmodule\ntype: Vmodule","category":"page"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"Syntaxes for each types (usage of @ports, @decls, etc.) are at List of Converter Macros.","category":"page"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"Instead of calling vpush! you may pass additional information to constructors of Vmodule. You may also wrap ports, parameters, etc. into type Vmodenv.","category":"page"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"julia> env = Vmodenv(pa, po, lp, ds); Vmodule(\"test\", env);","category":"page"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"would generate the same result.","category":"page"},{"location":"qstart.html#Define-Combinational/Sequential-Logics","page":"Quick Start","title":"Define Combinational/Sequential Logics","text":"","category":"section"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"You may write always blocks in Julia syntax, and add them to test module. Details at List of Converter Macros.","category":"page"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"julia> a1 = @always (dout <= din[3:0]); vshow(a1)\nalways_ff @( unknownedge  ) begin\n    dout <= din[3:0];\nend\ntype: Alwayscontent\n\njulia> a2 = @always (\n       dumreg = |(dumwire);\n       duminfer = ~dumreg\n       );\n\njulia> vshow(a2);\nalways_comb begin\n    dumreg = (|(dumwire));\n    duminfer = (~dumreg);\nend\ntype: Alwayscontent\n\njulia> vpush!(m, a1); vpush!(m, a2);","category":"page"},{"location":"qstart.html#Finalize-Verilog-Module","page":"Quick Start","title":"Finalize Verilog Module","text":"","category":"section"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"In the codes above some output was not completely of Verilog syntax (e.g. @( unknownedge )), and lacked some wire declarations (e.g. duminfer was not declared). You may automatically deal with these problems, for detailed information see also Basic Automation.","category":"page"},{"location":"qstart.html","page":"Quick Start","title":"Quick Start","text":"julia> m = vfinalize(m); vshow(m); # not `finalize`\nmodule test #(\n    parameter dummy = (10 << 2)\n)(\n    input CLK,\n    input RST,\n    input [7:0] din,\n    output reg [3:0] dout\n);\n    localparam A = 1;\n    localparam B = 2;\n    localparam C = (A + B);\n\n    reg dumreg;\n    wire [(A + (B << C))-1:0] dumwire;\n    logic duminfer;\n\n    always_ff @( posedge CLK ) begin\n        if (RST) begin\n            dout <= 0;\n        end else begin\n            dout <= din[3:0];\n        end\n    end\n    always_comb begin\n        dumreg = (|(dumwire));\n        duminfer = (~dumreg);\n    end\nendmodule\ntype: Vmodule","category":"page"},{"location":"midlevel.html#Mid-Level-Synthesis","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"","category":"section"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"CurrentModule = VerilogWriter\r\nDocTestSetup = quote\r\n    using VerilogWriter\r\nend","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"We offer here a tool to help creating a connection between multiple verilog modules.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"warning: Warning\nMethods described in this section is not fully debugged yet. Verilog codes generated using funtionalities in this page may contain unexpected behavior, and thus having precise inspection on output codes is desirable.","category":"page"},{"location":"midlevel.html#Midmodule","page":"Mid-Level Synthesis","title":"Midmodule","text":"","category":"section"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"Here we wrap a Vmodule object with Midmodule objects. ","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"julia> a = Randmmod(\"a\");\r\n\r\njulia> println(typeof(a));\r\nMidmodule\r\n\r\njulia> @Randmmod b; # declare Midmodule named \"b\" as variable `b`","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"Midmodule objects can be handled in a similar manner to that of Vmodule. You may add, for example, ports and always-blocks, using vpush!.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"julia> vpush!(a, @always (\r\n       counter <= counter + $(Wireexpr(8, 1))\r\n       ));\r\n\r\njulia> vshow(a.vmod);\r\nmodule a ();\r\n    always_ff @( unknownedge  ) begin\r\n        counter <= (counter + 8'd1);\r\n    end\r\nendmodule\r\ntype: Vmodule","category":"page"},{"location":"midlevel.html#Mmodgraph","page":"Mid-Level Synthesis","title":"Mmodgraph","text":"","category":"section"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"We handle connections in between Midmodules using Mmodgraph objects.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"julia> g = Mmodgraph();","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"Mmodgraph is a callable object, and you may register connections between Midmodules to this object.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"julia> g(a => b);","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"We also offer a method to convert Mmodgraph into a graph written in DOT language, and the connections can be visualized this way.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"julia> dotgen(g; dpi=196) |> println;\r\ndigraph{\r\nrankdir = LR;\r\ndpi = 196;\r\n\r\na [shape=oval];\r\nb [shape=oval];\r\na -> b;\r\n}","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"Using, for example, Graphviz, the graph below would be generated.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"(Image: )","category":"page"},{"location":"midlevel.html#Connect-Ports-between-Verilog-Modules","page":"Mid-Level Synthesis","title":"Connect Ports between Verilog Modules","text":"","category":"section"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"The connection in the example above connected Midmodule a and b. However, there is no data transaction available between the modules. You may explicitly register ports to be connected between Midmodules. Here we construct new connection from Midmodule a to c with an eight-bits wide data line.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"julia> @Randmmod c;\r\n\r\njulia> g(a => c, [(@oneport @out 8 dout) => (@oneport @in 8 din)]);","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"We declare the connection between a and c using Oneport. Note that at this time the Midmodules do not contain ports declared here. You also need to add the ports to each Midmodule object.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"julia> vpush!(a, @ports @out @logic 8 dout);\r\n\r\njulia> vpush!(c, @ports @in 8 din);","category":"page"},{"location":"midlevel.html#Automatically-Generated-Connections","page":"Mid-Level Synthesis","title":"Automatically-Generated Connections","text":"","category":"section"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"When adding connection to Mmodgraphs, VerilogWriter.jl automatically adds to both upstream and downstream module two ports, which are valid and update lines.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"These ports can be used to control timing when a transaction between Midmodules occurs.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"(Image: )","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"valid is the signal driven by upstream module, and when asserted the data lines connected between the modules should contain valid data.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"update is the signal driven by downstream module, and asserting the signal tells upstream modules that the data lines can be updated with new data.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"This may be similar to the First-Word-Fall-Through model in that downstream modules may process data before returning any signal (such as an acknowledgement signal).","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"As is often the case with handshaking signals, valid signals must not wait for the update signals. valid should be asserted independently from update (at least from update value at the same clock cycle) in order to avoid creating combinational loop in verilog codes.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"Note that VerilogWriter.jl only adds the ports to Midmodules, and thus you need to add to each Midmodule object logics that properly handle the valid and update signals. This also means that you may completely ignore the update and valid signals even when using Mmodgraph (you may need to connect the signals to 0 or 1 to suppress warnings from compilers, though).","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"To get the name of valid and update ports, you may call nametolower (for downstream facing ports) or nametoupper (for upstream facing ports) method with enum value imupdate or imvalid.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"julia> alb = @always (\r\n       $(nametoupper(imupdate)) <= 1; # always update\r\n       if $(nametoupper(imupdate)) & $(nametoupper(imvalid))\r\n           recv_count <= recv_count + $(Wireexpr(8, 1))\r\n       end\r\n       );\r\n\r\njulia> vpush!(b, alb);","category":"page"},{"location":"midlevel.html#Synchronizing-Transactions","page":"Mid-Level Synthesis","title":"Synchronizing Transactions","text":"","category":"section"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"g::Mmodgraph in the above example currently generates the graph below.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"(Image: )","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"When connecting more than one downstream Midmodule to one upstream Midmodule, VerilogWriter.jl automatically adds synchronizing logic to Mmodgraph. valid and update signals are modified automatically and a transaction between a and b/c does not complete unless both b and c assert update signal to a. From upstream module's (a's) perspective, b and c look like a single module which has one update and one valid port.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"julia> ala = @always (\r\n       $(nametolower(imvalid)) <= 1;\r\n       if $(nametolower(imvalid)) & $(nametolower(imupdate))\r\n           send_count <= send_count + $(Wireexpr(7, 1))\r\n       end\r\n       ); # the same `valid` and `update` wire is connected to both `b` and `c`\r\n\r\njulia> vpush!(a, ala); vshow(a.vmod);\r\nmodule a (\r\n    output logic [7:0] dout\r\n);\r\n    always_ff @( unknownedge  ) begin\r\n        counter <= (counter + 8'd1);\r\n    end\r\n    always_ff @( unknownedge  ) begin\r\n        valid_to_lower_port0 <= 1;\r\n        if ((valid_to_lower_port0 & update_from_lower_port0)) begin\r\n            send_count <= (send_count + 7'd1);\r\n        end\r\n    end\r\nendmodule\r\ntype: Vmodule","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"The same applies to cases where a single downstream Midmodule is connected to multiple upstream Midmodules. Note that ports other than valid and update in downstream Midmodule cannot be connected to multiple upstream ports, which is the same as connecting ports in raw verilog module instances. For now no warning and error is returned from VerilogWriter.jl even in such erroneous cases, and it can be detected, for instance, applying linter on generated verilog outputs.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"julia> @Randmmod d;\r\n\r\njulia> g(d => c, [(@oneport @out 32 douttoC) => (@oneport @in 32 dinfromD)]\r\n       ); # must not connect to `din` in `c`, which is already connected to `a`\r\n\r\njulia> vpush!(c, @oneport @in 32 dinfromD); vpush!(d, @oneport @out 32 douttoC);\r\n\r\njulia> vpush!(c, @always (\r\n       $(nametoupper(imupdate)) = 1\r\n       )); # connected to `update` of both `a` and `d`","category":"page"},{"location":"midlevel.html#Suppress-Synchronization-in-Connecting-Midmodules","page":"Mid-Level Synthesis","title":"Suppress Synchronization in Connecting Midmodules","text":"","category":"section"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"There are cases where multiple connection from one Mmodule should be completely independent from one another. In such cases you may wrap connection in Midport to separate connections to multiple groups.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"julia> @Randmmod e;\r\n\r\njulia> @assert 1 != defaultMidPid; # currently defaultMidPid == 0\r\n\r\njulia> vpush!(e, @oneport @in 8 dinfroma);\r\n\r\njulia> g(Midport(1, a) => Midport(defaultMidPid, e), \r\n       [(@oneport @out 8 dout) => (@oneport @in 8 dinfroma)]\r\n       ); # connect `a` at Midport id 1 to `e`","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"Currently g generates the graph below:","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"(Image: )","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"Connections between Midports is not synchronized if they have different Midport id (a member::Int of Midport). In the example above, a::Midmodule is connected to three Midmodules, which are b, c and e. Connection between a and e is assigned Midport id 1, while connection between others are assigned defaultMidPid (this port id is assigned to the connection which is registered to Mmodgraph without explicitly specifying port id). Therefore, transaction between a and b/c is synchronized through valid and update independently from transactions between a and e. As a consequence a needs to include additional logic to handle valid and update signal for Midport whose id is other than defaultMidPid.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"julia> vpush!(a, @always (\r\n       if $(nametolower(imvalid, 1)) & $(nametolower(imupdate, 1))\r\n           $(nametolower(imvalid, 1)) <= 0;\r\n       else\r\n           $(nametolower(imvalid, 1)) <= 1\r\n       end\r\n       )); # valid and update associated with Midport(1, a)","category":"page"},{"location":"midlevel.html#Generate-Vmodule-Objects","page":"Mid-Level Synthesis","title":"Generate Vmodule Objects","text":"","category":"section"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"After adding logics to each Midmodule, you may generate a list of Vmodules exported from Mmodgraph.","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"julia> vmods = layer2vmod!(g);\r\n\r\njulia> println(typeof(vmods));\r\nVector{Vmodule}","category":"page"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"At the head of the exported list of Vmodules is the top level Vmodule which represents the whole Mmodgraph, and the rest are the modules which are instanciated inside the top module. You may call vfinalize.(vmods) to further conduct wire width inferences and wire declarations.","category":"page"},{"location":"midlevel.html#Port-Lifting","page":"Mid-Level Synthesis","title":"Port Lifting","text":"","category":"section"},{"location":"midlevel.html","page":"Mid-Level Synthesis","title":"Mid-Level Synthesis","text":"Each Midmodule objects can have (verilog) ports that are not connected to other Midmodules. These ports are automatically added to the top level Vmodule when calling layer2vmod! and is accessible from outer verilog modules.","category":"page"},{"location":"fsm.html#Finite-State-Machine","page":"Finite State Machines","title":"Finite State Machine","text":"","category":"section"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"We offer here an easy way to construct a Finite State Machine (FSM). ","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"Finite State Machine is a common structure used in a hardware design. Offering a simple method to construct an FSM may be useful.","category":"page"},{"location":"fsm.html#Procedure-of-Designing-an-FSM","page":"Finite State Machines","title":"Procedure of Designing an FSM","text":"","category":"section"},{"location":"fsm.html#Construct-an-FSM","page":"Finite State Machines","title":"Construct an FSM","text":"","category":"section"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"First construct an FSM defining name of states and the machine itself.","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"@FSM\nFSM(name, state::String...)\nFSM(name, states::Vector{String})","category":"page"},{"location":"fsm.html#VerilogWriter.@FSM","page":"Finite State Machines","title":"VerilogWriter.@FSM","text":"@FSM(mname, states)\n\nCreate FSM with variables of (machine itself / states) names.\n\nWith the macro there is no need to explicitly make a string object for  machine/state names.\n\nExample\n\njulia> m = @FSM m1 (s1, s2); # same as \"@FSM(m1, (s1, s2))\"\n\njulia> vshow(m)\nreg m1;\n\nlocalparam s1 = 0;\nlocalparam s2 = 1;\n\ncase (m1)\n    s1: begin\n        \n    end\n    s2: begin\n        \n    end\nendcase\ntype: FSM\n\n\n\n\n\n","category":"macro"},{"location":"fsm.html#VerilogWriter.FSM-Tuple{Any, Vararg{String}}","page":"Finite State Machines","title":"VerilogWriter.FSM","text":"FSM(name, state::String...)\n\nCreate an FSM object with name name, whose states are state....\n\n\n\n\n\n","category":"method"},{"location":"fsm.html#VerilogWriter.FSM-Tuple{Any, Vector{String}}","page":"Finite State Machines","title":"VerilogWriter.FSM","text":"FSM(name, states::Vector{String})\n\nCreate an FSM object with name name, whose states are states.\n\n\n\n\n\n","category":"method"},{"location":"fsm.html#Add-Transition-Rules","page":"Finite State Machines","title":"Add Transition Rules","text":"","category":"section"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"Add a new rule with transadd!.","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"transadd!","category":"page"},{"location":"fsm.html#VerilogWriter.transadd!","page":"Finite State Machines","title":"VerilogWriter.transadd!","text":"transadd!(x::FSM, cond::Wireexpr, newtrans::Pair{String, String})\n\nAdd a new transition rule for the state machine x.\n\nThe new rule here is:\n\nThe transition from state newtrans[1] to state newtrans[2]\nThis transition occures when cond is true and the current state is newtrans[1]\n\nExamples\n\njulia> fsm = @FSM nstate (uno, dos, tres); # create a FSM\n\njulia> transadd!(fsm, (@wireexpr b1 == b2), @tstate uno => dos); # transition from \"uno\" to \"dos\" when \"b1 == b2\"\n\njulia> vshow(fsmconv(Case, fsm));\ncase (nstate)\n    uno: begin\n        if ((b1 == b2)) begin\n            nstate <= dos;\n        end\n    end\n    dos: begin\n        \n    end\n    tres: begin\n        \n    end\nendcase\ntype: Case\n\n\n\n\n\ntransadd!(x::FSM, rules::Vector{Tuple{Wireexpr, Pair{String, String}}})\n\nAdd muliple rules to x.\n\n\n\n\n\n","category":"function"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"As shown above cond is the condition to be true when the transition occurs, and as newtrans argument you assign a Pair object of strings, \"srcstate\" => \"deststate\". You may instead call macro @tstate srcstate => deststate.","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"@tstate","category":"page"},{"location":"fsm.html#VerilogWriter.@tstate","page":"Finite State Machines","title":"VerilogWriter.@tstate","text":"@tstate(arg)\n\nHelper macro for argument in transadd!. \n\nConvert a pair of variables to a pair of strings.\n\njulia> @tstate a => b\n\"a\" => \"b\"\n\njulia> m = @FSM machine s1, s2;\n\njulia> transadd!(m, (@wireexpr b), @tstate s1 => s2);\n\njulia> vshow(m)\nreg machine;\n\nlocalparam s1 = 0;\nlocalparam s2 = 1;\n\ncase (machine)\n    s1: begin\n        if (b) begin\n            machine <= s2;\n        end\n    end\n    s2: begin\n        \n    end\nendcase\ntype: FSM\n\n\n\n\n\n","category":"macro"},{"location":"fsm.html#Generate-Condition-to-be-True-when-Transition-Occurs","page":"Finite State Machines","title":"Generate Condition to be True when Transition Occurs","text":"","category":"section"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"After adding transition rules you may generate wireexpr which would be true only when the transition occurs.","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"transcond","category":"page"},{"location":"fsm.html#VerilogWriter.transcond","page":"Finite State Machines","title":"VerilogWriter.transcond","text":"transcond(m::FSM, states::Pair{String, String})\n\nGet the wireexpr whose value should be true iff the state of  the FSM changes from states[1] to states[2].\n\nExamples\n\njulia> m = @FSM fsm s1, s2, s3; transadd!(m, (@wireexpr b1 == TCOND), @tstate s1=>s2); vshow(fsmconv(Case, m));\ncase (fsm)\n    s1: begin\n        if ((b1 == TCOND)) begin\n            fsm <= s2;\n        end\n    end\n    s2: begin\n        \n    end\n    s3: begin\n        \n    end\nendcase\ntype: Case\n\njulia> t = transcond(m, @tstate s1 => s2); vshow(t);\n((fsm == s1) && (b1 == TCOND))\ntype: Wireexpr\n\njulia> t = transcond(m, @tstate s2 => s1);\nERROR: transition rule not registered for \"s2\" => \"s1\".\n\n\n\n\n\n","category":"function"},{"location":"fsm.html#Convert-from-FSM-to-Verilog-Codes","page":"Finite State Machines","title":"Convert from FSM to Verilog Codes","text":"","category":"section"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"We offer methods to generate several components in verilog, which compose FSM structure.","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"They are ","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"A case statement for transition between states\nreg declaration that holds the current state information.\nlocalparams each of which represents one state in the FSM.","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"fsmconv","category":"page"},{"location":"fsm.html#VerilogWriter.fsmconv","page":"Finite State Machines","title":"VerilogWriter.fsmconv","text":"fsmconv(::Type{Case}, x::FSM)\n\nConvert FSM object into Case object.\n\n\n\n\n\nfsmconv(::Type{Case}, x::FSM, atype::Atype)\n\nAccept as an argument atype to be used in assignments inside  a case statement. Defaults to ff in the method fsmconv(::Type{Case}, x::FSM).\n\n\n\n\n\nfsmconv(::Type{Ifcontent}, x::FSM)\n\nConvert FSM logic to Ifcontent object.\n\nWhen vshow(fsmconv(Ifcontent, x)) is evaluated one  case block will be the only output.\n\n\n\n\n\nfsmconv(::Type{Onedecl}, x::FSM)\n\nGenerate one reg declaration in verilog that holds the state value at the time.\n\n\n\n\n\nfsmconv(::Type{Decls}, x::FSM)\n\nGenerate Decls object from x.\n\n\n\n\n\nfsmconv(::Type{Localparams}, x::FSM)\n\nGenerate localparams that declare the value which corresponds to each state.\n\n\n\n\n\n","category":"function"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"vpush! is available to push all information above to a Vmodule object. You may also prewiew all of these with vshow(x::FSM).","category":"page"},{"location":"fsm.html#Struct-FSM-Description","page":"Finite State Machines","title":"Struct FSM Description","text":"","category":"section"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"push!(LOAD_PATH,\"../../src/\")\nusing VerilogWriter","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"println(showfield(FSM)) # hide","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"FSM","category":"page"},{"location":"fsm.html#VerilogWriter.FSM","page":"Finite State Machines","title":"VerilogWriter.FSM","text":"Struct for a Finite State Machine, not the Flying Spaghetti Monster.\n\nEach column of matrices corresponds to the source state, and row for  the destination state. Not supposed to directly edit the content of matrices without using handlers.\n\n[\n    false false \n    true  false\n]\n\nin transvalid means transition from the 1st state to  the 2nd state is provided.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference.html","page":"Reference","title":"Reference","text":"CurrentModule = VerilogWriter","category":"page"},{"location":"reference.html","page":"Reference","title":"Reference","text":"No detailed descriptions available yet.","category":"page"},{"location":"reference.html","page":"Reference","title":"Reference","text":"Still ?<function-name> on IJulia, Julia REPL will return docstrings for most of the functions, structs, and constant values in this module.","category":"page"},{"location":"index.html#VerilogWriter.jl","page":"Introduction","title":"VerilogWriter.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule = VerilogWriter","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using VerilogWriter","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"A package to generate Verilog/SystemVerilog codes (primarily targeted on FPGAs) and offer an introductory HLS (high level synthesis) on Julia.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"You may:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Convert Verilog-like Julia code into objects\nAutomatically infer wire width in always-blocks\nConstruct Finite State Machines in a simple method","category":"page"},{"location":"index.html#Brief-Introduction","page":"Introduction","title":"Brief Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"If you have IJulia locally, execute","category":"page"},{"location":"index.html#In[1]","page":"Introduction","title":"In[1]","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using VerilogWriter","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(or make .jl file and execute codes with julia <filename>.jl instead.) and then","category":"page"},{"location":"index.html#In[2]","page":"Introduction","title":"In[2]","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"x = @always (\n    dout = d1 + d2;\n    if b1\n        dout = ~d1\n    elseif b2 \n        dout = ~d2\n    end\n)\nvshow(x)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(note that variables such as dout, b1 are not declared anywhere.)","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and now you see the following:","category":"page"},{"location":"index.html#Out[2]","page":"Introduction","title":"Out[2]","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"always_comb begin\n    dout = (d1 + d2);\n    if (b1) begin\n        dout = ~d1;\n    end else if (b2) begin\n        dout = ~d2;\n    end\nend\ntype: Alwayscontent","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Another example is ","category":"page"},{"location":"index.html#In[3]","page":"Introduction","title":"In[3]","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"ps = @ports (\n    @in b1, CLK, RST\n)\nds = @decls (\n    @reg 8 dreg1\n)\nc = always(:(\n    reg1 <= dreg1;\n    if b1 \n        reg2 <= reg1[7:6]\n        reg3 <= reg1[0]\n        reg4 <= reg1\n        reg5 <= $(Wireexpr(32, 4))\n    else \n        reg5 <= 0\n    end\n))\n\nm = Vmodule(\"test\")\nvpush!.(m, (ps, ds, c))\nvshow(vfinalize(m))","category":"page"},{"location":"index.html#Out[3]","page":"Introduction","title":"Out[3]","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"module test (\n    input b1,\n    input CLK,\n    input RST\n);\n    reg [7:0] dreg1;\n    logic [7:0] reg1;\n    logic [1:0] reg2;\n    logic reg3;\n    logic [7:0] reg4;\n    logic [31:0] reg5;\n\n    always_ff @( posedge CLK ) begin\n        if (RST) begin\n            reg1 <= 0;\n            reg2 <= 0;\n            reg3 <= 0;\n            reg4 <= 0;\n            reg5 <= 0;\n        end else begin\n            reg1 <= dreg1;\n            if (b1) begin\n                reg2 <= reg1[7:6];\n                reg3 <= reg1[0];\n                reg4 <= reg1;\n                reg5 <= 32'd4;\n            end else begin\n                reg5 <= 0;\n            end\n        end\n    end\nendmodule\ntype: Vmodule","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(of course this verilog module itself is far from being useful.)","category":"page"},{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This package offers a simple method to write on Julia Verilog/SystemVerilog codes not as raw strings but as objects with certain structures, such as always-block-objects, port-declaration-objects, and so on (not as sophisticated as, for example, Chisel is, though).","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The motivation here is that it would be nice if we could write Verilog/SystemVerilog with the power of the Julia language, with a minimal amount of additional syntaxes (function calls, constructors, etc.). ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"As in the examples above, we offer, for instance, simple macros to convert Verilog-like Julia code into certain objects that have proper structure found in Verilog codes.","category":"page"},{"location":"index.html#Usage","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This module is not yet registered, so","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/t-f-marfil/VerilogWriter.jl\"))","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"would work. Or simply ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"git clone \"https://github.com/t-f-marfil/VerilogWriter.jl\"","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and try tutorial.ipynb in /src.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Dockerfile to build environment with julia and this module is also available in this repository.","category":"page"},{"location":"index.html#What-is-Left-to-be-Done","page":"Introduction","title":"What is Left to be Done","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"It seems too many things are left to be done to make this VerilogWriter.jl, at least to some extent, useful, but to list few of them, ","category":"page"},{"location":"index.html#Unsupported-Syntaxes","page":"Introduction","title":"Unsupported Syntaxes","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Lots of operators and syntaxes in Verilog/SystemVerilog is not supported (e.g. for, generate for, interfaces, tasks, always_latch, some of indexed part select, and so on), although some of them can be replaced by using Julia syntaxes instead (e.g. using Julia for loop and generate multiple always blocks instead of Verilog), or rather it is better to use Julia-for instead to make use of the power of Julia language (Verilog for-loop which changes its behavior according to parameters of the module cannot be imitated this way).","category":"page"},{"location":"index.html#Not-Enough-Handlers-of-the-Structs","page":"Introduction","title":"Not Enough Handlers of the Structs","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We offer here some structs to imitate what is done in Verilog codes, but few functions to handle them are offered together. Still you can construct some more functions to handle the structs offered here, making it a little easier to make more complex Verilog modules.","category":"page"},{"location":"inference.html#Basic-Automation","page":"Basic Automation","title":"Basic Automation","text":"","category":"section"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"CurrentModule = VerilogWriter\nDocTestSetup = quote\n    using VerilogWriter\nend","category":"page"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"We offer some tools to automatically add additional information inferred from a given Verilog-like codes.","category":"page"},{"location":"inference.html#Reset-in-Always-Blocks","page":"Basic Automation","title":"Reset in Always Blocks","text":"","category":"section"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"Given a content of always blocks, you may automatically reset all wires which appear at the LHS in the block.","category":"page"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"autoreset","category":"page"},{"location":"inference.html#VerilogWriter.autoreset","page":"Basic Automation","title":"VerilogWriter.autoreset","text":"autoreset(x::Ifcontent; clk=defclk, rst=defrst, edge=posedge, reg2d::Dict{String, Wireexpr}=Dict{String, Wireexpr}())\n\nGiven x::Ifcontent, returns always_ff/always block that  resets every wire/regs appear at Lhs of x.\n\nThis is synchronous reset. reg2d is a pair of \"name of wire\" and \"ram depth in wireexpr\".\n\n\n\n\n\nautoreset(x::Alwayscontent; clk=defclk, rst=defrst, edge=posedge, reg2d::Dict{String, Wireexpr}=Dict{String, Wireexpr}())\n\nAutomatically reset wires which appear in x::Alwayscontent.\n\nSensitivity list in the original Alwayscontent will be ignored.\n\nExample\n\nc = @always (\n    r1 <= r2;\n    if b1 \n        r2 <= 0\n        r3 <= r3 + r4\n    else \n        r3 <= 0\n    end\n) \nr = autoreset(c; clk=(@wireexpr clk), rst=(@wireexpr ~resetn))\nvshow(r)\n\n# output\n\nalways_ff @( posedge clk ) begin\n    if ((~resetn)) begin\n        r1 <= 0;\n        r2 <= 0;\n        r3 <= 0;\n    end else begin\n        r1 <= r2;\n        if (b1) begin\n            r2 <= 0;\n            r3 <= (r3 + r4);\n        end else begin\n            r3 <= 0;\n        end\n    end\nend\ntype: Alwayscontent\n\n\n\n\n\nautoreset(x::Vmodule; clk=defclk, rst=defrst, reg2d::Dict{String, Wireexpr}=Dict{String, Wireexpr}())\n\nReturn a new Vmodule object whose Alwayscontents are all reset.\n\n\n\n\n\n","category":"function"},{"location":"inference.html#Automatic-Wire-Declaration","page":"Basic Automation","title":"Automatic Wire Declaration","text":"","category":"section"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"autodecl","category":"page"},{"location":"inference.html#VerilogWriter.autodecl","page":"Basic Automation","title":"VerilogWriter.autodecl","text":"autodecl(x, env::Vmodenv)::Vmodenv\n\nDeclare wires in x which are not yet declared in env. Raise error when not enough information to determine width of all wires is given.\n\nType of x is restricted to the type wireextract! accepts.\n\nExamples\n\nInference Success\n\npts = @ports (\n        @in 16 din;\n        @in b1\n)\nenv = Vmodenv(pts)\n\nc = @ifcontent (\n    reg1 = 0;\n    reg2 = din;\n    if b1 \n        reg1 = din[10:7]\n    end\n) \n\nvenv = autodecl(c, env)\nvshow(venv)\n\n# output\n\ninput [15:0] din\ninput b1\n\nlogic [3:0] reg1;\nlogic [15:0] reg2;\ntype: Vmodenv\n\nYou may also declare ports/wires beforehand whose width is unknown.\n\nWhen declaring ports/wires without specifying its bit width, assign -1 as its width.\n\nps = @ports (\n    @in 2 x;\n    @in -1 y;\n    @out @reg A z\n) \nds = @decls (\n    @wire -1 w1;\n    @wire B w2\n)\n\nab = @always (\n    z <= r1 + r2 + r3;\n    r4 <= (y & w1) << r1[1:0];\n    r5 <= y + w2\n)\nenv = Vmodenv(Parameters(), ps, Localparams(), ds)\nnenv = autodecl(ab.content, env)\n\nvshow(nenv)\n\n# output\n\ninput [1:0] x\ninput [B-1:0] y\noutput reg [A-1:0] z\n\nwire [B-1:0] w1;\nwire [B-1:0] w2;\nlogic [A-1:0] r1;\nlogic [A-1:0] r2;\nlogic [A-1:0] r3;\nlogic [B-1:0] r4;\nlogic [B-1:0] r5;\ntype: Vmodenv\n\nFail in Inference\n\nc = @ifcontent (\n    reg1 = 0;\n    reg2 = din;\n    if b1 \n        reg1 = din[10:7]\n    end\n) \n\nautodecl(c)\n\n# output\n\nERROR: Wire width cannot be inferred for the following wires.\n1. b1\n2. reg2 = din\n\n\n\n\n\nautodecl(x)::Vmodenv\n\nConduct wire width inference under an empty environment.\n\n\n\n\n\nautodecl(x::Vmodule)::Vmodule\n\nUsing ports, parameters, localparams, decls in x::Vmodule  as an environment, conduct wire width inference and  return a new Vmodule object with inferred wires.\n\n\n\n\n\n","category":"function"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"env in an argument for autodecl is of type Vmodenv.","category":"page"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"vfinalize","category":"page"},{"location":"inference.html#VerilogWriter.vfinalize","page":"Basic Automation","title":"VerilogWriter.vfinalize","text":"vfinalize(x::Vmodule)\n\nReturn new Vmodule object generated by applying  autoreset and autodecl on x.\n\nreg2d is automatically generated before calling autodecl. This is based on the observation that depth of RAM can not be inferred usually.\n\n\n\n\n\n","category":"function"},{"location":"types.html#Basic-Types","page":"Basic Types","title":"Basic Types","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"CurrentModule = VerilogWriter\nDocTestSetup = quote\n    using VerilogWriter\nend","category":"page"},{"location":"types.html#Structs-Description","page":"Basic Types","title":"Structs Description","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"This module offers several types that contain a structure of Verilog components, major parts of which are listed below. ","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Parameters\nOneparam\nPorts\nOneport\nPortdirec\nWiretype\nLocalparams\nOnelocalparam\nWireexpr\nWireop\nDecls\nOnedecl\nAssign\nAlwayscontent\nAlassign\nIfelseblock\nIfcontent\nAtype\nEdge\nVmodinst\nVmodule\nVmodenv","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"push!(LOAD_PATH,\"../../src/\")\nusing VerilogWriter","category":"page"},{"location":"types.html#Parameters","page":"Basic Types","title":"Parameters","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Parameters)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Parameters","category":"page"},{"location":"types.html#VerilogWriter.Parameters","page":"Basic Types","title":"VerilogWriter.Parameters","text":"List of parameters.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Oneparam","page":"Basic Types","title":"Oneparam","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Oneparam)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Oneparam","category":"page"},{"location":"types.html#VerilogWriter.Oneparam","page":"Basic Types","title":"VerilogWriter.Oneparam","text":"Parameter in verilog.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Ports","page":"Basic Types","title":"Ports","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Ports)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Ports","category":"page"},{"location":"types.html#VerilogWriter.Ports","page":"Basic Types","title":"VerilogWriter.Ports","text":"Gather multiple ports.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Oneport","page":"Basic Types","title":"Oneport","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Oneport)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Oneport","category":"page"},{"location":"types.html#VerilogWriter.Oneport","page":"Basic Types","title":"VerilogWriter.Oneport","text":"Represent a single port declaration.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Portdirec","page":"Basic Types","title":"Portdirec","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Portdirec)))) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Portdirec","category":"page"},{"location":"types.html#VerilogWriter.Portdirec","page":"Basic Types","title":"VerilogWriter.Portdirec","text":"Port direction object.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Wiretype","page":"Basic Types","title":"Wiretype","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Wiretype)))) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Wiretype","category":"page"},{"location":"types.html#VerilogWriter.Wiretype","page":"Basic Types","title":"VerilogWriter.Wiretype","text":"Wiretype object.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Localparams","page":"Basic Types","title":"Localparams","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Localparams)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Localparams","category":"page"},{"location":"types.html#VerilogWriter.Localparams","page":"Basic Types","title":"VerilogWriter.Localparams","text":"Multiple localparams.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Onelocalparam","page":"Basic Types","title":"Onelocalparam","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Onelocalparam)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Onelocalparam","category":"page"},{"location":"types.html#VerilogWriter.Onelocalparam","page":"Basic Types","title":"VerilogWriter.Onelocalparam","text":"One localparam.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Wireexpr","page":"Basic Types","title":"Wireexpr","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Wireexpr)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Wireexpr\n\nWireexpr(n::String)\nWireexpr(n::Symbol)\nWireexpr(n::Int)\nWireexpr(op::Wireop, w::Wireexpr...)\nWireexpr(op::Wireop, v::Vector{Wireexpr})\nWireexpr(n::String, msb::T) where {T <: Union{Int, Wireexpr}}\nWireexpr(n::String, msb::T1, lsb::T2) where {T1 <: Union{Int, Wireexpr}, T2 <: Union{Int, Wireexpr}}\nWireexpr(w::Int, n::Int)\nWireexpr(expr::Wireexpr)\nWireexpr()","category":"page"},{"location":"types.html#VerilogWriter.Wireexpr","page":"Basic Types","title":"VerilogWriter.Wireexpr","text":"Wire expressions in verilog. \n\nContains unnecessary information to handle all the wires in the same type. \n\nOne motivation to avoid making different types of  wires (e.g. using parametric types) is that it seemed beneficial to have multiple wires in a vector, and that  it is sometime a disadvantage in performance to use  abstract types when creating vectors.\n\nSome operators on wires in Verilog, which are listed in Enum Wireop,  are overloaded for Wireexpr. Note that reduction operators (unary &, |, ^) are not in Julia,  and logical and, or (&&, ||) can be applied only for booleans in Julia, thus  are not available as an operator for Wireexpr objects.\n\nExamples\n\njulia> w1 = @wireexpr x + y;\n\njulia> w2 = @wireexpr z;\n\njulia> vshow(w1 & w2);\n((x + y) & z)\ntype: Wireexpr\n\njulia> w3 = @wireexpr x;\n\njulia> w4 = @wireexpr y && z; # && is available inside `@wireexpr`.\n\njulia> vshow(w3 | w4)\n(x | (y && z))\ntype: Wireexpr\n\n\n\n\n\n","category":"type"},{"location":"types.html#VerilogWriter.Wireexpr-Tuple{String}","page":"Basic Types","title":"VerilogWriter.Wireexpr","text":"Wireexpr(n::String)\n\nCase where no slice is needed.\n\n\n\n\n\n","category":"method"},{"location":"types.html#VerilogWriter.Wireexpr-Tuple{Symbol}","page":"Basic Types","title":"VerilogWriter.Wireexpr","text":"Wireexpr(n::Symbol)\n\nConvert Symbol to String and construct Wireexpr.\n\n\n\n\n\n","category":"method"},{"location":"types.html#VerilogWriter.Wireexpr-Tuple{Int64}","page":"Basic Types","title":"VerilogWriter.Wireexpr","text":"Wireexpr(n::Int)\n\nLiteral of Integer.\n\n\n\n\n\n","category":"method"},{"location":"types.html#VerilogWriter.Wireexpr-Tuple{Wireop, Vararg{Wireexpr}}","page":"Basic Types","title":"VerilogWriter.Wireexpr","text":"Wireexpr(op::Wireop, w::Wireexpr...)\n\nApply an operation on w wires.\n\nExamples\n\njulia> a = @wireexpr a; b = @wireexpr b;\n\njulia> c = Wireexpr(add, a, b); # equivalent to @wireexpr $a + $b\n\njulia> vshow(c);\n(a + b)\ntype: Wireexpr\n\njulia> d = Wireexpr(redor, a); vshow(d); # @wireexpr |($a)\n(|(a))\ntype: Wireexpr\n\n\n\n\n\n","category":"method"},{"location":"types.html#VerilogWriter.Wireexpr-Tuple{Wireop, Vector{Wireexpr}}","page":"Basic Types","title":"VerilogWriter.Wireexpr","text":"Wireexpr(op::Wireop, v::Vector{Wireexpr})\n\nApply an operation on wires in v.\n\n\n\n\n\n","category":"method"},{"location":"types.html#VerilogWriter.Wireexpr-Union{Tuple{T}, Tuple{String, T}} where T<:Union{Int64, Wireexpr}","page":"Basic Types","title":"VerilogWriter.Wireexpr","text":"Wireexpr(n::String, msb::T) where {T <: Union{Int, Wireexpr}}\n\nGet one bit at msb from n.\n\n\n\n\n\n","category":"method"},{"location":"types.html#VerilogWriter.Wireexpr-Union{Tuple{T2}, Tuple{T1}, Tuple{String, T1, T2}} where {T1<:Union{Int64, Wireexpr}, T2<:Union{Int64, Wireexpr}}","page":"Basic Types","title":"VerilogWriter.Wireexpr","text":"Wireexpr(n::String, msb::T1, lsb::T2) where {T1 <: Union{Int, Wireexpr}, T2 <: Union{Int, Wireexpr}}\n\nSlice of n from msb to lsb.\n\nIndex for wires can be Int or Wireexpr.\n\n\n\n\n\n","category":"method"},{"location":"types.html#VerilogWriter.Wireexpr-Tuple{Int64, Int64}","page":"Basic Types","title":"VerilogWriter.Wireexpr","text":"Wireexpr(w::Integer, n::Integer)\n\nLiteral with width specification, printed in the decimal format.\n\n\n\n\n\n","category":"method"},{"location":"types.html#VerilogWriter.Wireexpr-Tuple{Wireexpr}","page":"Basic Types","title":"VerilogWriter.Wireexpr","text":"Wireexpr(expr::Wireexpr)\n\nReturn the argument itself, used in slice construction to make it possible to apply the same method to msb as Int and as Wireexpr.\n\n\n\n\n\n","category":"method"},{"location":"types.html#VerilogWriter.Wireexpr-Tuple{}","page":"Basic Types","title":"VerilogWriter.Wireexpr","text":"Wireexpr()\n\nCreate an empty expression.\n\n\n\n\n\n","category":"method"},{"location":"types.html#Wireop","page":"Basic Types","title":"Wireop","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Wireop)))) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Wireop","category":"page"},{"location":"types.html#VerilogWriter.Wireop","page":"Basic Types","title":"VerilogWriter.Wireop","text":"Verilog operators.\n\nUnary &, | does not exist so explicitly call as function e.g. &(wire), |(wire) (& behaves in a wickedmanner...?), and are only available inside quoted expressions. Xor in verilog ^ is in Julia exponential operator, and the difference in an association exists.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Decls","page":"Basic Types","title":"Decls","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Decls)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Decls","category":"page"},{"location":"types.html#VerilogWriter.Decls","page":"Basic Types","title":"VerilogWriter.Decls","text":"Multiple wire declarations.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Onedecl","page":"Basic Types","title":"Onedecl","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Onedecl)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Onedecl","category":"page"},{"location":"types.html#VerilogWriter.Onedecl","page":"Basic Types","title":"VerilogWriter.Onedecl","text":"Represent one wire declaration.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Assign","page":"Basic Types","title":"Assign","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Assign)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Assign","category":"page"},{"location":"types.html#VerilogWriter.Assign","page":"Basic Types","title":"VerilogWriter.Assign","text":"Assign one statement.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Alwayscontent","page":"Basic Types","title":"Alwayscontent","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Alwayscontent)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Alwayscontent","category":"page"},{"location":"types.html#VerilogWriter.Alwayscontent","page":"Basic Types","title":"VerilogWriter.Alwayscontent","text":"Represent always blocks.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Alassign","page":"Basic Types","title":"Alassign","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Alassign)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Alassign","category":"page"},{"location":"types.html#VerilogWriter.Alassign","page":"Basic Types","title":"VerilogWriter.Alassign","text":"Assign statement inside always blocks.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Ifelseblock","page":"Basic Types","title":"Ifelseblock","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Ifelseblock)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Ifelseblock","category":"page"},{"location":"types.html#VerilogWriter.Ifelseblock","page":"Basic Types","title":"VerilogWriter.Ifelseblock","text":"Container of an if-else block. Parametrized by T for mutual recursion. Used as Ifelseblock = Ifelseblock_inner{Case}.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Ifcontent","page":"Basic Types","title":"Ifcontent","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Ifcontent)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Ifcontent","category":"page"},{"location":"types.html#VerilogWriter.Ifcontent","page":"Basic Types","title":"VerilogWriter.Ifcontent","text":"Container of one if-block (, one elseif block, or one else block).\n\nParametrized by T, U only for mutual recursion with Ifelseblock and Case, thus used as Ifcontent_inner{Ifelseblock, Case}, which is aliased as Ifcontent.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Atype","page":"Basic Types","title":"Atype","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Atype)))) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Atype","category":"page"},{"location":"types.html#VerilogWriter.Atype","page":"Basic Types","title":"VerilogWriter.Atype","text":"Type of always blocks.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Edge","page":"Basic Types","title":"Edge","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Edge)))) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Edge","category":"page"},{"location":"types.html#VerilogWriter.Edge","page":"Basic Types","title":"VerilogWriter.Edge","text":"Edge in sensitivity lists.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Vmodinst","page":"Basic Types","title":"Vmodinst","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Vmodinst)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Vmodinst","category":"page"},{"location":"types.html#VerilogWriter.Vmodinst","page":"Basic Types","title":"VerilogWriter.Vmodinst","text":"Represents module instantiation.\n\ni = Vmodinst(\n    \"mod1\",\n    \"u1\",\n    [\n        \"A\" => Wireexpr(15)\n    ],\n    [\n        \"p1\" => (@wireexpr x << 1),\n        \"p2\" => (@wireexpr y)\n    ]\n)\nvshow(i)\n\n# output\n\nmod1 #(\n    .A(15)\n) u1 (\n    .p1((x << 1)),\n    .p2(y)\n);\ntype: Vmodinst\n\nFor convenient instantiation  see also @preport and naiveinst.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Vmodule","page":"Basic Types","title":"Vmodule","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Vmodule)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Vmodule","category":"page"},{"location":"types.html#VerilogWriter.Vmodule","page":"Basic Types","title":"VerilogWriter.Vmodule","text":"Represents one verilog module.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Vmodenv","page":"Basic Types","title":"Vmodenv","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"println(showfield(Vmodenv)) # hide","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Vmodenv","category":"page"},{"location":"types.html#VerilogWriter.Vmodenv","page":"Basic Types","title":"VerilogWriter.Vmodenv","text":"Environment in which wire width inference is done.\n\n\n\n\n\n","category":"type"},{"location":"types.html#Converter-Macros","page":"Basic Types","title":"Converter Macros","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"As in previous examples we offer macros to convert Julia syntax into certain types described above. You may use these instead of calling constructors.","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"note: Note\nNote that conveter functions are now deprecated, everything should be handled with the macros.","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"All the macros listed below accept Expr object as its argument (e.g. @mac x = 10 internally takes :(x = 10) as its argument, see Julia Documents for more information.), and that is why variables inside the argument do not have to be declared anywhere else in the source code. The syntaxes each function requires in an argument are also described below (or may be easily inferred from the examples in this page and Quick Start).","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"(be care full not to foreget (one space) between macros and (, i.e. @macro(a,b) and @macro (a,b) are different, and the latter is used here.)","category":"page"},{"location":"types.html#List-of-Converter-Macros","page":"Basic Types","title":"List of Converter Macros","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Written inside parentheses are the types of objects the functions return.","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"parameters (Parameters)\noneparam (Oneparam)\nports (Ports)\nportoneline (Oneport)\nwireexpr (Wireexpr)\nlocalparams (Localparams)\nonelocalparam (Onelocalparam)\ndecls (Decls)\ndecloneline (Vector{Onedecl})\nalways (Alwayscontent)","category":"page"},{"location":"types.html#parameters","page":"Basic Types","title":"parameters","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"parameters(expr::Expr)","category":"page"},{"location":"types.html#VerilogWriter.parameters-Tuple{Expr}","page":"Basic Types","title":"VerilogWriter.parameters","text":"parameters(expr::Expr)\n\nMultiple parameters.\n\nUsing convert and localparams inside.\n\nExample\n\njulia> v = @parameters (\n       x = 10;\n       y = 20;\n       z = 30\n       );\n\njulia> vshow(v);\n#(\n    parameter x = 10,\n    parameter y = 20,\n    parameter z = 30\n)\ntype: Parameters\n\n\n\n\n\n","category":"method"},{"location":"types.html#oneparam","page":"Basic Types","title":"oneparam","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"oneparam(expr::Expr)","category":"page"},{"location":"types.html#VerilogWriter.oneparam-Tuple{Expr}","page":"Basic Types","title":"VerilogWriter.oneparam","text":"oneparam(expr::Expr)\n\nOne parameter. \n\nSyntax\n\n<paramname> = <val::Int>\n\njulia> vshow(@oneparam x = 10);\nparameter x = 10\ntype: Oneparam\n\n\n\n\n\n","category":"method"},{"location":"types.html#ports","page":"Basic Types","title":"ports","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"ports(::Expr)\nports(::Vector{Oneport})","category":"page"},{"location":"types.html#VerilogWriter.ports-Tuple{Expr}","page":"Basic Types","title":"VerilogWriter.ports","text":"ports(expr::Expr)\n\nConvert Julia AST into port declarations as Ports object.\n\nSyntax\n\n<portoneline>[;<portoneline>;...]\n\nMultiple lines of portoneline expressions  separated by ; can be accepted. \n\nExample\n\njulia> pp = @ports (\n       @in p1;\n       @in @wire 8 p2, p3, p4;\n       @out @reg 2 p5, p6\n       );\n\njulia> vshow(pp);\n(\n    input p1,\n    input [7:0] p2,\n    input [7:0] p3,\n    input [7:0] p4,\n    output reg [1:0] p5,\n    output reg [1:0] p6\n);\ntype: Ports\n\n\n\n\n\n","category":"method"},{"location":"types.html#VerilogWriter.ports-Tuple{Vector{Oneport}}","page":"Basic Types","title":"VerilogWriter.ports","text":"ports(expr::Vector{Oneport})\n\nInsertion through metaprogramming.\n\nExample\n\njulia> a = @portoneline @in 8 d1, d2, d3;\n\njulia> b = @ports (\n       @in d0;\n       $a;\n       @out @reg 8 dout\n       );\n\njulia> vshow(b);\n(\n    input d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [7:0] d3,\n    output reg [7:0] dout\n);\ntype: Ports\n\n\n\n\n\n","category":"method"},{"location":"types.html#portoneline","page":"Basic Types","title":"portoneline","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"portoneline(::Expr)","category":"page"},{"location":"types.html#VerilogWriter.portoneline-Tuple{Expr}","page":"Basic Types","title":"VerilogWriter.portoneline","text":"portoneline(expr::Expr)\n\nParse Julia AST to one line of port declaration as Oneport.\n\nSyntax\n\n@in <wirename>, @out <wirename>\n\nOne port declaration of width 1.\n\n@in/@out <wirename1, wirename2, ...>\n\nMultiple port declaration of width 1 in one line.\n\n@in/@out <width> <wirename1[, wirename2, ...]>\n\nPort declarations of width <width>.\n\n@in/@out @<wiretype> [<width>] <wirename1[, wirename2, ...]>\n\nPort declaration with wiretypes [of width <width>].\n\nExamples\n\njulia> p1 = @portoneline @in din;\n\njulia> vshow(p1);\ninput din\ntype: Oneport\n\njulia> p2 = (@portoneline @out din1, din2, din3); vshow(p2);\noutput din1\ntype: Oneport\noutput din2\ntype: Oneport\noutput din3\ntype: Oneport\n\njulia> p3 = (@portoneline @in 8 din); vshow(p3);\ninput [7:0] din\ntype: Oneport\n\njulia> p4 = (@portoneline @out @reg 8 dout); vshow(p4);\noutput reg [7:0] dout\ntype: Oneport\n\njulia> p5 = (@portoneline @out (A+B)<<2 x, y); vshow(p5); # width with parameter\noutput [((A + B) << 2)-1:0] x\ntype: Oneport\noutput [((A + B) << 2)-1:0] y\ntype: Oneport\n\n\n\n\n\n","category":"method"},{"location":"types.html#wireexpr","page":"Basic Types","title":"wireexpr","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"wireexpr(::Expr)\nwireexpr(::Wireexpr)","category":"page"},{"location":"types.html#VerilogWriter.wireexpr-Tuple{Expr}","page":"Basic Types","title":"VerilogWriter.wireexpr","text":"wireexpr(expr::Expr)\n\nParse one wire expression. Be sure to put 'two e's' in wir'ee'xpr, not 'wirexpr'.\n\nSyntax\n\nPart of what can be done in Verilog can be accepted,  such as din[7:0], (w1 + w2) << 5\n\n<wirename>\n\nOne wire, without slicing or bit-selecting.\n\n<val::Int>, <val::hex>, <val::bin>\n\nLiterals, e.g. 5, 0x1f, 0b10.\n\n<wire> <op> <wire>, <op> <wire>\n\nUnary and binary operators.  For reduction operators (unary &, |, ^), since these are  not operators in Julia, write it in the form of function  call explicitly, i.e. &(wire), |(wire) instead of doing ^wire. Note that we use ^ as xor just as in Verilog, though this is not  a xor operator in Julia.\n\n<wire>[<wire>:<wire>], <wire>[<wire>]\n\nBit select and slicing as in Verilog/SystemVerilog. Does not reject even if both wires in [<wire>:<wire>] are not of constant value although it is not a valid verilog syntax.\n\nwire[<wire>-:<wire>]\n\nIndexed part select. Does not reject even if <wire> after -: is not of constant value. As using - operator and : (quote) in Julia syntax,  no spaces between <wire>(here)-:(and here)<wire> are allowed,  and <wire> after -: should in most cases be put inside parentheses.\n\nNote that because : (quote) is used inside quote,  you (for now) cannot embed objects here through Metaprogramming.\n\ne.g. w = (@wireexpr w); always(:(x[A-:($w)] <= y)) is not  allowed. \n\nIn such cases use constructors instead as shown below.\n\njulia> e = Wireexpr(ipselm, @wireexpr(x), @wireexpr(A), @wireexpr(w)); # Indexed Part SELect with Minus operator \n\njulia> @testonlyexport; vshow(oneblock(:($(e) <= y))[2] |> eval);\nx[A -: w] <= y;\ntype: Alassign\n\nExamples\n\njulia> (@wireexpr w) |> vshow;\nw\ntype: Wireexpr\n\njulia> (@wireexpr w1 & &(w2)) |> vshow;\n(w1 & (&(w2)))\ntype: Wireexpr\n\njulia> (@wireexpr w[i:0]) |> vshow;\nw[i:0]\ntype: Wireexpr\n\njulia> (@wireexpr w[(P*Q)-:(R+10)]) |> vshow;\nw[(P * Q) -: (R + 10)]\ntype: Wireexpr\n\n\n\n\n\n\n","category":"method"},{"location":"types.html#VerilogWriter.wireexpr-Tuple{Wireexpr}","page":"Basic Types","title":"VerilogWriter.wireexpr","text":"wireexpr(expr::Wireexpr)\n\nInsertion through metaprogramming.\n\nExample\n\njulia> w = @wireexpr x + y;\n\njulia> e = :(a + |($(w) & z));\n\njulia> wireexpr(e) |> eval |> vshow;\n(a + (|(((x + y) & z))))\ntype: Wireexpr\n\n\n\n\n\n","category":"method"},{"location":"types.html#localparams","page":"Basic Types","title":"localparams","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"localparams(expr::Expr)","category":"page"},{"location":"types.html#VerilogWriter.localparams-Tuple{Expr}","page":"Basic Types","title":"VerilogWriter.localparams","text":"localparams(expr::Expr)\n\nMultiple localparams.\n\nExamples\n\njulia> p = @localparams x = 10; vshow(p);\nlocalparam x = 10;\ntype: Localparams\n\njulia> p = @localparams (\n       a = 111;\n       b = 222;\n       c = 333\n       );\n\njulia> vshow(p);\nlocalparam a = 111;\nlocalparam b = 222;\nlocalparam c = 333;\ntype: Localparams\n\n\n\n\n\n","category":"method"},{"location":"types.html#onelocalparam","page":"Basic Types","title":"onelocalparam","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"onelocalparam(expr::Expr)","category":"page"},{"location":"types.html#VerilogWriter.onelocalparam-Tuple{Expr}","page":"Basic Types","title":"VerilogWriter.onelocalparam","text":"onelocalparam(expr::Expr)\n\nOne localparam object. The syntax is the same as oneparam.\n\nExample\n\njulia> vshow(@onelocalparam x = 100)\nlocalparam x = 100;\ntype: Onelocalparam\n\n\n\n\n\n","category":"method"},{"location":"types.html#decls","page":"Basic Types","title":"decls","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"decls(::Expr)\ndecls(::Vector{Onedecl})\ndecls(expr::Decls...)","category":"page"},{"location":"types.html#VerilogWriter.decls-Tuple{Expr}","page":"Basic Types","title":"VerilogWriter.decls","text":"decls(expr::Expr)\n\nParse Julia AST into wire declaration section object Decls.\n\nSyntax\n\n<onedecl>[;<onedecl>;...]\n\nMultiple decloneline expressions which are concatenated  by ; can be accepted.\n\nExample\n\njulia> d = @decls (\n       @wire w1;\n       @reg 8 w2,w3,w4;\n       @logic 32 w5\n       );\n\njulia> vshow(d)\nwire w1;\nreg [7:0] w2;\nreg [7:0] w3;\nreg [7:0] w4;\nlogic [31:0] w5;\ntype: Decls\n\n\n\n\n\n","category":"method"},{"location":"types.html#VerilogWriter.decls-Tuple{Vector{Onedecl}}","page":"Basic Types","title":"VerilogWriter.decls","text":"decls(expr::Vector{Onedecl})\n\nFor interpolation with metaprogramming.\n\nExample\n\njulia> a = @decloneline @reg 8 x1, x2;\n\njulia> b = decls(:(\n       $(a);\n       @wire y1, y2\n       )) |> eval;\n\njulia> vshow(b);\nreg [7:0] x1;\nreg [7:0] x2;\nwire y1;\nwire y2;\ntype: Decls\n\n\n\n\n\n","category":"method"},{"location":"types.html#VerilogWriter.decls-Tuple{Vararg{Decls}}","page":"Basic Types","title":"VerilogWriter.decls","text":"decls(expr::Decls...)\n\nFor interpolation of Decls objects.\n\n\n\n\n\n","category":"method"},{"location":"types.html#decloneline","page":"Basic Types","title":"decloneline","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"decloneline(::Expr)","category":"page"},{"location":"types.html#VerilogWriter.decloneline-Tuple{Expr}","page":"Basic Types","title":"VerilogWriter.decloneline","text":"decloneline(expr::Expr)::Vector{Expr}\n\nParse Julia AST into wire declaration as Vector{Onedecl}.\n\nThe number of Onedecl objects returned may differ  according to the number of wires declared in one line  (e.g. input dout <=> input din1, din2, din3).\n\nSyntax\n\nSimilar to that of portoneline.\n\n@wire/@reg/@logic [<width>] <wirename1>[, <wirename2>,...]\n\nExamples\n\njulia> d = (@decloneline @reg 10 d1); vshow(d);\nreg [9:0] d1;\ntype: Onedecl\n\njulia> d = (@decloneline @logic 8 d1,d2,d3); vshow(d);\nlogic [7:0] d1;\ntype: Onedecl\nlogic [7:0] d2;\ntype: Onedecl\nlogic [7:0] d3;\ntype: Onedecl\n\njulia> d = (@decloneline @wire A >> 2 w1, w2); vshow(d);\nwire [(A >> 2)-1:0] w1;\ntype: Onedecl\nwire [(A >> 2)-1:0] w2;\ntype: Onedecl\n\n\n\n\n\n","category":"method"},{"location":"types.html#always","page":"Basic Types","title":"always","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"always(::Expr)","category":"page"},{"location":"types.html#VerilogWriter.always-Tuple{Expr}","page":"Basic Types","title":"VerilogWriter.always","text":"always(expr::Expr)\n\nParse AST into always block as Alwayscontent using ralways.\n\nAlso infers type of always using addatype!.\n\nSyntax\n\n<oneblock>;<oneblock>[;<oneblock>;...]\n\n<oneblock> is the expression that follows either below syntax.\n\n<wireoperation> = <wireoperation>\n\nOne blocking assignment. <wireoperation> is a expression accepted by wireexpr. Not all syntax accepted here is of valid verilog syntax.\n\n<wireoperation> <= <wireoperation>\n\nOne non-blocking assignment.\n\nIf-else statement\n\nif <wireoperation>\n    <oneblock>\n    <oneblock>\n    ...\nelseif <wireoperation> \n    <oneblock>\n    <oneblock>\n    ...\nelse\n    <oneblock>\n    ...\nend\n\nIf-else statement written in 'Julia syntax', not in Verilog  syntax, can be accepted. else block and elseif are not mandatory. Since if end are at the top level, no ; inside if-else statement is needed. Nested if-else statement can be also accepted as in usual Julia.\n\nThe order in which oneblock is placed within if,  elseif, and else block is not strictly preserved.  If-else statement inside if,elseif,else blocks is placed after blocking/non-blocking assignment there.\n\n@posedge <wirename>; <ifelsestatements>/<assignments>\n\nSet sensitivity list using macro syntax. @negedge is also possible.  You must put @posegde/@negedge statement at the beginning, and only once.\n\nExamples\n\na1 = @always (\n    w1 = w2;\n    if b2 \n        w1 = w3 \n    end\n)\nvshow(a1)\n\n# output\n\nalways_comb begin\n    w1 = w2;\n    if (b2) begin\n        w1 = w3;\n    end\nend\ntype: Alwayscontent\n\na1 = @always (\n    @posedge clk;\n    \n    if b1 == b2\n        w1 <= w2 + w3 \n    else\n        w1 <= ~w1 \n    end\n)\nvshow(a1)\n\n# output\n\nalways_ff @( posedge clk ) begin\n    if ((b1 == b2)) begin\n        w1 <= (w2 + w3);\n    end else begin\n        w1 <= (~w1);\n    end\nend\ntype: Alwayscontent\n\n\n\n\n\n","category":"method"},{"location":"types.html#Embed-Objects","page":"Basic Types","title":"Embed Objects","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"You can embed generated objects back into Verilog-like codes. The synatx is almost the same as those of interpolation.","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"By embedding objects as Julia AST, you can construct new objects that contain the information of embedded objects.","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"Every object (offered in this package) can be embedded almost anywhere it seems to be possible.","category":"page"},{"location":"types.html#Examples","page":"Basic Types","title":"Examples","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"julia> a = @portoneline @in clk;\n\njulia> b = @ports ($a; @out 8 dout); vshow(b);\n(\n    input clk,\n    output [7:0] dout\n);\ntype: Ports\n\njulia> a = @ports (@in clk; @out 8 dout);\n\njulia> b = @ports (@in resetn; $(a)); vshow(b);\n(\n    input resetn,\n    input clk,\n    output [7:0] dout\n);\ntype: Ports\n\njulia> a = @wireexpr (x + y) & z;\n\njulia> b = @always (lhs = $(a) | w); vshow(b);\nalways_comb begin\n    lhs = (((x + y) & z) | w);\nend\ntype: Alwayscontent","category":"page"},{"location":"types.html#Miscellaneous-Functions","page":"Basic Types","title":"Miscellaneous Functions","text":"","category":"section"},{"location":"types.html#vshow","page":"Basic Types","title":"vshow","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"vshow calls Base.string inside. You may convert objects into a string of verilog codes calling Base.string. See also vexport.","category":"page"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"vshow","category":"page"},{"location":"types.html#VerilogWriter.vshow","page":"Basic Types","title":"VerilogWriter.vshow","text":"vshow(x; systemverilog=true)\n\nPrint the structs in VerilogWriter.jl in a readable  format (except for enums). When systemverilog=false, output always, always @*  instead of always_ff, always_comb, respectively.\n\n\n\n\n\n","category":"function"},{"location":"types.html#vexport","page":"Basic Types","title":"vexport","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"vexport","category":"page"},{"location":"types.html#VerilogWriter.vexport","page":"Basic Types","title":"VerilogWriter.vexport","text":"vexport(fpath::AbstractString, x::Vmodule)\n\nExport x to a verilog/systemverilog file.\n\n\n\n\n\nvexport(fpath::AbstractString, x::Vector{Vmodule})\n\nExport x to a verilog/systemverilog file.\n\n\n\n\n\n","category":"function"},{"location":"types.html#vpush!","page":"Basic Types","title":"vpush!","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"vpush!","category":"page"},{"location":"types.html#VerilogWriter.vpush!","page":"Basic Types","title":"VerilogWriter.vpush!","text":"vpush!(coll::Decls, x::Onedecl...)\n\nvpush! method, add Onedecl to Decls.\n\n\n\n\n\nvpush!(coll::Ports, x::Oneport...)\n\nvpush! method, add Oneport to Ports.\n\n\n\n\n\nvpush!(coll::Parameters, x::Oneparam...)\n\nvpush! method, add Oneparam to Parameters.\n\n\n\n\n\nvpush!(coll::Localparams, x::Onelocalparam...)\n\nvpush! method, add Onelocalparam to Localparams.\n\n\n\n\n\nvpush!(coll::T, x::T...) where {T <: Union{Decls, Ports, Parameters, Localparams}}\n\nvpush! method, add T to T.\n\n\n\n\n\nvpush!(coll::Vmodule, x::Vmodinst...)\n\nvpush! method, add Vmodinst to Vmodule.\n\n\n\n\n\nvpush!(coll::Vmodule, x::Assign...)\n\nvpush! method, add Assign to Vmodule.\n\n\n\n\n\nvpush!(coll::Vmodule, x::Alwayscontent...)\n\nvpush! method, add Alwayscontent to Vmodule.\n\n\n\n\n\nvpush!(coll::Vmodule, x::Oneparam...)\n\nvpush! method, add Oneparam to Vmodule.\n\n\n\n\n\nvpush!(coll::Vmodule, x::Oneport...)\n\nvpush! method, add Oneport to Vmodule.\n\n\n\n\n\nvpush!(coll::Vmodule, x::Onelocalparam...)\n\nvpush! method, add Onelocalparam to Vmodule.\n\n\n\n\n\nvpush!(coll::Vmodule, x::Onedecl...)\n\nvpush! method, add Onedecl to Vmodule.\n\n\n\n\n\nvpush!(coll::Vmodule, x::T...) where {T <: Union{Decls, Ports, Parameters, Localparams}}\n\nvpush! method, add T to Vmodule.\n\n\n\n\n\nvpush!(coll::Vmodule, x::FSM...)\n\nvpush! method, add FSM to Vmodule.\n\n\n\n\n\nvpush!(coll::Vmodule, x::Vector{T}...) where {T}\n\nvpush! method, add Vector to Vmodule.\n\n\n\n\n\n","category":"function"},{"location":"types.html#sym2wire","page":"Basic Types","title":"sym2wire","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"@sym2wire","category":"page"},{"location":"types.html#VerilogWriter.@sym2wire","page":"Basic Types","title":"VerilogWriter.@sym2wire","text":"@sym2wire(arg::Symbol)\n\nDeclare new Wireexpr of name arg.\n\n\n\n\n\n@sym2wire(arg::Expr)\n\nDeclare new Wireexprs of name arg..., respectively.\n\nExample\n\njulia> @sym2wire x, y, z;\n\njulia> vshow(y);\ny\ntype: Wireexpr\n\n\n\n\n\n","category":"macro"},{"location":"types.html#naiveinst","page":"Basic Types","title":"naiveinst","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"naiveinst","category":"page"},{"location":"types.html#VerilogWriter.naiveinst","page":"Basic Types","title":"VerilogWriter.naiveinst","text":"naiveinst(vmod::Vmodule, iname::String)\n\nGenerate from vmod an Vmodinst object all ports of which are assigned a wire whose name is the same as each port.\n\n\n\n\n\nnaiveinst(vmod::Vmodule)\n\nNaive instantiation of vmod with default instance name.\n\n\n\n\n\n","category":"function"},{"location":"types.html#@preport","page":"Basic Types","title":"@preport","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"@preport","category":"page"},{"location":"types.html#VerilogWriter.@preport","page":"Basic Types","title":"VerilogWriter.@preport","text":"@preport(pre::Symbol, pnames)\n\nHelper macro for port assignment declaration in module instantiation.\n\nFor each <port name> in pnames, assign wire whose name is pre * <port name> (add prefix).\n\nExamples\n\nUnit Examples\n\njulia> p = @preport sub_ a,b\n2-element Vector{Pair{String, Wireexpr}}:\n \"a\" => Wireexpr(id, \"sub_a\", Wireexpr[], -1, -1)\n \"b\" => Wireexpr(id, \"sub_b\", Wireexpr[], -1, -1)\n\njulia> (x ->((a, b) = x; println(a, \" => \", string(b)))).(p);\na => sub_a\nb => sub_b\n\nIn Vmodinst\n\njulia> v = Vmodinst(\"mod\", \"umod\", (@preport p_ a,b,c), true); vshow(v);\nmod umod (\n    .a(p_a),\n    .b(p_b),\n    .c(p_c),\n    .*\n);\ntype: Vmodinst\n\n\n\n\n\n@preport(pnames)\n\nAdd no prefix at the head of each port name in pnames.\n\n\n\n\n\n","category":"macro"},{"location":"types.html#invports","page":"Basic Types","title":"invports","text":"","category":"section"},{"location":"types.html","page":"Basic Types","title":"Basic Types","text":"invports","category":"page"},{"location":"types.html#VerilogWriter.invports","page":"Basic Types","title":"VerilogWriter.invports","text":"invports(ps::Ports)\n\nReturn Ports object whose directions are reversed from ps.\n\nExamples\n\npts = @ports (\n    @in 8 bus1, bus2;\n    @out @reg bus3\n)\nipts = invports(pts)\nvshow(pts)\nvshow(ipts)\n\n# output\n\n(\n    input [7:0] bus1,\n    input [7:0] bus2,\n    output reg bus3\n);\ntype: Ports\n(\n    output [7:0] bus1,\n    output [7:0] bus2,\n    input bus3\n);\ntype: Ports\n\n\n\n\n\n","category":"function"}]
}
