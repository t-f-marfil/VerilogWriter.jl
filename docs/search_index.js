var documenterSearchIndex = {"docs":
[{"location":"structs/#Component-Structs","page":"Component structs","title":"Component Structs","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"CurrentModule = VerilogWriter\r\nDocTestSetup = quote\r\n    using VerilogWriter\r\nend","category":"page"},{"location":"structs/#Structs-Description","page":"Component structs","title":"Structs Description","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"This module offers several structs that contain a structure of Verilog components, major ones of which are listed below. ","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Parameters\nOneparam\nPorts\nOneport\nPortdirec\nWiretype\nWireexpr\nWireop\nDecls\nOnedecl\nAssign\nAlwayscontent\nAlassign\nIfelseblock\nIfcontent\nAtype\nEdge\nVmodule","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"push!(LOAD_PATH,\"../../src/\")\r\nusing VerilogWriter","category":"page"},{"location":"structs/#Parameters","page":"Component structs","title":"Parameters","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Parameters)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Parameters","category":"page"},{"location":"structs/#VerilogWriter.Parameters","page":"Component structs","title":"VerilogWriter.Parameters","text":"List of parameters.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Oneparam","page":"Component structs","title":"Oneparam","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Oneparam)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Oneparam","category":"page"},{"location":"structs/#VerilogWriter.Oneparam","page":"Component structs","title":"VerilogWriter.Oneparam","text":"Parameter in verilog.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Ports","page":"Component structs","title":"Ports","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Ports)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Ports","category":"page"},{"location":"structs/#VerilogWriter.Ports","page":"Component structs","title":"VerilogWriter.Ports","text":"Gather multiple ports.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Oneport","page":"Component structs","title":"Oneport","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Oneport)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Oneport","category":"page"},{"location":"structs/#VerilogWriter.Oneport","page":"Component structs","title":"VerilogWriter.Oneport","text":"Represent a single port declaration.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Portdirec","page":"Component structs","title":"Portdirec","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Portdirec)))) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Portdirec","category":"page"},{"location":"structs/#VerilogWriter.Portdirec","page":"Component structs","title":"VerilogWriter.Portdirec","text":"Port direction object.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Wiretype","page":"Component structs","title":"Wiretype","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Wiretype)))) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Wiretype","category":"page"},{"location":"structs/#VerilogWriter.Wiretype","page":"Component structs","title":"VerilogWriter.Wiretype","text":"Wiretype object.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Wireexpr","page":"Component structs","title":"Wireexpr","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Wireexpr)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Wireexpr","category":"page"},{"location":"structs/#VerilogWriter.Wireexpr","page":"Component structs","title":"VerilogWriter.Wireexpr","text":"Wire expressions in verilog. \n\nContains unnecessary information to handle all the wires in the same type. \n\nOne motivation to avoid making different types of  wires (e.g. using parametric types) is that it seemed beneficial to have multiple wires in a vector, and that  it is sometime a disadvantage in performance to use  abstract types when creating vectors.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Wireop","page":"Component structs","title":"Wireop","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Wireop)))) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Wireop","category":"page"},{"location":"structs/#VerilogWriter.Wireop","page":"Component structs","title":"VerilogWriter.Wireop","text":"Verilog operators.\n\nUnary &, | does not exists so explicitly call as function  e.g. &(wire), |(wire) (& behaves in a wickedmanner...?). Xor in verilog ^ is in Julia exponential operator, and the difference in association exists.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Decls","page":"Component structs","title":"Decls","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Decls)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Decls","category":"page"},{"location":"structs/#VerilogWriter.Decls","page":"Component structs","title":"VerilogWriter.Decls","text":"Multiple wire declarations.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Onedecl","page":"Component structs","title":"Onedecl","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Onedecl)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Onedecl","category":"page"},{"location":"structs/#VerilogWriter.Onedecl","page":"Component structs","title":"VerilogWriter.Onedecl","text":"Represent one wire declaration.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Assign","page":"Component structs","title":"Assign","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Assign)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Assign","category":"page"},{"location":"structs/#VerilogWriter.Assign","page":"Component structs","title":"VerilogWriter.Assign","text":"Assign one statement.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Alwayscontent","page":"Component structs","title":"Alwayscontent","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Alwayscontent)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Alwayscontent","category":"page"},{"location":"structs/#VerilogWriter.Alwayscontent","page":"Component structs","title":"VerilogWriter.Alwayscontent","text":"Represent always blocks.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Alassign","page":"Component structs","title":"Alassign","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Alassign)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Alassign","category":"page"},{"location":"structs/#VerilogWriter.Alassign","page":"Component structs","title":"VerilogWriter.Alassign","text":"Assign statement inside always blocks.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Ifelseblock","page":"Component structs","title":"Ifelseblock","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Ifelseblock)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Ifelseblock","category":"page"},{"location":"structs/#VerilogWriter.Ifelseblock","page":"Component structs","title":"VerilogWriter.Ifelseblock","text":"Container of an if-else block.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Ifcontent","page":"Component structs","title":"Ifcontent","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Ifcontent)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Ifcontent","category":"page"},{"location":"structs/#VerilogWriter.Ifcontent","page":"Component structs","title":"VerilogWriter.Ifcontent","text":"Container of one if-block (, one elseif block, or one else block).\n\nParametrized by T only for mutual recursion with Ifelseblock,  thus used as Ifcontent_inner{Ifelseblock}, which is aliased as Ifcontent.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Atype","page":"Component structs","title":"Atype","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Atype)))) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Atype","category":"page"},{"location":"structs/#VerilogWriter.Atype","page":"Component structs","title":"VerilogWriter.Atype","text":"Type of always blocks.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Edge","page":"Component structs","title":"Edge","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Edge)))) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Edge","category":"page"},{"location":"structs/#VerilogWriter.Edge","page":"Component structs","title":"VerilogWriter.Edge","text":"Edge in sensitivity lists.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Vmodule","page":"Component structs","title":"Vmodule","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Vmodule)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Vmodule","category":"page"},{"location":"structs/#VerilogWriter.Vmodule","page":"Component structs","title":"VerilogWriter.Vmodule","text":"Represents one verilog module.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Converter-Functions/Macros","page":"Component structs","title":"Converter Functions/Macros","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"As in previous examples we offer functions and macros to convert Julia syntax into certain structs described above. You may use these instead of calling constructors.","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"All the functions listed below accept Expr object as its argument (e.g. :(x = 10), see Julia Documents for more information.), and that is why variables inside the argument Expr object do not have to be declared anywhere else in the source code. The syntaxes each function requires in a argument Expr objects are also described below (or may be easily inferred from the examples here and Brief Introduction).","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"As you see in Brief Introduction there are macros that do the same thing as functions listed below (and both macro and function has the same name). As macros take Expr object as its argument, you can write codes in a slightly more simple manner with macros. For example,","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"always(:(\r\n    @posedge clk; \r\n\r\n    w1 <= w2;\r\n    if b1 == b2 \r\n        w3 <= w4\r\n    end\r\n))","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"is equivalent to ","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"@always (\r\n    @posedge clk; \r\n\r\n    w1 <= w2;\r\n    if b1 == b2 \r\n        w3 <= w4\r\n    end\r\n)","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"(be care full not to foreget (one space) between macros and (, i.e. @macro(a;b) and @macro (a;b) are different.)","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"But sometimes there are things what macros cannot do (at least to me it seems impossible in macros), an example is having for loop inside expressions.","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"d = always(:(\r\n    if b1 \r\n        $([:($(Symbol(\"x$i\")) = $(Symbol(\"y$i\"))) for i in 1:3]...)\r\n    end\r\n))\r\nvshow(d)","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"and this outputs","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"always_comb begin\r\n    if (b1) begin\r\n        x1 = y1;\r\n        x2 = y2;\r\n        x3 = y3;\r\n    end\r\nend\r\ntype: Alwayscontent","category":"page"},{"location":"structs/#List-of-Converter-Functions/Macros","page":"Component structs","title":"List of Converter Functions/Macros","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Written inside parentheses are the types of objects the functions return.","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"ports (Ports)\nportoneline (Oneport)\nwireexpr (Wireexpr)\ndecls (Decls)\ndecloneline (Onedecl)\nalways (Alwayscontent)\nroneblock  (Ifelseblock,Alassign)","category":"page"},{"location":"structs/#ports","page":"Component structs","title":"ports","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"ports(::Expr)","category":"page"},{"location":"structs/#VerilogWriter.ports-Tuple{Expr}","page":"Component structs","title":"VerilogWriter.ports","text":"ports(expr::Expr)\n\nConvert Julia AST into port declarations as Ports object.\n\nSyntax\n\n<portoneline>[;<portoneline>;...]\n\nMultiple lines of portoneline expressions  separated by ; can be accepted. \n\nExample\n\npp = ports(:(\n    @in p1;\n    @in wire 8 p2, p3, p4;\n    @out reg 2 p5, p6\n))\n\nvshow(pp)\n\n# output\n\n(\n    input p1,\n    input [7:0] p2,\n    input [7:0] p3,\n    input [7:0] p4,\n    output reg [1:0] p5,\n    output reg [1:0] p6\n);\n\ntype: Ports\n\n\n\n\n\n","category":"method"},{"location":"structs/#portoneline","page":"Component structs","title":"portoneline","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"portoneline(::Expr)","category":"page"},{"location":"structs/#VerilogWriter.portoneline-Tuple{Expr}","page":"Component structs","title":"VerilogWriter.portoneline","text":"portoneline(expr::Expr)\n\nParse Julia AST to one line of port declaration as Oneport.\n\nSyntax\n\n@in <wirename>, @out <wirename>\n\nOne port declaration of width 1.\n\n@in/@out <wirename1, wirename2, ...>\n\nMultiple port declaration of width 1 in one line.\n\n@in/@out <width::Int> <wirename1[, wirename2, ...]>\n\nPort declarations of width <width>.\n\n@in/@out <wiretype> [<width::Int>] <wirename1[, wirename2, ...]>\n\nPort declaration with wiretypes [of width <width>].\n\nExamples\n\njulia> p1 = portoneline(:(@in din));\n\njulia> vshow(p1);\ninput din\ntype: Oneport\n\njulia> p2 = portoneline(:(@out din1, din2, din3)); vshow(p2);\noutput din1\ntype: Oneport\noutput din2\ntype: Oneport\noutput din3\ntype: Oneport\n\njulia> p3 = portoneline(:(@in 8 din)); vshow(p3);\ninput [7:0] din\ntype: Oneport\n\njulia> p4 = portoneline(:(@out reg 8 dout)); vshow(p4);\noutput reg [7:0] dout\ntype: Oneport\n\n\n\n\n\n","category":"method"},{"location":"structs/#wireexpr","page":"Component structs","title":"wireexpr","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"wireexpr(::Expr)","category":"page"},{"location":"structs/#VerilogWriter.wireexpr-Tuple{Expr}","page":"Component structs","title":"VerilogWriter.wireexpr","text":"wireexpr(expr::Expr)\n\nParse one wire expression. Be sure to put 'two e's' in wir'ee'xpr, not 'wirexpr'.\n\nSyntax\n\nPart of what can be done in Verilog can be accepted,  such as din[7:0], (w1 + w2) << 5\n\n<wirename>\n\nOne wire, without slicing or bit-selecting.\n\n<val::Int>, <val::hex>, <val::bin>\n\nLiterals, e.g. 5, 0x1f, 0b10.\n\n<wire> <op> <wire>, <op> <wire>\n\nUnary and binary operators.  For reduction operators (unary &, |, ^), since these are  not operators in Julia, write it in the form of function  call explicitly, i.e. &(wire), |(wire) instead of doing ^wire. Note that we use ^ as xor just as in Verilog, though this is not  a xor operator in Julia.\n\n<wire>[<wire>:<wire>], <wire>[<wire>]\n\nBit select and slicing as in Verilog/SystemVerilog.\n\nExamples\n\njulia> w = wireexpr(:(w)); vshow(w);\nw\ntype: Wireexpr\n\njulia> w = wireexpr(:(w1 & &(w2) )); vshow(w);\n(w1 & &(w2))\ntype: Wireexpr\n\njulia> w = wireexpr(:(w[i:0])); vshow(w);\nw[i:0]\ntype: Wireexpr\n\n\n\n\n\n","category":"method"},{"location":"structs/#decls","page":"Component structs","title":"decls","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"decls(::Expr)","category":"page"},{"location":"structs/#VerilogWriter.decls-Tuple{Expr}","page":"Component structs","title":"VerilogWriter.decls","text":"decls(expr::Expr)\n\nParse Julia AST into wire declaration section object Decls.\n\nSyntax\n\n<onedecl>[;<onedecl>;...]\n\nMultiple decloneline expressions which are concatenated  by ; can be accepted.\n\nExample\n\nd = decls(:(\n    @wire w1;\n    @reg 8 w2,w3,w4;\n    @logic 32 w5\n))\nvshow(d)\n\n# output\n\nwire w1;\nreg [7:0] w2;\nreg [7:0] w3;\nreg [7:0] w4;\nlogic [31:0] w5;\ntype: Decls\n\n\n\n\n\n","category":"method"},{"location":"structs/#decloneline","page":"Component structs","title":"decloneline","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"decloneline(::Expr)","category":"page"},{"location":"structs/#VerilogWriter.decloneline-Tuple{Expr}","page":"Component structs","title":"VerilogWriter.decloneline","text":"decloneline(expr::Expr)\n\nParse Julia AST into wire declaration as Vector{Onedecl}.\n\nThe number of Onedecl objects returned may differ  according to the number of wires declared in one line  (e.g. input dout <=> input din1, din2, din3).\n\nSyntax\n\nSimilar to that of portoneline.\n\n@wire/@reg/@logic [<width>] <wirename1>[, <wirename2>,...]\n\nExamples\n\njulia> d = decloneline(:(@reg 10 d1)); vshow(d);\nreg [9:0] d1;\ntype: Onedecl\n\njulia> d = decloneline(:(@logic 8 d1,d2,d3)); vshow(d);\nlogic [7:0] d1;\ntype: Onedecl\nlogic [7:0] d2;\ntype: Onedecl\nlogic [7:0] d3;\ntype: Onedecl\n\n\n\n\n\n","category":"method"},{"location":"structs/#always","page":"Component structs","title":"always","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"always(::Expr)","category":"page"},{"location":"structs/#VerilogWriter.always-Tuple{Expr}","page":"Component structs","title":"VerilogWriter.always","text":"always(expr::Expr)\n\nParse AST into always block as Alwayscontent.\n\nSyntax\n\n<roneblock>;<roneblock>[;<roneblock>;...]\n\n<roneblock> is the expression that can be parsed by roneblock. ; in between <roneblock>s are strictly needed.\n\n@posedge <wirename>; <ifelsestatements>/<assignments>\n\nSet sensitivity list using macro syntax. @negedge is also possible.  You must put @posegde/@negedge statement at the beginning, and only once.\n\nExamples\n\na1 = always(:(\n    w1 = w2;\n    if b2 \n        w1 = w3 \n    end\n))\nvshow(a1)\n\n# output\n\nalways_comb begin\n    w1 = w2;\n    if (b2) begin\n        w1 = w3;\n    end\nend\ntype: Alwayscontent\n\na1 = always(:(\n    @posedge clk;\n    \n    if b1 == b2\n        w1 <= w2 + w3 \n    else\n        w1 <= ~w1 \n    end\n))\nvshow(a1)\n\n# output\n\nalways_ff @( posedge clk ) begin\n    if ((b1 == b2)) begin\n        w1 <= (w2 + w3);\n    end else begin\n        w1 <= ~w1;\n    end\nend\ntype: Alwayscontent\n\n\n\n\n\n","category":"method"},{"location":"structs/#roneblock","page":"Component structs","title":"roneblock","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"roneblock(::Expr)","category":"page"},{"location":"structs/#VerilogWriter.roneblock-Tuple{Expr}","page":"Component structs","title":"VerilogWriter.roneblock","text":"roneblock(expr::Expr)\n\nParse AST in Julia grammar to one if-else statement or  one assignment inside always blocks in Verilog,  which are Ifelseblock and Alassign, respectively. \n\nAs using Julia expression and Julia parser as if  it is of Verilog, there can be difference in grammatical matters  between what can be given as the expr and real Verilog  (e.g. operator precedence of <=).\n\nSyntax\n\n<wirename1> = <wireoperation>\n\nOne blocking assignment. (Note that bit width cannot be  specified yet, nor can it be printed.) <wireoperation> is a expression accepted by wireexpr.\n\nIf-else statement\n\nif <wireoperation>\n    <oneassignment>\n    <oneassignment>\n    ...\nelseif <wireoperation> \n    <oneassignment>\n    <ifelsestatement>\n    ...\nelse\n    <ifelsestatement>\n    ...\nend\n\nIf-else statement written in 'Julia syntax', not in Verilog  syntax, can be accepted. else block and elseif are not compulsory. Since if end are at the top level no ; inside if-else statement is needed. Nested if-else statement can be also accepted as in usual Julia.\n\nExamples\n\njulia> a1 = roneblock(:(w1 <= w2)); \n\njulia> vshow(a1);\nw1 <= w2;\ntype: Alassign\n\njulia> a2 = roneblock(:(w3 = w4 + ~w2)); vshow(a2);\nw3 = (w4 + ~w2);\ntype: Alassign\n\na3 = roneblock(:(\n    if b1 == b2\n        w5 = ~w6\n        w7 = w8 \n    elseif b2 \n        w9 = w9 + w10\n    else\n        if b3 \n            w11 = w12 \n        end\n    end\n))\nvshow(a3)\n\n# output\n\nif ((b1 == b2)) begin\n    w5 = ~w6;\n    w7 = w8;\nend else if (b2) begin\n    w9 = (w9 + w10);\nend else begin\n    if (b3) begin\n        w11 = w12;\n    end\nend\ntype: Ifelseblock\n\n\n\n\n\n","category":"method"},{"location":"structs/#Other-Important-functions","page":"Component structs","title":"Other Important functions","text":"","category":"section"},{"location":"structs/#vshow","page":"Component structs","title":"vshow","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"vshow(::Any)","category":"page"},{"location":"structs/#VerilogWriter.vshow-Tuple{Any}","page":"Component structs","title":"VerilogWriter.vshow","text":"vshow(x; systemverilog=true)\n\nPrint the structs in VerilogWriter.jl in a readable  format (except for enums). When systemverilog=false, output always, always @*  instead of always_ff, always_comb, respectively.\n\n\n\n\n\n","category":"method"},{"location":"structs/#invports","page":"Component structs","title":"invports","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"invports","category":"page"},{"location":"structs/#VerilogWriter.invports","page":"Component structs","title":"VerilogWriter.invports","text":"invports(ps::Ports)\n\nReturn Ports object whose directions are reversed from ps.\n\nExamples\n\npts = @ports (\n    @in 8 bus1, bus2;\n    @out reg bus3\n)\nipts = invports(pts)\nvshow(pts)\nvshow(ipts)\n\n# output\n\n(\n    input [7:0] bus1,\n    input [7:0] bus2,\n    output reg bus3\n);\n\ntype: Ports\n(\n    output [7:0] bus1,\n    output [7:0] bus2,\n    input bus3\n);\n\ntype: Ports\n\n\n\n\n\n","category":"function"},{"location":"structs/#invport","page":"Component structs","title":"invport","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"invport","category":"page"},{"location":"structs/#VerilogWriter.invport","page":"Component structs","title":"VerilogWriter.invport","text":"invport(onep::Oneport)\n\nReturn Oneport object whose directions are reversed from onep. Wiretype information (reg, wire, logic) is  lost when inverted for reg cannot be at input port.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = VerilogWriter","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"No detailed descriptions available yet.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Still ?<function-name> on IJulia, Julia REPL will return docstrings for most of the functions, structs, and constant values in this module.","category":"page"},{"location":"#VerilogWriter.jl-Document","page":"Home","title":"VerilogWriter.jl Document","text":"","category":"section"},{"location":"#Brief-Introduction","page":"Home","title":"Brief Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have IJulia locally, execute","category":"page"},{"location":"#In[1]","page":"Home","title":"In[1]","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using VerilogWriter","category":"page"},{"location":"","page":"Home","title":"Home","text":"(or make .jl file and execute codes with julia <filename>.jl instead.) and then","category":"page"},{"location":"#In[2]","page":"Home","title":"In[2]","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"x = @always (\r\n    dout = d1 + d2;\r\n    if b1\r\n        dout = ~d1\r\n    elseif b2 \r\n        dout = ~d2\r\n    end\r\n)\r\nvshow(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(note that variables such as dout, b1 are not declared anywhere.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and now you see the following:","category":"page"},{"location":"#Out[2]","page":"Home","title":"Out[2]","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"always_comb begin\r\n    dout = (d1 + d2);\r\n    if (b1) begin\r\n        dout = ~d1;\r\n    end else if (b2) begin\r\n        dout = ~d2;\r\n    end\r\nend\r\ntype: Alwayscontent","category":"page"},{"location":"","page":"Home","title":"Home","text":"Another example is ","category":"page"},{"location":"#In[3]","page":"Home","title":"In[3]","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"prs = Parameters(Oneparam(\"splind\", 5))\r\n\r\nps = @ports (\r\n    @in clk, sig1, sig2;\r\n    @in 8 din, din2;\r\n    @out reg 8 dout\r\n)\r\n\r\nds = @decls (\r\n    @reg 8 dbuf\r\n)\r\n\r\nproc = @always (\r\n    @posedge clk;\r\n\r\n    if sig2 && |(din2)\r\n        dbuf <= din \r\n    elseif sig1 ^ sig2\r\n        dout[7:splind] <= dbuf[7:splind]\r\n        dout[splind-1:0] <= din[splind-1:0]\r\n    else\r\n        dout <= ~din \r\n    end\r\n)\r\n\r\nmymod = Vmodule(\r\n    \"mymodule\",\r\n    prs,\r\n    ps,\r\n    ds,\r\n    Assign[],\r\n    [proc]\r\n)\r\n\r\nvshow(mymod, systemverilog=false)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and now you get ","category":"page"},{"location":"#Out[3]","page":"Home","title":"Out[3]","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"module mymodule #(\r\n    parameter splind = 5\r\n)(\r\n    input clk,\r\n    input sig1,\r\n    input sig2,\r\n    input [7:0] din,\r\n    input [7:0] din2,\r\n    output reg [7:0] dout\r\n);\r\n    reg [7:0] dbuf;\r\n\r\n    always @( posedge clk ) begin\r\n        if ((sig2 && |(din2))) begin\r\n            dbuf <= din;\r\n        end else if ((sig1 ^ sig2)) begin\r\n            dout[7:splind] <= dbuf[7:splind];\r\n            dout[(splind - 1):0] <= din[(splind - 1):0];\r\n        end else begin\r\n            dout <= ~din;\r\n        end\r\n    end\r\nendmodule\r\ntype: Vmodule","category":"page"},{"location":"","page":"Home","title":"Home","text":"(of course this verilog module itself is far from being useful.)","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This module offers a simple method to write on Julia  Verilog/SystemVerilog codes not as raw strings but as objects with certain structures, such as always-block-objects, port-declaration-objects, and so on (not as sophisticated as, for example, Chisel is, though).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The motivation here is that it would be nice if we could write Verilog/SystemVerilog with the power of the Julia language, with a minimal amount of additional syntaxes (function calls, constructors, etc.). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"As in the examples above, we offer, for instance, simple macros to convert Verilog-like Julia code into certain objects that have proper structure found in Verilog codes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = VerilogWriter","category":"page"},{"location":"#What-is-Left-to-be-Done","page":"Home","title":"What is Left to be Done","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It seems too many things are left to be done to make this VerilogWriter.jl, at least to some extent, useful, but to list few of them, ","category":"page"},{"location":"#Unsupported-Syntaxes","page":"Home","title":"Unsupported Syntaxes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Lots of operators and syntaxes in Verilog/SystemVerilog is not supported (e.g. for, generate for, interfaces, tasks, always_latch, indexed part select, and so on), although some of them can be replaced by using Julia syntaxes instead (e.g. using Julia for loop and generate multiple always blocks instead of Verilog), or rather it 'should be' replaced to make use of the power of Julia language.","category":"page"},{"location":"#No-Useful-Handlers-of-the-Structs","page":"Home","title":"No Useful Handlers of the Structs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We offer here some structs to imitate what is done in Verilog codes, but few functions to handle them are offered together. Still you can construct some more functions to handle the structs offered here, making it a little easier to make more complex Verilog modules.","category":"page"},{"location":"","page":"Home","title":"Home","text":"One example might be making functions to infer wire bit width from always blocks and assign statements, similar to what is done in Chisel.","category":"page"},{"location":"#No-Way-to-Insert-Generated-Objects-in-Verilog-like-Codes","page":"Home","title":"No Way to Insert Generated Objects in Verilog-like Codes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Macros and functions accepts 'raw' Verilog-like expressions, while there is no method to somehow insert the objects into expressions for the functions/macros. Instead you need to call certain constructors to create an object that contains another object. For example, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"blk = @roneblock (\r\n    if b \r\n        x = z \r\n    end\r\n)\r\n\r\n# cannot use @always here\r\nalw = Alwayscontent(\r\n    blk\r\n)\r\nvshow(addatype!(alw))","category":"page"},{"location":"","page":"Home","title":"Home","text":"outputs ","category":"page"},{"location":"","page":"Home","title":"Home","text":"always_comb begin\r\n    if (b) begin\r\n        x = z;\r\n    end\r\nend\r\ntype: Alwayscontent","category":"page"}]
}
