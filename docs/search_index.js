var documenterSearchIndex = {"docs":
[{"location":"intro/#VerilogWriter.jl-Document","page":"Introduction","title":"VerilogWriter.jl Document","text":"","category":"section"},{"location":"intro/#Brief-Introduction","page":"Introduction","title":"Brief Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"If you have IJulia locally, execute","category":"page"},{"location":"intro/#In[1]","page":"Introduction","title":"In[1]","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"using VerilogWriter","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(or make .jl file and execute codes with julia <filename>.jl instead.) and then","category":"page"},{"location":"intro/#In[2]","page":"Introduction","title":"In[2]","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"x = @always (\r\n    dout = d1 + d2;\r\n    if b1\r\n        dout = ~d1\r\n    elseif b2 \r\n        dout = ~d2\r\n    end\r\n)\r\nvshow(x)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(note that variables such as dout, b1 are not declared anywhere.)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and now you see the following:","category":"page"},{"location":"intro/#Out[2]","page":"Introduction","title":"Out[2]","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"always_comb begin\r\n    dout = (d1 + d2);\r\n    if (b1) begin\r\n        dout = ~d1;\r\n    end else if (b2) begin\r\n        dout = ~d2;\r\n    end\r\nend\r\ntype: Alwayscontent","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Another example is ","category":"page"},{"location":"intro/#In[3]","page":"Introduction","title":"In[3]","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"prs = Parameters(Oneparam(\"splind\", 5))\r\n\r\nps = @ports (\r\n    @in clk, sig1, sig2;\r\n    @in 8 din, din2;\r\n    @out reg 8 dout\r\n)\r\n\r\nds = @decls (\r\n    @reg 8 dbuf\r\n)\r\n\r\nproc = @always (\r\n    @posedge clk;\r\n\r\n    if sig2 && |(din2)\r\n        dbuf <= din \r\n    elseif sig1 ^ sig2\r\n        dout[7:splind] <= dbuf[7:splind]\r\n        dout[splind-1:0] <= din[splind-1:0]\r\n    else\r\n        dout <= ~din \r\n    end\r\n)\r\n\r\nmymod = Vmodule(\r\n    \"mymodule\",\r\n    prs,\r\n    ps,\r\n    ds,\r\n    Assign[],\r\n    [proc]\r\n)\r\n\r\nvshow(mymod, systemverilog=false)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and now you get ","category":"page"},{"location":"intro/#Out[3]","page":"Introduction","title":"Out[3]","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"module mymodule #(\r\n    parameter splind = 5\r\n)(\r\n    input clk,\r\n    input sig1,\r\n    input sig2,\r\n    input [7:0] din,\r\n    input [7:0] din2,\r\n    output reg [7:0] dout\r\n);\r\n    reg [7:0] dbuf;\r\n\r\n    always @( posedge clk ) begin\r\n        if ((sig2 && |(din2))) begin\r\n            dbuf <= din;\r\n        end else if ((sig1 ^ sig2)) begin\r\n            dout[7:splind] <= dbuf[7:splind];\r\n            dout[(splind - 1):0] <= din[(splind - 1):0];\r\n        end else begin\r\n            dout <= ~din;\r\n        end\r\n    end\r\nendmodule\r\ntype: Vmodule","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(of course this verilog module itself is far from being useful.)","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This module offers a simple method to write on Julia  Verilog/SystemVerilog codes not as raw strings but as objects with certain structures, such as always-block-objects, port-declaration-objects, and so on (not as sophisticated as, for example, Chisel is, though).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The motivation here is that it would be nice if we could write Verilog/SystemVerilog with the power of the Julia language, with a minimal amount of additional syntaxes (function calls, constructors, etc.). ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"As in the examples above, we offer, for instance, simple macros to convert Verilog-like Julia code into certain objects that have proper structure found in Verilog codes.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = VerilogWriter","category":"page"},{"location":"intro/#What-is-Left-to-be-Done","page":"Introduction","title":"What is Left to be Done","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"It seems too many things are left to be done to make this VerilogWriter.jl, at least to some extent, useful, but to list few of them, ","category":"page"},{"location":"intro/#Unsupported-Syntaxes","page":"Introduction","title":"Unsupported Syntaxes","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Lots of operators and syntaxes in Verilog/SystemVerilog is not supported (e.g. for, generate for, interfaces, tasks, always_latch, indexed part select, and so on), although some of them can be replaced by using Julia syntaxes instead (e.g. using Julia for loop and generate multiple always blocks instead of Verilog), or rather it 'should be' replaced to make use of the power of Julia language.","category":"page"},{"location":"intro/#Not-Enough-Handlers-of-the-Structs","page":"Introduction","title":"Not Enough Handlers of the Structs","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We offer here some structs to imitate what is done in Verilog codes, but few functions to handle them are offered together. Still you can construct some more functions to handle the structs offered here, making it a little easier to make more complex Verilog modules.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"One example might be making functions to infer wire bit width from always blocks and assign statements, similar to what is done in Chisel.","category":"page"},{"location":"structs/#Component-Structs","page":"Component structs","title":"Component Structs","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"CurrentModule = VerilogWriter\r\nDocTestSetup = quote\r\n    using VerilogWriter\r\nend","category":"page"},{"location":"structs/#Structs-Description","page":"Component structs","title":"Structs Description","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"This module offers several structs that contain a structure of Verilog components, major ones of which are listed below. ","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Parameters\nOneparam\nPorts\nOneport\nPortdirec\nWiretype\nWireexpr\nWireop\nDecls\nOnedecl\nAssign\nAlwayscontent\nAlassign\nIfelseblock\nIfcontent\nAtype\nEdge\nVmodule","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"push!(LOAD_PATH,\"../../src/\")\r\nusing VerilogWriter","category":"page"},{"location":"structs/#Parameters","page":"Component structs","title":"Parameters","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Parameters)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Parameters","category":"page"},{"location":"structs/#VerilogWriter.Parameters","page":"Component structs","title":"VerilogWriter.Parameters","text":"List of parameters.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Oneparam","page":"Component structs","title":"Oneparam","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Oneparam)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Oneparam","category":"page"},{"location":"structs/#VerilogWriter.Oneparam","page":"Component structs","title":"VerilogWriter.Oneparam","text":"Parameter in verilog.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Ports","page":"Component structs","title":"Ports","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Ports)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Ports","category":"page"},{"location":"structs/#VerilogWriter.Ports","page":"Component structs","title":"VerilogWriter.Ports","text":"Gather multiple ports.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Oneport","page":"Component structs","title":"Oneport","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Oneport)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Oneport","category":"page"},{"location":"structs/#VerilogWriter.Oneport","page":"Component structs","title":"VerilogWriter.Oneport","text":"Represent a single port declaration.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Portdirec","page":"Component structs","title":"Portdirec","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Portdirec)))) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Portdirec","category":"page"},{"location":"structs/#VerilogWriter.Portdirec","page":"Component structs","title":"VerilogWriter.Portdirec","text":"Port direction object.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Wiretype","page":"Component structs","title":"Wiretype","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Wiretype)))) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Wiretype","category":"page"},{"location":"structs/#VerilogWriter.Wiretype","page":"Component structs","title":"VerilogWriter.Wiretype","text":"Wiretype object.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Wireexpr","page":"Component structs","title":"Wireexpr","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Wireexpr)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Wireexpr","category":"page"},{"location":"structs/#VerilogWriter.Wireexpr","page":"Component structs","title":"VerilogWriter.Wireexpr","text":"Wire expressions in verilog. \n\nContains unnecessary information to handle all the wires in the same type. \n\nOne motivation to avoid making different types of  wires (e.g. using parametric types) is that it seemed beneficial to have multiple wires in a vector, and that  it is sometime a disadvantage in performance to use  abstract types when creating vectors.\n\nSome operators on wires in Verilog, which are listed in Enum Wireop,  are overloaded for Wireexpr. Note that reduction operators (unary &, |, ^) are not in Julia,  and logical and, or (&&, ||) can be applied only for booleans in Julia, thus  are not available as an operator for Wireexpr objects.\n\nExamples\n\njulia> w1 = @wireexpr x + y;\n\njulia> w2 = @wireexpr z;\n\njulia> vshow(w1 & w2);\n((x + y) & z)\ntype: Wireexpr\n\njulia> w3 = @wireexpr x;\n\njulia> w4 = @wireexpr y && z; # && is available inside `@wireexpr` and `wireexpr` methods.\n\njulia> vshow(w3 | w4)\n(x | (y && z))\ntype: Wireexpr\n\n\n\n\n\n","category":"type"},{"location":"structs/#Wireop","page":"Component structs","title":"Wireop","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Wireop)))) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Wireop","category":"page"},{"location":"structs/#VerilogWriter.Wireop","page":"Component structs","title":"VerilogWriter.Wireop","text":"Verilog operators.\n\nUnary &, | does not exists so explicitly call as function e.g. &(wire), |(wire) (& behaves in a wickedmanner...?), and are only available inside quoted expressions. Xor in verilog ^ is in Julia exponential operator, and the difference in an association exists.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Decls","page":"Component structs","title":"Decls","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Decls)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Decls","category":"page"},{"location":"structs/#VerilogWriter.Decls","page":"Component structs","title":"VerilogWriter.Decls","text":"Multiple wire declarations.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Onedecl","page":"Component structs","title":"Onedecl","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Onedecl)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Onedecl","category":"page"},{"location":"structs/#VerilogWriter.Onedecl","page":"Component structs","title":"VerilogWriter.Onedecl","text":"Represent one wire declaration.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Assign","page":"Component structs","title":"Assign","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Assign)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Assign","category":"page"},{"location":"structs/#VerilogWriter.Assign","page":"Component structs","title":"VerilogWriter.Assign","text":"Assign one statement.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Alwayscontent","page":"Component structs","title":"Alwayscontent","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Alwayscontent)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Alwayscontent","category":"page"},{"location":"structs/#VerilogWriter.Alwayscontent","page":"Component structs","title":"VerilogWriter.Alwayscontent","text":"Represent always blocks.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Alassign","page":"Component structs","title":"Alassign","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Alassign)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Alassign","category":"page"},{"location":"structs/#VerilogWriter.Alassign","page":"Component structs","title":"VerilogWriter.Alassign","text":"Assign statement inside always blocks.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Ifelseblock","page":"Component structs","title":"Ifelseblock","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Ifelseblock)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Ifelseblock","category":"page"},{"location":"structs/#VerilogWriter.Ifelseblock","page":"Component structs","title":"VerilogWriter.Ifelseblock","text":"Container of an if-else block.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Ifcontent","page":"Component structs","title":"Ifcontent","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Ifcontent)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Ifcontent","category":"page"},{"location":"structs/#VerilogWriter.Ifcontent","page":"Component structs","title":"VerilogWriter.Ifcontent","text":"Container of one if-block (, one elseif block, or one else block).\n\nParametrized by T only for mutual recursion with Ifelseblock,  thus used as Ifcontent_inner{Ifelseblock}, which is aliased as Ifcontent.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Atype","page":"Component structs","title":"Atype","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Atype)))) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Atype","category":"page"},{"location":"structs/#VerilogWriter.Atype","page":"Component structs","title":"VerilogWriter.Atype","text":"Type of always blocks.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Edge","page":"Component structs","title":"Edge","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Edge)))) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Edge","category":"page"},{"location":"structs/#VerilogWriter.Edge","page":"Component structs","title":"VerilogWriter.Edge","text":"Edge in sensitivity lists.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Vmodule","page":"Component structs","title":"Vmodule","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"println(showfield(Vmodule)) # hide","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Vmodule","category":"page"},{"location":"structs/#VerilogWriter.Vmodule","page":"Component structs","title":"VerilogWriter.Vmodule","text":"Represents one verilog module.\n\n\n\n\n\n","category":"type"},{"location":"structs/#Converter-Functions/Macros","page":"Component structs","title":"Converter Functions/Macros","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"As in previous examples we offer functions and macros to convert Julia syntax into certain structs described above. You may use these instead of calling constructors.","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"All the functions listed below accept Expr object as its argument (e.g. :(x = 10), see Julia Documents for more information.), and that is why variables inside the argument Expr object do not have to be declared anywhere else in the source code. The syntaxes each function requires in a argument Expr objects are also described below (or may be easily inferred from the examples here and Brief Introduction).","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"As you see in Brief Introduction there are macros that do the same thing as functions listed below (and both macro and function has the same name). As macros take Expr object as its argument, you can write codes in a slightly more simple manner with macros. For example,","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"always(:(\r\n    @posedge clk; \r\n\r\n    w1 <= w2;\r\n    if b1 == b2 \r\n        w3 <= w4\r\n    end\r\n))","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"is equivalent to ","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"@always (\r\n    @posedge clk; \r\n\r\n    w1 <= w2;\r\n    if b1 == b2 \r\n        w3 <= w4\r\n    end\r\n)","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"(be care full not to foreget (one space) between macros and (, i.e. @macro(a;b) and @macro (a;b) are different.)","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"But sometimes there are things what macros cannot do (at least to me it seems impossible in macros), an example is having for loop inside expressions.","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"d = always(:(\r\n    if b1 \r\n        $([:($(Symbol(\"x$i\")) = $(Symbol(\"y$i\"))) for i in 1:3]...)\r\n    end\r\n))\r\nvshow(d)","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"and this outputs","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"always_comb begin\r\n    if (b1) begin\r\n        x1 = y1;\r\n        x2 = y2;\r\n        x3 = y3;\r\n    end\r\nend\r\ntype: Alwayscontent","category":"page"},{"location":"structs/#List-of-Converter-Functions/Macros","page":"Component structs","title":"List of Converter Functions/Macros","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Written inside parentheses are the types of objects the functions return.","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"ports (Ports)\nportoneline (Oneport)\nwireexpr (Wireexpr)\ndecls (Decls)\ndecloneline (Onedecl)\nalways (Alwayscontent)\noneblock  (Ifelseblock,Alassign)","category":"page"},{"location":"structs/#ports","page":"Component structs","title":"ports","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"ports(::Expr)\r\nports(::Vector{Oneport})","category":"page"},{"location":"structs/#VerilogWriter.ports-Tuple{Expr}","page":"Component structs","title":"VerilogWriter.ports","text":"ports(expr::Expr)\n\nConvert Julia AST into port declarations as Ports object.\n\nSyntax\n\n<portoneline>[;<portoneline>;...]\n\nMultiple lines of portoneline expressions  separated by ; can be accepted. \n\nExample\n\npp = ports(:(\n    @in p1;\n    @in wire 8 p2, p3, p4;\n    @out reg 2 p5, p6\n))\n\nvshow(pp)\n\n# output\n\n(\n    input p1,\n    input [7:0] p2,\n    input [7:0] p3,\n    input [7:0] p4,\n    output reg [1:0] p5,\n    output reg [1:0] p6\n);\n\ntype: Ports\n\n\n\n\n\n","category":"method"},{"location":"structs/#VerilogWriter.ports-Tuple{Vector{Oneport}}","page":"Component structs","title":"VerilogWriter.ports","text":"ports(expr::Vector{Oneport})\n\nInsertion through metaprogramming.\n\nExample\n\na = @portoneline @in 8 d1, d2, d3\nb = ports(:(\n    @in d0;\n    $(a);\n    @out reg 8 dout\n))\nvshow(b)\n\n# output\n\n(\n    input d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [7:0] d3,\n    output reg [7:0] dout\n);\n\ntype: Ports\n\n\n\n\n\n","category":"method"},{"location":"structs/#portoneline","page":"Component structs","title":"portoneline","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"portoneline(::Expr)","category":"page"},{"location":"structs/#VerilogWriter.portoneline-Tuple{Expr}","page":"Component structs","title":"VerilogWriter.portoneline","text":"portoneline(expr::Expr)\n\nParse Julia AST to one line of port declaration as Oneport.\n\nSyntax\n\n@in <wirename>, @out <wirename>\n\nOne port declaration of width 1.\n\n@in/@out <wirename1, wirename2, ...>\n\nMultiple port declaration of width 1 in one line.\n\n@in/@out <width::Int> <wirename1[, wirename2, ...]>\n\nPort declarations of width <width>.\n\n@in/@out <wiretype> [<width::Int>] <wirename1[, wirename2, ...]>\n\nPort declaration with wiretypes [of width <width>].\n\nExamples\n\njulia> p1 = portoneline(:(@in din));\n\njulia> vshow(p1);\ninput din\ntype: Oneport\n\njulia> p2 = portoneline(:(@out din1, din2, din3)); vshow(p2);\noutput din1\ntype: Oneport\noutput din2\ntype: Oneport\noutput din3\ntype: Oneport\n\njulia> p3 = portoneline(:(@in 8 din)); vshow(p3);\ninput [7:0] din\ntype: Oneport\n\njulia> p4 = portoneline(:(@out reg 8 dout)); vshow(p4);\noutput reg [7:0] dout\ntype: Oneport\n\n\n\n\n\n","category":"method"},{"location":"structs/#wireexpr","page":"Component structs","title":"wireexpr","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"wireexpr(::Expr)\r\nwireexpr(::Wireexpr)","category":"page"},{"location":"structs/#VerilogWriter.wireexpr-Tuple{Expr}","page":"Component structs","title":"VerilogWriter.wireexpr","text":"wireexpr(expr::Expr)\n\nParse one wire expression. Be sure to put 'two e's' in wir'ee'xpr, not 'wirexpr'.\n\nSyntax\n\nPart of what can be done in Verilog can be accepted,  such as din[7:0], (w1 + w2) << 5\n\n<wirename>\n\nOne wire, without slicing or bit-selecting.\n\n<val::Int>, <val::hex>, <val::bin>\n\nLiterals, e.g. 5, 0x1f, 0b10.\n\n<wire> <op> <wire>, <op> <wire>\n\nUnary and binary operators.  For reduction operators (unary &, |, ^), since these are  not operators in Julia, write it in the form of function  call explicitly, i.e. &(wire), |(wire) instead of doing ^wire. Note that we use ^ as xor just as in Verilog, though this is not  a xor operator in Julia.\n\n<wire>[<wire>:<wire>], <wire>[<wire>]\n\nBit select and slicing as in Verilog/SystemVerilog.\n\nExamples\n\njulia> w = wireexpr(:(w)); vshow(w);\nw\ntype: Wireexpr\n\njulia> w = wireexpr(:(w1 & &(w2) )); vshow(w);\n(w1 & &(w2))\ntype: Wireexpr\n\njulia> w = wireexpr(:(w[i:0])); vshow(w);\nw[i:0]\ntype: Wireexpr\n\n\n\n\n\n","category":"method"},{"location":"structs/#VerilogWriter.wireexpr-Tuple{Wireexpr}","page":"Component structs","title":"VerilogWriter.wireexpr","text":"wireexpr(expr::Wireexpr)\n\nInsertion through metaprogramming.\n\nExample\n\njulia> w = @wireexpr x + y;\n\njulia> e = :(a + |($(w) & z));\n\njulia> ans = wireexpr(e); vshow(ans);\n(a + |(((x + y) & z)))\ntype: Wireexpr\n\n\n\n\n\n","category":"method"},{"location":"structs/#decls","page":"Component structs","title":"decls","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"decls(::Expr)\r\ndecls(::Vector{Onedecl})","category":"page"},{"location":"structs/#VerilogWriter.decls-Tuple{Expr}","page":"Component structs","title":"VerilogWriter.decls","text":"decls(expr::Expr)\n\nParse Julia AST into wire declaration section object Decls.\n\nSyntax\n\n<onedecl>[;<onedecl>;...]\n\nMultiple decloneline expressions which are concatenated  by ; can be accepted.\n\nExample\n\nd = decls(:(\n    @wire w1;\n    @reg 8 w2,w3,w4;\n    @logic 32 w5\n))\nvshow(d)\n\n# output\n\nwire w1;\nreg [7:0] w2;\nreg [7:0] w3;\nreg [7:0] w4;\nlogic [31:0] w5;\ntype: Decls\n\n\n\n\n\n","category":"method"},{"location":"structs/#VerilogWriter.decls-Tuple{Vector{Onedecl}}","page":"Component structs","title":"VerilogWriter.decls","text":"decls(expr::Vector{Onedecl})\n\nFor insertion with metaprogramming.\n\nExample\n\na = @decloneline @reg 8 x1, x2\nb = decls(:(\n    $(a);\n    @wire y1, y2\n))\nvshow(b)\n\n# output\n\nreg [7:0] x1;\nreg [7:0] x2;\nwire y1;\nwire y2;\ntype: Decls\n\n\n\n\n\n","category":"method"},{"location":"structs/#decloneline","page":"Component structs","title":"decloneline","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"decloneline(::Expr)","category":"page"},{"location":"structs/#VerilogWriter.decloneline-Tuple{Expr}","page":"Component structs","title":"VerilogWriter.decloneline","text":"decloneline(expr::Expr)\n\nParse Julia AST into wire declaration as Vector{Onedecl}.\n\nThe number of Onedecl objects returned may differ  according to the number of wires declared in one line  (e.g. input dout <=> input din1, din2, din3).\n\nSyntax\n\nSimilar to that of portoneline.\n\n@wire/@reg/@logic [<width>] <wirename1>[, <wirename2>,...]\n\nExamples\n\njulia> d = decloneline(:(@reg 10 d1)); vshow(d);\nreg [9:0] d1;\ntype: Onedecl\n\njulia> d = decloneline(:(@logic 8 d1,d2,d3)); vshow(d);\nlogic [7:0] d1;\ntype: Onedecl\nlogic [7:0] d2;\ntype: Onedecl\nlogic [7:0] d3;\ntype: Onedecl\n\n\n\n\n\n","category":"method"},{"location":"structs/#always","page":"Component structs","title":"always","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"always(::Expr)","category":"page"},{"location":"structs/#VerilogWriter.always-Tuple{Expr}","page":"Component structs","title":"VerilogWriter.always","text":"always(expr::Expr)\n\nParse AST into always block as Alwayscontent using ralways.\n\nAlso infers type of always using addatype!.\n\nSyntax\n\n<oneblock>;<oneblock>[;<oneblock>;...]\n\n<oneblock> is the expression that can be parsed by oneblock. ; in between <oneblock>s are strictly needed.\n\n@posedge <wirename>; <ifelsestatements>/<assignments>\n\nSet sensitivity list using macro syntax. @negedge is also possible.  You must put @posegde/@negedge statement at the beginning, and only once.\n\nExamples\n\na1 = always(:(\n    w1 = w2;\n    if b2 \n        w1 = w3 \n    end\n))\nvshow(a1)\n\n# output\n\nalways_comb begin\n    w1 = w2;\n    if (b2) begin\n        w1 = w3;\n    end\nend\ntype: Alwayscontent\n\na1 = always(:(\n    @posedge clk;\n    \n    if b1 == b2\n        w1 <= w2 + w3 \n    else\n        w1 <= ~w1 \n    end\n))\nvshow(a1)\n\n# output\n\nalways_ff @( posedge clk ) begin\n    if ((b1 == b2)) begin\n        w1 <= (w2 + w3);\n    end else begin\n        w1 <= ~w1;\n    end\nend\ntype: Alwayscontent\n\n\n\n\n\n","category":"method"},{"location":"structs/#oneblock","page":"Component structs","title":"oneblock","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"oneblock(::Expr)\r\noneblock(expr::T) where {T <: Union{Alassign, Ifelseblock}}","category":"page"},{"location":"structs/#VerilogWriter.oneblock-Tuple{Expr}","page":"Component structs","title":"VerilogWriter.oneblock","text":"oneblock(expr::Expr)\n\nParse AST in Julia grammar to one if-else statement or  one assignment inside always blocks in Verilog,  which are Ifelseblock and Alassign, respectively. \n\nAs using Julia expression and Julia parser as if  it is of Verilog, there can be difference in grammatical matters  between what can be given as the expr and real Verilog  (e.g. operator precedence of <=).\n\nSyntax\n\n<wirename1> = <wireoperation>\n\nOne blocking assignment. (Note that bit width cannot be  specified yet, nor can it be printed.) <wireoperation> is a expression accepted by wireexpr.\n\nIf-else statement\n\nif <wireoperation>\n    <oneassignment>\n    <oneassignment>\n    ...\nelseif <wireoperation> \n    <oneassignment>\n    <ifelsestatement>\n    ...\nelse\n    <ifelsestatement>\n    ...\nend\n\nIf-else statement written in 'Julia syntax', not in Verilog  syntax, can be accepted. else block and elseif are not compulsory. Since if end are at the top level no ; inside if-else statement is needed. Nested if-else statement can be also accepted as in usual Julia.\n\nExamples\n\njulia> a1 = oneblock(:(w1 <= w2)); \n\njulia> vshow(a1);\nw1 <= w2;\ntype: Alassign\n\njulia> a2 = oneblock(:(w3 = w4 + ~w2)); vshow(a2);\nw3 = (w4 + ~w2);\ntype: Alassign\n\na3 = oneblock(:(\n    if b1 == b2\n        w5 = ~w6\n        w7 = w8 \n    elseif b2 \n        w9 = w9 + w10\n    else\n        if b3 \n            w11 = w12 \n        end\n    end\n))\nvshow(a3)\n\n# output\n\nif ((b1 == b2)) begin\n    w5 = ~w6;\n    w7 = w8;\nend else if (b2) begin\n    w9 = (w9 + w10);\nend else begin\n    if (b3) begin\n        w11 = w12;\n    end\nend\ntype: Ifelseblock\n\n\n\n\n\n","category":"method"},{"location":"structs/#VerilogWriter.oneblock-Tuple{T} where T<:Union{Alassign, Ifelseblock}","page":"Component structs","title":"VerilogWriter.oneblock","text":"oneblock(expr::T) where {T <: Union{Alassign, Ifelseblock}}\n\nFor insertion through metaprogramming.\n\nExample\n\na = @oneblock r = s & t\nb = @oneblock (\n    if b \n        x = y \n    else\n        x = z\n    end\n)\nc = always(:(\n    p = q;\n    $(a);\n    $(b)\n))\nvshow(c)\n\n# output\n\nalways_comb begin\n    p = q;\n    r = (s & t);\n    if (b) begin\n        x = y;\n    end else begin\n        x = z;\n    end\nend\ntype: Alwayscontent\n\n\n\n\n\n","category":"method"},{"location":"structs/#Embedding-Objects","page":"Component structs","title":"Embedding Objects","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"You can embed generated objects back into Verilog-like codes. Note that because we ask you to make use of metaprogramming (interpolation in particular), macros cannot be used for the purpose. ","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"By embedding objects as Julia AST, you can construct new objects that contain the information of embedded objects.","category":"page"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"Every object (offered in this package) can be embedded almost anywhere it seems to be possible.","category":"page"},{"location":"structs/#Examples","page":"Component structs","title":"Examples","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"julia> a = @portoneline @in clk;\r\n\r\njulia> b = ports(:($(a); @out 8 dout)); vshow(b);\r\n(\r\n    input clk,\r\n    output [7:0] dout\r\n);\r\n\r\ntype: Ports\r\n\r\njulia> a = @ports (@in clk; @out 8 dout);\r\n\r\njulia> b = ports(:(@in resetn; $(a))); vshow(b);\r\n(\r\n    input resetn,\r\n    input clk,\r\n    output [7:0] dout\r\n);\r\n\r\ntype: Ports\r\n\r\njulia> a = @wireexpr (x + y) & z;\r\n\r\njulia> b = always(:(lhs = $(a) | w)); vshow(b);\r\nalways_comb begin\r\n    lhs = (((x + y) & z) | w);\r\nend\r\ntype: Alwayscontent","category":"page"},{"location":"structs/#Other-Functions","page":"Component structs","title":"Other Functions","text":"","category":"section"},{"location":"structs/#vshow","page":"Component structs","title":"vshow","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"vshow(::Any)","category":"page"},{"location":"structs/#VerilogWriter.vshow-Tuple{Any}","page":"Component structs","title":"VerilogWriter.vshow","text":"vshow(x; systemverilog=true)\n\nPrint the structs in VerilogWriter.jl in a readable  format (except for enums). When systemverilog=false, output always, always @*  instead of always_ff, always_comb, respectively.\n\n\n\n\n\n","category":"method"},{"location":"structs/#invports","page":"Component structs","title":"invports","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"invports","category":"page"},{"location":"structs/#VerilogWriter.invports","page":"Component structs","title":"VerilogWriter.invports","text":"invports(ps::Ports)\n\nReturn Ports object whose directions are reversed from ps.\n\nExamples\n\npts = @ports (\n    @in 8 bus1, bus2;\n    @out reg bus3\n)\nipts = invports(pts)\nvshow(pts)\nvshow(ipts)\n\n# output\n\n(\n    input [7:0] bus1,\n    input [7:0] bus2,\n    output reg bus3\n);\n\ntype: Ports\n(\n    output [7:0] bus1,\n    output [7:0] bus2,\n    input bus3\n);\n\ntype: Ports\n\n\n\n\n\n","category":"function"},{"location":"structs/#invport","page":"Component structs","title":"invport","text":"","category":"section"},{"location":"structs/","page":"Component structs","title":"Component structs","text":"invport","category":"page"},{"location":"structs/#VerilogWriter.invport","page":"Component structs","title":"VerilogWriter.invport","text":"invport(onep::Oneport)\n\nReturn Oneport object whose directions are reversed from onep. Wiretype information (reg, wire, logic) is  lost when inverted for reg cannot be at input port.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = VerilogWriter","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"No detailed descriptions available yet.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Still ?<function-name> on IJulia, Julia REPL will return docstrings for most of the functions, structs, and constant values in this module.","category":"page"},{"location":"#What-You-Can-Do-with-VerilogWriter.jl","page":"Tutorial","title":"What You Can Do with VerilogWriter.jl","text":"","category":"section"},{"location":"","page":"Tutorial","title":"Tutorial","text":"CurrentModule = VerilogWriter\r\nDocTestSetup = quote\r\n    using VerilogWriter\r\nend","category":"page"},{"location":"#Convert-Verilog-like-Julia-Code-into-Objects","page":"Tutorial","title":"Convert Verilog-like Julia Code into Objects","text":"","category":"section"},{"location":"","page":"Tutorial","title":"Tutorial","text":"julia> a = @portoneline @in x;\r\n\r\njulia> vshow(a);\r\ninput x\r\ntype: Oneport\r\n\r\njulia> b = @portoneline @out reg 8 d1, d2;\r\n\r\njulia> vshow(b);\r\noutput reg [7:0] d1\r\ntype: Oneport\r\noutput reg [7:0] d2\r\ntype: Oneport","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"c = @always (\r\n    @posedge clk;\r\n    \r\n    d1 <= d2 + d3;\r\n    if b1 && b2\r\n        d4 <= d5 ^ d6 \r\n    else\r\n        d4 <= ~d4[7:0] \r\n    end\r\n)\r\nvshow(c)\r\n\r\n# output\r\n\r\nalways_ff @( posedge clk ) begin\r\n    d1 <= (d2 + d3);\r\n    if ((b1 && b2)) begin\r\n        d4 <= (d5 ^ d6);\r\n    end else begin\r\n        d4 <= ~d4[7:0];\r\n    end\r\nend\r\ntype: Alwayscontent","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"You may also create objects from constructors and apply some operations.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"julia> c = Wireexpr(\"wire1\");\r\n\r\njulia> d = Wireexpr(\"wire2\");\r\n\r\njulia> e = @wireexpr wire3 << 5;\r\n\r\njulia> vshow((c & d) + e);\r\n((wire1 & wire2) + (wire3 << 5))\r\ntype: Wireexpr","category":"page"},{"location":"#Embed-Generated-Objects-Back-into-Verilog-like-Codes","page":"Tutorial","title":"Embed Generated Objects Back into Verilog-like Codes","text":"","category":"section"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Using metaprogramming, you would do, for example, ","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"a = @always (\r\n    d1 = d2 + d3;\r\n    d4 = d4 & d5\r\n)\r\nb = always(:(\r\n    $(a);\r\n    if b1 == b2 \r\n        d6 = ~d7\r\n    end\r\n))\r\nvshow(b)\r\n\r\n# output\r\n\r\nalways_comb begin\r\n    d1 = (d2 + d3);\r\n    d4 = (d4 & d5);\r\n    if ((b1 == b2)) begin\r\n        d6 = ~d7;\r\n    end\r\nend\r\ntype: Alwayscontent","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Note that you cannot use macros when embedding objects in Verilog-like codes.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"One application of this syntax would be ","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"a = @ports (\r\n    @in 8 bus1, bus2;\r\n    @out 8 bus3\r\n)\r\nsend = Vmodule(\r\n    \"send\",\r\n    ports(:(\r\n        @in sendin;\r\n        $(a)\r\n    )),\r\n    Decls(),\r\n    Alwayscontent[]\r\n)\r\nrecv = Vmodule(\r\n    \"recv\",\r\n    ports(:(\r\n        @in recvin;\r\n        $(invports(a))\r\n    )),\r\n    Decls(),\r\n    Alwayscontent[]\r\n)\r\nvshow(send)\r\nprintln()\r\nvshow(recv)\r\n\r\n# output\r\n\r\nmodule send (\r\n    input sendin,\r\n    input [7:0] bus1,\r\n    input [7:0] bus2,\r\n    output [7:0] bus3\r\n);\r\n    \r\n\r\n\r\nendmodule\r\ntype: Vmodule\r\n\r\nmodule recv (\r\n    input recvin,\r\n    output [7:0] bus1,\r\n    output [7:0] bus2,\r\n    input [7:0] bus3\r\n);\r\n    \r\n\r\n\r\nendmodule\r\ntype: Vmodule","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"where you can construct Ports objects first and embed them in multiple modules.","category":"page"}]
}
