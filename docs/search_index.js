var documenterSearchIndex = {"docs":
[{"location":"intro.html#VerilogWriter.jl-Document","page":"Introduction","title":"VerilogWriter.jl Document","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"CurrentModule = VerilogWriter","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"using VerilogWriter","category":"page"},{"location":"intro.html#Brief-Introduction","page":"Introduction","title":"Brief Introduction","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"If you have IJulia locally, execute","category":"page"},{"location":"intro.html#In[1]","page":"Introduction","title":"In[1]","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"using VerilogWriter","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"(or make .jl file and execute codes with julia <filename>.jl instead.) and then","category":"page"},{"location":"intro.html#In[2]","page":"Introduction","title":"In[2]","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"x = @always (\n    dout = d1 + d2;\n    if b1\n        dout = ~d1\n    elseif b2 \n        dout = ~d2\n    end\n)\nvshow(x)","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"(note that variables such as dout, b1 are not declared anywhere.)","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"and now you see the following:","category":"page"},{"location":"intro.html#Out[2]","page":"Introduction","title":"Out[2]","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"always_comb begin\n    dout = (d1 + d2);\n    if (b1) begin\n        dout = ~d1;\n    end else if (b2) begin\n        dout = ~d2;\n    end\nend\ntype: Alwayscontent","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Another example is ","category":"page"},{"location":"intro.html#In[3]","page":"Introduction","title":"In[3]","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"ps = @ports (\n    @in b1, RST\n)\nds = @decls (\n    @reg 8 dreg1\n)\nc = ifcontent(:(\n    reg1 <= dreg1;\n    if b1 \n        reg2 <= reg1[7:6]\n        reg3 <= reg1[0]\n        reg4 <= reg1\n        reg5 <= $(Wireexpr(32, 4))\n    else \n        reg5 <= 0\n    end\n))\nac = autoreset(c)\nenv = Vmodenv(Parameters(), ps, Localparams(), ds)\nad = autodecl(ac.content, env)\n\nvshow(ad)\nvshow(ac)","category":"page"},{"location":"intro.html#Out[3]","page":"Introduction","title":"Out[3]","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"reg [7:0] reg1;\nreg [1:0] reg2;\nreg reg3;\nreg [7:0] reg4;\nreg [31:0] reg5;\ntype: Decls\nalways_ff @( posedge CLK ) begin\n    if (RST) begin\n        reg1 <= 0;\n        reg2 <= 0;\n        reg3 <= 0;\n        reg4 <= 0;\n        reg5 <= 0;\n    end else begin\n        reg1 <= dreg1;\n        if (b1) begin\n            reg2 <= reg1[7:6];\n            reg3 <= reg1[0];\n            reg4 <= reg1;\n            reg5 <= 32'd4;\n        end else begin\n            reg5 <= 0;\n        end\n    end\nend\ntype: Alwayscontent","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"(of course this verilog module itself is far from being useful.)","category":"page"},{"location":"intro.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"This package offers a simple method to write on Julia Verilog/SystemVerilog codes not as raw strings but as objects with certain structures, such as always-block-objects, port-declaration-objects, and so on (not as sophisticated as, for example, Chisel is, though).","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"The motivation here is that it would be nice if we could write Verilog/SystemVerilog with the power of the Julia language, with a minimal amount of additional syntaxes (function calls, constructors, etc.). ","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"As in the examples above, we offer, for instance, simple macros to convert Verilog-like Julia code into certain objects that have proper structure found in Verilog codes.","category":"page"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"CurrentModule = VerilogWriter","category":"page"},{"location":"intro.html#What-is-Left-to-be-Done","page":"Introduction","title":"What is Left to be Done","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"It seems too many things are left to be done to make this VerilogWriter.jl, at least to some extent, useful, but to list few of them, ","category":"page"},{"location":"intro.html#Unsupported-Syntaxes","page":"Introduction","title":"Unsupported Syntaxes","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"Lots of operators and syntaxes in Verilog/SystemVerilog is not supported (e.g. for, generate for, interfaces, tasks, always_latch, indexed part select, and so on), although some of them can be replaced by using Julia syntaxes instead (e.g. using Julia for loop and generate multiple always blocks instead of Verilog), or rather it 'should be' replaced to make use of the power of Julia language.","category":"page"},{"location":"intro.html#Not-Enough-Handlers-of-the-Structs","page":"Introduction","title":"Not Enough Handlers of the Structs","text":"","category":"section"},{"location":"intro.html","page":"Introduction","title":"Introduction","text":"We offer here some structs to imitate what is done in Verilog codes, but few functions to handle them are offered together. Still you can construct some more functions to handle the structs offered here, making it a little easier to make more complex Verilog modules.","category":"page"},{"location":"structs.html#Component-Structs","page":"Basic Structs","title":"Component Structs","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"CurrentModule = VerilogWriter\nDocTestSetup = quote\n    using VerilogWriter\nend","category":"page"},{"location":"structs.html#Structs-Description","page":"Basic Structs","title":"Structs Description","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"This module offers several structs that contain a structure of Verilog components, major ones of which are listed below. ","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Parameters\nOneparam\nPorts\nOneport\nPortdirec\nWiretype\nLocalparams\nOnelocalparam\nWireexpr\nWireop\nDecls\nOnedecl\nAssign\nAlwayscontent\nAlassign\nIfelseblock\nIfcontent\nAtype\nEdge\nVmodinst\nVmodule","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"push!(LOAD_PATH,\"../../src/\")\nusing VerilogWriter","category":"page"},{"location":"structs.html#Parameters","page":"Basic Structs","title":"Parameters","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Parameters)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Parameters","category":"page"},{"location":"structs.html#VerilogWriter.Parameters","page":"Basic Structs","title":"VerilogWriter.Parameters","text":"List of parameters.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Oneparam","page":"Basic Structs","title":"Oneparam","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Oneparam)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Oneparam","category":"page"},{"location":"structs.html#VerilogWriter.Oneparam","page":"Basic Structs","title":"VerilogWriter.Oneparam","text":"Parameter in verilog.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Ports","page":"Basic Structs","title":"Ports","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Ports)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Ports","category":"page"},{"location":"structs.html#VerilogWriter.Ports","page":"Basic Structs","title":"VerilogWriter.Ports","text":"Gather multiple ports.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Oneport","page":"Basic Structs","title":"Oneport","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Oneport)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Oneport","category":"page"},{"location":"structs.html#VerilogWriter.Oneport","page":"Basic Structs","title":"VerilogWriter.Oneport","text":"Represent a single port declaration.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Portdirec","page":"Basic Structs","title":"Portdirec","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Portdirec)))) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Portdirec","category":"page"},{"location":"structs.html#VerilogWriter.Portdirec","page":"Basic Structs","title":"VerilogWriter.Portdirec","text":"Port direction object.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Wiretype","page":"Basic Structs","title":"Wiretype","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Wiretype)))) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Wiretype","category":"page"},{"location":"structs.html#VerilogWriter.Wiretype","page":"Basic Structs","title":"VerilogWriter.Wiretype","text":"Wiretype object.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Localparams","page":"Basic Structs","title":"Localparams","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Localparams)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Localparams","category":"page"},{"location":"structs.html#VerilogWriter.Localparams","page":"Basic Structs","title":"VerilogWriter.Localparams","text":"Multiple localparams.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Onelocalparam","page":"Basic Structs","title":"Onelocalparam","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Onelocalparam)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Onelocalparam","category":"page"},{"location":"structs.html#VerilogWriter.Onelocalparam","page":"Basic Structs","title":"VerilogWriter.Onelocalparam","text":"One localparam.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Wireexpr","page":"Basic Structs","title":"Wireexpr","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Wireexpr)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Wireexpr\n\nWireexpr(n::String)\nWireexpr(n::Symbol)\nWireexpr(n::Int)\nWireexpr(op::Wireop, w::Wireexpr...)\nWireexpr(op::Wireop, v::Vector{Wireexpr})\nWireexpr(n::String, msb::T) where {T <: Union{Int, Wireexpr}}\nWireexpr(n::String, msb::T1, lsb::T2) where {T1 <: Union{Int, Wireexpr}, T2 <: Union{Int, Wireexpr}}\nWireexpr(w::Int, n::Int)\nWireexpr(expr::Wireexpr)\nWireexpr()","category":"page"},{"location":"structs.html#VerilogWriter.Wireexpr","page":"Basic Structs","title":"VerilogWriter.Wireexpr","text":"Wire expressions in verilog. \n\nContains unnecessary information to handle all the wires in the same type. \n\nOne motivation to avoid making different types of  wires (e.g. using parametric types) is that it seemed beneficial to have multiple wires in a vector, and that  it is sometime a disadvantage in performance to use  abstract types when creating vectors.\n\nSome operators on wires in Verilog, which are listed in Enum Wireop,  are overloaded for Wireexpr. Note that reduction operators (unary &, |, ^) are not in Julia,  and logical and, or (&&, ||) can be applied only for booleans in Julia, thus  are not available as an operator for Wireexpr objects.\n\nExamples\n\njulia> w1 = @wireexpr x + y;\n\njulia> w2 = @wireexpr z;\n\njulia> vshow(w1 & w2);\n((x + y) & z)\ntype: Wireexpr\n\njulia> w3 = @wireexpr x;\n\njulia> w4 = @wireexpr y && z; # && is available inside `@wireexpr` and `wireexpr` methods.\n\njulia> vshow(w3 | w4)\n(x | (y && z))\ntype: Wireexpr\n\n\n\n\n\n","category":"type"},{"location":"structs.html#VerilogWriter.Wireexpr-Tuple{String}","page":"Basic Structs","title":"VerilogWriter.Wireexpr","text":"Wireexpr(n::String)\n\nCase where no slice is needed.\n\n\n\n\n\n","category":"method"},{"location":"structs.html#VerilogWriter.Wireexpr-Tuple{Symbol}","page":"Basic Structs","title":"VerilogWriter.Wireexpr","text":"Wireexpr(n::Symbol)\n\nConvert Symbol to String and construct Wireexpr.\n\n\n\n\n\n","category":"method"},{"location":"structs.html#VerilogWriter.Wireexpr-Tuple{Int64}","page":"Basic Structs","title":"VerilogWriter.Wireexpr","text":"Wireexpr(n::Int)\n\nLiteral of Integer.\n\n\n\n\n\n","category":"method"},{"location":"structs.html#VerilogWriter.Wireexpr-Tuple{Wireop, Vararg{Wireexpr}}","page":"Basic Structs","title":"VerilogWriter.Wireexpr","text":"Wireexpr(op::Wireop, w::Wireexpr...)\n\nApply an operation of w wires.\n\nExamples\n\njulia> a = @wireexpr a; b = @wireexpr b;\n\njulia> c = Wireexpr(add, a, b); # equivalent to wireexpr(:($(a) + $(b)))\n\njulia> vshow(c);\n(a + b)\ntype: Wireexpr\n\njulia> d = Wireexpr(redor, a); vshow(d); # wireexpr(:(|($(a))))\n|(a)\ntype: Wireexpr\n\n\n\n\n\n","category":"method"},{"location":"structs.html#VerilogWriter.Wireexpr-Tuple{Wireop, Vector{Wireexpr}}","page":"Basic Structs","title":"VerilogWriter.Wireexpr","text":"Wireexpr(op::Wireop, v::Vector{Wireexpr})\n\nApply an operation on wires in v.\n\n\n\n\n\n","category":"method"},{"location":"structs.html#VerilogWriter.Wireexpr-Union{Tuple{T}, Tuple{String, T}} where T<:Union{Int64, Wireexpr}","page":"Basic Structs","title":"VerilogWriter.Wireexpr","text":"Wireexpr(n::String, msb::T) where {T <: Union{Int, Wireexpr}}\n\nGet one bit at msb from n.\n\n\n\n\n\n","category":"method"},{"location":"structs.html#VerilogWriter.Wireexpr-Union{Tuple{T2}, Tuple{T1}, Tuple{String, T1, T2}} where {T1<:Union{Int64, Wireexpr}, T2<:Union{Int64, Wireexpr}}","page":"Basic Structs","title":"VerilogWriter.Wireexpr","text":"Wireexpr(n::String, msb::T1, lsb::T2) where {T1 <: Union{Int, Wireexpr}, T2 <: Union{Int, Wireexpr}}\n\nSlice of n from msb to lsb.\n\nIndex for wires can be Int or Wireexpr.\n\n\n\n\n\n","category":"method"},{"location":"structs.html#VerilogWriter.Wireexpr-Tuple{Int64, Int64}","page":"Basic Structs","title":"VerilogWriter.Wireexpr","text":"Wireexpr(w::Integer, n::Integer)\n\nLiteral with width specification, printed in the decimal format.\n\n\n\n\n\n","category":"method"},{"location":"structs.html#VerilogWriter.Wireexpr-Tuple{Wireexpr}","page":"Basic Structs","title":"VerilogWriter.Wireexpr","text":"Wireexpr(expr::Wireexpr)\n\nReturn the argument itself, used in slice construction to make it possible to apply the same method to msb as Int and as Wireexpr.\n\n\n\n\n\n","category":"method"},{"location":"structs.html#VerilogWriter.Wireexpr-Tuple{}","page":"Basic Structs","title":"VerilogWriter.Wireexpr","text":"Wireexpr()\n\nCreate an empty expression.\n\n\n\n\n\n","category":"method"},{"location":"structs.html#Wireop","page":"Basic Structs","title":"Wireop","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Wireop)))) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Wireop","category":"page"},{"location":"structs.html#VerilogWriter.Wireop","page":"Basic Structs","title":"VerilogWriter.Wireop","text":"Verilog operators.\n\nUnary &, | does not exist so explicitly call as function e.g. &(wire), |(wire) (& behaves in a wickedmanner...?), and are only available inside quoted expressions. Xor in verilog ^ is in Julia exponential operator, and the difference in an association exists.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Decls","page":"Basic Structs","title":"Decls","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Decls)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Decls","category":"page"},{"location":"structs.html#VerilogWriter.Decls","page":"Basic Structs","title":"VerilogWriter.Decls","text":"Multiple wire declarations.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Onedecl","page":"Basic Structs","title":"Onedecl","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Onedecl)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Onedecl","category":"page"},{"location":"structs.html#VerilogWriter.Onedecl","page":"Basic Structs","title":"VerilogWriter.Onedecl","text":"Represent one wire declaration.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Assign","page":"Basic Structs","title":"Assign","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Assign)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Assign","category":"page"},{"location":"structs.html#VerilogWriter.Assign","page":"Basic Structs","title":"VerilogWriter.Assign","text":"Assign one statement.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Alwayscontent","page":"Basic Structs","title":"Alwayscontent","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Alwayscontent)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Alwayscontent","category":"page"},{"location":"structs.html#VerilogWriter.Alwayscontent","page":"Basic Structs","title":"VerilogWriter.Alwayscontent","text":"Represent always blocks.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Alassign","page":"Basic Structs","title":"Alassign","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Alassign)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Alassign","category":"page"},{"location":"structs.html#VerilogWriter.Alassign","page":"Basic Structs","title":"VerilogWriter.Alassign","text":"Assign statement inside always blocks.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Ifelseblock","page":"Basic Structs","title":"Ifelseblock","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Ifelseblock)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Ifelseblock","category":"page"},{"location":"structs.html#VerilogWriter.Ifelseblock","page":"Basic Structs","title":"VerilogWriter.Ifelseblock","text":"Container of an if-else block. Parametrized by T for mutual recursion. Used as Ifelseblock = Ifelseblock_inner{Case}.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Ifcontent","page":"Basic Structs","title":"Ifcontent","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Ifcontent)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Ifcontent","category":"page"},{"location":"structs.html#VerilogWriter.Ifcontent","page":"Basic Structs","title":"VerilogWriter.Ifcontent","text":"Container of one if-block (, one elseif block, or one else block).\n\nParametrized by T, U only for mutual recursion with Ifelseblock and Case, thus used as Ifcontent_inner{Ifelseblock, Case}, which is aliased as Ifcontent.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Atype","page":"Basic Structs","title":"Atype","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Atype)))) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Atype","category":"page"},{"location":"structs.html#VerilogWriter.Atype","page":"Basic Structs","title":"VerilogWriter.Atype","text":"Type of always blocks.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Edge","page":"Basic Structs","title":"Edge","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(string(\"Enum \", reduce((x, y)->string(x, \" \", y), instances(Edge)))) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Edge","category":"page"},{"location":"structs.html#VerilogWriter.Edge","page":"Basic Structs","title":"VerilogWriter.Edge","text":"Edge in sensitivity lists.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Vmodinst","page":"Basic Structs","title":"Vmodinst","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Vmodinst)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Vmodinst","category":"page"},{"location":"structs.html#VerilogWriter.Vmodinst","page":"Basic Structs","title":"VerilogWriter.Vmodinst","text":"Vmodinst\n\nRepresents module instantiation.\n\ni = Vmodinst(\n    \"mod1\",\n    \"u1\",\n    [\n        \"A\" => Wireexpr(15)\n    ],\n    [\n        \"p1\" => (@wireexpr x << 1),\n        \"p2\" => (@wireexpr y)\n    ]\n)\nvshow(i)\n\n# output\n\nmod1 #(\n    .A(15)\n) u1 (\n    .p1((x << 1)),\n    .p2(y)\n);\ntype: Vmodinst\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Vmodule","page":"Basic Structs","title":"Vmodule","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"println(showfield(Vmodule)) # hide","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Vmodule","category":"page"},{"location":"structs.html#VerilogWriter.Vmodule","page":"Basic Structs","title":"VerilogWriter.Vmodule","text":"Represents one verilog module.\n\n\n\n\n\n","category":"type"},{"location":"structs.html#Converter-Functions/Macros","page":"Basic Structs","title":"Converter Functions/Macros","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"As in previous examples we offer functions and macros to convert Julia syntax into certain structs described above. You may use these instead of calling constructors.","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"All the functions listed below accept Expr object as its argument (e.g. :(x = 10), see Julia Documents for more information.), and that is why variables inside the argument Expr object do not have to be declared anywhere else in the source code. The syntaxes each function requires in a argument Expr objects are also described below (or may be easily inferred from the examples here and Brief Introduction).","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"As you see in Brief Introduction there are macros that do the same thing as functions listed below (and both macro and function has the same name). As macros take Expr object as its argument, you can write codes in a slightly more simple manner with macros. For example,","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"always(:(\n    @posedge clk; \n\n    w1 <= w2;\n    if b1 == b2 \n        w3 <= w4\n    end\n))","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"is equivalent to ","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"@always (\n    @posedge clk; \n\n    w1 <= w2;\n    if b1 == b2 \n        w3 <= w4\n    end\n)","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"(be care full not to foreget (one space) between macros and (, i.e. @macro(a,b) and @macro (a,b) are different.)","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"But sometimes there are things what macros cannot do (for now), an example is having for loop inside expressions.","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"d = always(:(\n    if b1 \n        $([:($(Symbol(\"x$i\")) = $(Symbol(\"y$i\"))) for i in 1:3]...)\n    end\n))\nvshow(d)","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"and this outputs","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"always_comb begin\n    if (b1) begin\n        x1 = y1;\n        x2 = y2;\n        x3 = y3;\n    end\nend\ntype: Alwayscontent","category":"page"},{"location":"structs.html#List-of-Converter-Functions/Macros","page":"Basic Structs","title":"List of Converter Functions/Macros","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Written inside parentheses are the types of objects the functions return.","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"parameters (Parameters)\noneparam (Oneparam)\nports (Ports)\nportoneline (Oneport)\nwireexpr (Wireexpr)\nlocalparams (Localparams)\nonelocalparam (Onelocalparam)\ndecls (Decls)\ndecloneline (Onedecl)\nalways (Alwayscontent)\noneblock  (Ifelseblock,Alassign)\nifcontent","category":"page"},{"location":"structs.html#parameters","page":"Basic Structs","title":"parameters","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"parameters(expr::Expr)","category":"page"},{"location":"structs.html#VerilogWriter.parameters-Tuple{Expr}","page":"Basic Structs","title":"VerilogWriter.parameters","text":"parameters(expr::Expr)\n\nMultiple parameters.\n\nUsing convert and localparams inside.\n\nExample\n\nv = parameters(:(\n    x = 10;\n    y = 20;\n    z = 30\n))\nvshow(v)\n\n# output\n\n#(\n    parameter x = 10,\n    parameter y = 20,\n    parameter z = 30\n)\ntype: Parameters\n\n\n\n\n\n","category":"method"},{"location":"structs.html#oneparam","page":"Basic Structs","title":"oneparam","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"oneparam(expr::Expr)","category":"page"},{"location":"structs.html#VerilogWriter.oneparam-Tuple{Expr}","page":"Basic Structs","title":"VerilogWriter.oneparam","text":"oneparam(expr::Expr)\n\nOne parameter. \n\nSyntax\n\n<paramname> = <val::Int>\n\njulia> vshow(oneparam(:(x = 10)));\nparameter x = 10\ntype: Oneparam\n\n\n\n\n\n","category":"method"},{"location":"structs.html#ports","page":"Basic Structs","title":"ports","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"ports(::Expr)\nports(::Vector{Oneport})","category":"page"},{"location":"structs.html#VerilogWriter.ports-Tuple{Expr}","page":"Basic Structs","title":"VerilogWriter.ports","text":"ports(expr::Expr)\n\nConvert Julia AST into port declarations as Ports object.\n\nSyntax\n\n<portoneline>[;<portoneline>;...]\n\nMultiple lines of portoneline expressions  separated by ; can be accepted. \n\nExample\n\npp = ports(:(\n    @in p1;\n    @in @wire 8 p2, p3, p4;\n    @out @reg 2 p5, p6\n))\n\nvshow(pp)\n\n# output\n\n(\n    input p1,\n    input [7:0] p2,\n    input [7:0] p3,\n    input [7:0] p4,\n    output reg [1:0] p5,\n    output reg [1:0] p6\n);\ntype: Ports\n\n\n\n\n\n","category":"method"},{"location":"structs.html#VerilogWriter.ports-Tuple{Vector{Oneport}}","page":"Basic Structs","title":"VerilogWriter.ports","text":"ports(expr::Vector{Oneport})\n\nInsertion through metaprogramming.\n\nExample\n\na = @portoneline @in 8 d1, d2, d3\nb = ports(:(\n    @in d0;\n    $(a);\n    @out @reg 8 dout\n))\nvshow(b)\n\n# output\n\n(\n    input d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [7:0] d3,\n    output reg [7:0] dout\n);\ntype: Ports\n\n\n\n\n\n","category":"method"},{"location":"structs.html#portoneline","page":"Basic Structs","title":"portoneline","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"portoneline(::Expr)","category":"page"},{"location":"structs.html#VerilogWriter.portoneline-Tuple{Expr}","page":"Basic Structs","title":"VerilogWriter.portoneline","text":"portoneline(expr::Expr)\n\nParse Julia AST to one line of port declaration as Oneport.\n\nSyntax\n\n@in <wirename>, @out <wirename>\n\nOne port declaration of width 1.\n\n@in/@out <wirename1, wirename2, ...>\n\nMultiple port declaration of width 1 in one line.\n\n@in/@out <width> <wirename1[, wirename2, ...]>\n\nPort declarations of width <width>.\n\n@in/@out @<wiretype> [<width>] <wirename1[, wirename2, ...]>\n\nPort declaration with wiretypes [of width <width>].\n\nExamples\n\njulia> p1 = portoneline(:(@in din));\n\njulia> vshow(p1);\ninput din\ntype: Oneport\n\njulia> p2 = portoneline(:(@out din1, din2, din3)); vshow(p2);\noutput din1\ntype: Oneport\noutput din2\ntype: Oneport\noutput din3\ntype: Oneport\n\njulia> p3 = portoneline(:(@in 8 din)); vshow(p3);\ninput [7:0] din\ntype: Oneport\n\njulia> p4 = portoneline(:(@out @reg 8 dout)); vshow(p4);\noutput reg [7:0] dout\ntype: Oneport\n\njulia> p5 = portoneline(:(@out (A+B)<<2 x, y)); vshow(p5); # width with parameter\noutput [((A + B) << 2)-1:0] x\ntype: Oneport\noutput [((A + B) << 2)-1:0] y\ntype: Oneport\n\n\n\n\n\n","category":"method"},{"location":"structs.html#wireexpr","page":"Basic Structs","title":"wireexpr","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"wireexpr(::Expr)\nwireexpr(::Wireexpr)","category":"page"},{"location":"structs.html#VerilogWriter.wireexpr-Tuple{Expr}","page":"Basic Structs","title":"VerilogWriter.wireexpr","text":"wireexpr(expr::Expr)\n\nParse one wire expression. Be sure to put 'two e's' in wir'ee'xpr, not 'wirexpr'.\n\nSyntax\n\nPart of what can be done in Verilog can be accepted,  such as din[7:0], (w1 + w2) << 5\n\n<wirename>\n\nOne wire, without slicing or bit-selecting.\n\n<val::Int>, <val::hex>, <val::bin>\n\nLiterals, e.g. 5, 0x1f, 0b10.\n\n<wire> <op> <wire>, <op> <wire>\n\nUnary and binary operators.  For reduction operators (unary &, |, ^), since these are  not operators in Julia, write it in the form of function  call explicitly, i.e. &(wire), |(wire) instead of doing ^wire. Note that we use ^ as xor just as in Verilog, though this is not  a xor operator in Julia.\n\n<wire>[<wire>:<wire>], <wire>[<wire>]\n\nBit select and slicing as in Verilog/SystemVerilog. Does not reject even if both wires in [<wire>:<wire>] are not of constant value.\n\nwire[<wire>-:<wire>]\n\nIndexed part select. Does not reject even if <wire> after -: is not of constant value. As using - operator and : (quote) in Julia syntax,  no spaces between <wire>(here)-:(and here)<wire> are allowed,  and <wire> after -: should in most cases be put inside parentheses.\n\nNote that because : (quote) is used inside quote,  you (for now) cannot embed objects here through Metaprogramming.\n\ne.g. w = (@wireexpr w); oneblock(:(x[A-:($w)] <= y)) is not  allowed. \n\nIn such cases use constructors instead.\n\njulia> e = Wireexpr(ipselm, @wireexpr(x), @wireexpr(A), @wireexpr(w));\n\njulia> vshow(oneblock(:($(e) <= y)));\nx[A -: w] <= y;\ntype: Alassign\n\nExamples\n\njulia> w = wireexpr(:(w)); vshow(w);\nw\ntype: Wireexpr\n\njulia> w = wireexpr(:(w1 & &(w2) )); vshow(w);\n(w1 & &(w2))\ntype: Wireexpr\n\njulia> w = wireexpr(:(w[i:0])); vshow(w);\nw[i:0]\ntype: Wireexpr\n\njulia> w = @wireexpr w[(P*Q)-:(R+10)]; vshow(w);\nw[(P * Q) -: (R + 10)]\ntype: Wireexpr\n\n\n\n\n\n\n","category":"method"},{"location":"structs.html#VerilogWriter.wireexpr-Tuple{Wireexpr}","page":"Basic Structs","title":"VerilogWriter.wireexpr","text":"wireexpr(expr::Wireexpr)\n\nInsertion through metaprogramming.\n\nExample\n\njulia> w = @wireexpr x + y;\n\njulia> e = :(a + |($(w) & z));\n\njulia> ans = wireexpr(e); vshow(ans);\n(a + |(((x + y) & z)))\ntype: Wireexpr\n\n\n\n\n\n","category":"method"},{"location":"structs.html#localparams","page":"Basic Structs","title":"localparams","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"localparams(expr::Expr)","category":"page"},{"location":"structs.html#VerilogWriter.localparams-Tuple{Expr}","page":"Basic Structs","title":"VerilogWriter.localparams","text":"localparams(expr::Expr)\n\nMultiple localparams.\n\nExamples\n\njulia> p = localparams(:(x = 10)); vshow(p);\nlocalparam x = 10;\ntype: Localparams\n\np = localparams(:(\n    a = 111;\n    b = 222;\n    c = 333\n))\nvshow(p)\n\n# output\n\nlocalparam a = 111;\nlocalparam b = 222;\nlocalparam c = 333;\ntype: Localparams\n\n\n\n\n\n","category":"method"},{"location":"structs.html#onelocalparam","page":"Basic Structs","title":"onelocalparam","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"onelocalparam(expr::Expr)","category":"page"},{"location":"structs.html#VerilogWriter.onelocalparam-Tuple{Expr}","page":"Basic Structs","title":"VerilogWriter.onelocalparam","text":"onelocalparam(expr::Expr)\n\nOne localparam object. The syntax is the same as oneparam.\n\nExample\n\njulia> vshow(onelocalparam(:(x = 100)))\nlocalparam x = 100;\ntype: Onelocalparam\n\n\n\n\n\n","category":"method"},{"location":"structs.html#decls","page":"Basic Structs","title":"decls","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"decls(::Expr)\ndecls(::Vector{Onedecl})\ndecls(expr::Decls...)","category":"page"},{"location":"structs.html#VerilogWriter.decls-Tuple{Expr}","page":"Basic Structs","title":"VerilogWriter.decls","text":"decls(expr::Expr)\n\nParse Julia AST into wire declaration section object Decls.\n\nSyntax\n\n<onedecl>[;<onedecl>;...]\n\nMultiple decloneline expressions which are concatenated  by ; can be accepted.\n\nExample\n\nd = decls(:(\n    @wire w1;\n    @reg 8 w2,w3,w4;\n    @logic 32 w5\n))\nvshow(d)\n\n# output\n\nwire w1;\nreg [7:0] w2;\nreg [7:0] w3;\nreg [7:0] w4;\nlogic [31:0] w5;\ntype: Decls\n\n\n\n\n\n","category":"method"},{"location":"structs.html#VerilogWriter.decls-Tuple{Vector{Onedecl}}","page":"Basic Structs","title":"VerilogWriter.decls","text":"decls(expr::Vector{Onedecl})\n\nFor insertion with metaprogramming.\n\nExample\n\na = @decloneline @reg 8 x1, x2\nb = decls(:(\n    $(a);\n    @wire y1, y2\n))\nvshow(b)\n\n# output\n\nreg [7:0] x1;\nreg [7:0] x2;\nwire y1;\nwire y2;\ntype: Decls\n\n\n\n\n\n","category":"method"},{"location":"structs.html#VerilogWriter.decls-Tuple{Vararg{Decls}}","page":"Basic Structs","title":"VerilogWriter.decls","text":"decls(expr::Decls...)\n\nFor interpolation of Decls objects.\n\n\n\n\n\n","category":"method"},{"location":"structs.html#decloneline","page":"Basic Structs","title":"decloneline","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"decloneline(::Expr)","category":"page"},{"location":"structs.html#VerilogWriter.decloneline-Tuple{Expr}","page":"Basic Structs","title":"VerilogWriter.decloneline","text":"decloneline(expr::Expr)\n\nParse Julia AST into wire declaration as Vector{Onedecl}.\n\nThe number of Onedecl objects returned may differ  according to the number of wires declared in one line  (e.g. input dout <=> input din1, din2, din3).\n\nSyntax\n\nSimilar to that of portoneline.\n\n@wire/@reg/@logic [<width>] <wirename1>[, <wirename2>,...]\n\nExamples\n\njulia> d = decloneline(:(@reg 10 d1)); vshow(d);\nreg [9:0] d1;\ntype: Onedecl\n\njulia> d = decloneline(:(@logic 8 d1,d2,d3)); vshow(d);\nlogic [7:0] d1;\ntype: Onedecl\nlogic [7:0] d2;\ntype: Onedecl\nlogic [7:0] d3;\ntype: Onedecl\n\njulia> d = decloneline(:(@wire A >> 2 w1, w2)); vshow(d);\nwire [(A >> 2)-1:0] w1;\ntype: Onedecl\nwire [(A >> 2)-1:0] w2;\ntype: Onedecl\n\n\n\n\n\n","category":"method"},{"location":"structs.html#always","page":"Basic Structs","title":"always","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"always(::Expr)","category":"page"},{"location":"structs.html#VerilogWriter.always-Tuple{Expr}","page":"Basic Structs","title":"VerilogWriter.always","text":"always(expr::Expr)\n\nParse AST into always block as Alwayscontent using ralways.\n\nAlso infers type of always using addatype!.\n\nSyntax\n\n<oneblock>;<oneblock>[;<oneblock>;...]\n\n<oneblock> is the expression that can be parsed by oneblock. ; in between <oneblock>s are strictly needed.\n\n@posedge <wirename>; <ifelsestatements>/<assignments>\n\nSet sensitivity list using macro syntax. @negedge is also possible.  You must put @posegde/@negedge statement at the beginning, and only once.\n\nExamples\n\na1 = always(:(\n    w1 = w2;\n    if b2 \n        w1 = w3 \n    end\n))\nvshow(a1)\n\n# output\n\nalways_comb begin\n    w1 = w2;\n    if (b2) begin\n        w1 = w3;\n    end\nend\ntype: Alwayscontent\n\na1 = always(:(\n    @posedge clk;\n    \n    if b1 == b2\n        w1 <= w2 + w3 \n    else\n        w1 <= ~w1 \n    end\n))\nvshow(a1)\n\n# output\n\nalways_ff @( posedge clk ) begin\n    if ((b1 == b2)) begin\n        w1 <= (w2 + w3);\n    end else begin\n        w1 <= ~w1;\n    end\nend\ntype: Alwayscontent\n\n\n\n\n\n","category":"method"},{"location":"structs.html#oneblock","page":"Basic Structs","title":"oneblock","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"oneblock(::Expr)\noneblock(expr::T) where {T <: Union{Alassign, Ifelseblock}}","category":"page"},{"location":"structs.html#VerilogWriter.oneblock-Tuple{Expr}","page":"Basic Structs","title":"VerilogWriter.oneblock","text":"oneblock(expr::Expr)\n\nParse AST in Julia grammar to one if-else statement or  one assignment inside always blocks in Verilog,  which are Ifelseblock and Alassign, respectively. \n\nAs using Julia expression and Julia parser as if  it is of Verilog, there can be difference in grammatical matters  between what can be given as the expr and real Verilog  (e.g. operator precedence of <=).\n\nSyntax\n\n<wirename1> = <wireoperation>\n\nOne blocking assignment. (Note that bit width cannot be  specified yet, nor can it be printed.) <wireoperation> is a expression accepted by wireexpr.\n\nIf-else statement\n\nif <wireoperation>\n    <oneassignment>\n    <oneassignment>\n    ...\nelseif <wireoperation> \n    <oneassignment>\n    <ifelsestatement>\n    ...\nelse\n    <ifelsestatement>\n    ...\nend\n\nIf-else statement written in 'Julia syntax', not in Verilog  syntax, can be accepted. else block and elseif are not compulsory. Since if end are at the top level no ; inside if-else statement is needed. Nested if-else statement can be also accepted as in usual Julia.\n\nExamples\n\njulia> a1 = oneblock(:(w1 <= w2)); \n\njulia> vshow(a1);\nw1 <= w2;\ntype: Alassign\n\njulia> a2 = oneblock(:(w3 = w4 + ~w2)); vshow(a2);\nw3 = (w4 + ~w2);\ntype: Alassign\n\na3 = oneblock(:(\n    if b1 == b2\n        w5 = ~w6\n        w7 = w8 \n    elseif b2 \n        w9 = w9 + w10\n    else\n        if b3 \n            w11 = w12 \n        end\n    end\n))\nvshow(a3)\n\n# output\n\nif ((b1 == b2)) begin\n    w5 = ~w6;\n    w7 = w8;\nend else if (b2) begin\n    w9 = (w9 + w10);\nend else begin\n    if (b3) begin\n        w11 = w12;\n    end\nend\ntype: Ifelseblock\n\n\n\n\n\n","category":"method"},{"location":"structs.html#VerilogWriter.oneblock-Tuple{T} where T<:Union{Alassign, Ifelseblock}","page":"Basic Structs","title":"VerilogWriter.oneblock","text":"oneblock(expr::T) where {T <: Union{Alassign, Ifelseblock}}\n\nFor insertion through metaprogramming.\n\nExample\n\na = @oneblock r = s & t\nb = @oneblock (\n    if b \n        x = y \n    else\n        x = z\n    end\n)\nc = always(:(\n    p = q;\n    $(a);\n    $(b)\n))\nvshow(c)\n\n# output\n\nalways_comb begin\n    p = q;\n    r = (s & t);\n    if (b) begin\n        x = y;\n    end else begin\n        x = z;\n    end\nend\ntype: Alwayscontent\n\n\n\n\n\n","category":"method"},{"location":"structs.html#ifcontent","page":"Basic Structs","title":"ifcontent","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"ifcontent(x::Expr)","category":"page"},{"location":"structs.html#VerilogWriter.ifcontent-Tuple{Expr}","page":"Basic Structs","title":"VerilogWriter.ifcontent","text":"ifcontent(x::Expr)\n\nConvert into Ifcontent what is convertible to Alwayscontent.\n\nExample\n\nx = @ifcontent (\n    a = b;\n    if b \n        x = c\n    else\n        x = d \n    end\n)\nvshow(x)\n\n# output\n\na = b;\nif (b) begin\n    x = c;\nend else begin\n    x = d;\nend\ntype: Ifcontent\n\n\n\n\n\n","category":"method"},{"location":"structs.html#Embedding-Objects","page":"Basic Structs","title":"Embedding Objects","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"You can embed generated objects back into Verilog-like codes. Note that because we ask you to make use of metaprogramming (interpolation in particular), macros cannot be used for the purpose. ","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"By embedding objects as Julia AST, you can construct new objects that contain the information of embedded objects.","category":"page"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"Every object (offered in this package) can be embedded almost anywhere it seems to be possible.","category":"page"},{"location":"structs.html#Examples","page":"Basic Structs","title":"Examples","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"julia> a = @portoneline @in clk;\n\njulia> b = ports(:($(a); @out 8 dout)); vshow(b);\n(\n    input clk,\n    output [7:0] dout\n);\ntype: Ports\n\njulia> a = @ports (@in clk; @out 8 dout);\n\njulia> b = ports(:(@in resetn; $(a))); vshow(b);\n(\n    input resetn,\n    input clk,\n    output [7:0] dout\n);\ntype: Ports\n\njulia> a = @wireexpr (x + y) & z;\n\njulia> b = always(:(lhs = $(a) | w)); vshow(b);\nalways_comb begin\n    lhs = (((x + y) & z) | w);\nend\ntype: Alwayscontent","category":"page"},{"location":"structs.html#Other-Functions","page":"Basic Structs","title":"Other Functions","text":"","category":"section"},{"location":"structs.html#vshow","page":"Basic Structs","title":"vshow","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"vshow(::Any)","category":"page"},{"location":"structs.html#VerilogWriter.vshow-Tuple{Any}","page":"Basic Structs","title":"VerilogWriter.vshow","text":"vshow(x; systemverilog=true)\n\nPrint the structs in VerilogWriter.jl in a readable  format (except for enums). When systemverilog=false, output always, always @*  instead of always_ff, always_comb, respectively.\n\n\n\n\n\n","category":"method"},{"location":"structs.html#invports","page":"Basic Structs","title":"invports","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"invports","category":"page"},{"location":"structs.html#VerilogWriter.invports","page":"Basic Structs","title":"VerilogWriter.invports","text":"invports(ps::Ports)\n\nReturn Ports object whose directions are reversed from ps.\n\nExamples\n\npts = @ports (\n    @in 8 bus1, bus2;\n    @out @reg bus3\n)\nipts = invports(pts)\nvshow(pts)\nvshow(ipts)\n\n# output\n\n(\n    input [7:0] bus1,\n    input [7:0] bus2,\n    output reg bus3\n);\ntype: Ports\n(\n    output [7:0] bus1,\n    output [7:0] bus2,\n    input bus3\n);\ntype: Ports\n\n\n\n\n\n","category":"function"},{"location":"structs.html#declmerge","page":"Basic Structs","title":"declmerge","text":"","category":"section"},{"location":"structs.html","page":"Basic Structs","title":"Basic Structs","text":"declmerge","category":"page"},{"location":"structs.html#VerilogWriter.declmerge","page":"Basic Structs","title":"VerilogWriter.declmerge","text":"declmerge(d::Parameters...)\n\nMerge multiple Parameters objects into one Parameters.\n\n\n\n\n\ndeclmerge(d::Decls...)\n\nMerge multiple Decls objects into one Decls.\n\n\n\n\n\ndeclmerge(d::Localparams...)\n\nMerge multiple Localparams objects into one Localparams.\n\n\n\n\n\ndeclmerge(d::Ports...)\n\nMerge multiple Ports objects into one Ports.\n\n\n\n\n\n","category":"function"},{"location":"fsm.html#Finite-State-Machine","page":"Finite State Machines","title":"Finite State Machine","text":"","category":"section"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"We offer here an easy way to construct a Finite State Machine (FSM). ","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"Finite State Machine is a common structure used in a hardware design. Offering a simple method to construct a FSM may be useful.","category":"page"},{"location":"fsm.html#Procedure-of-Designing-a-FSM","page":"Finite State Machines","title":"Procedure of Designing a FSM","text":"","category":"section"},{"location":"fsm.html#Construct-a-FSM","page":"Finite State Machines","title":"Construct a FSM","text":"","category":"section"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"First construct a FSM defining name of states and the machine itself.","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"@FSM\nFSM(name, state::String...)\nFSM(name, states::Vector{String})","category":"page"},{"location":"fsm.html#VerilogWriter.@FSM","page":"Finite State Machines","title":"VerilogWriter.@FSM","text":"@FSM(mname, states)\n\nCreate FSM with variables of (machine itself / states) names.\n\nWith the macro there is no need to explicitly make a string object for  machine/state names.\n\nExample\n\njulia> m = @FSM m1 (s1, s2); # same as \"@FSM(m1, (s1, s2))\"\n\njulia> vshow(m)\nreg m1;\n\nlocalparam s1 = 0;\nlocalparam s2 = 1;\n\ncase (m1)\n    s1: begin\n        \n    end\n    s2: begin\n        \n    end\nendcase\ntype: FSM\n\n\n\n\n\n","category":"macro"},{"location":"fsm.html#VerilogWriter.FSM-Tuple{Any, Vararg{String}}","page":"Finite State Machines","title":"VerilogWriter.FSM","text":"FSM(name, state::String...)\n\nCreate an FSM object with name name, whose states are state....\n\n\n\n\n\n","category":"method"},{"location":"fsm.html#VerilogWriter.FSM-Tuple{Any, Vector{String}}","page":"Finite State Machines","title":"VerilogWriter.FSM","text":"FSM(name, states::Vector{String})\n\nCreate an FSM object with name name, whose states are states.\n\n\n\n\n\n","category":"method"},{"location":"fsm.html#Add-Transition-Rules","page":"Finite State Machines","title":"Add Transition Rules","text":"","category":"section"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"Add a new rule with transadd!.","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"transadd!","category":"page"},{"location":"fsm.html#VerilogWriter.transadd!","page":"Finite State Machines","title":"VerilogWriter.transadd!","text":"transadd!(x::FSM, cond::Wireexpr, newtrans::Pair{String, String})\n\nAdd a new transition rule for the state machine x.\n\nThe new rule here is:\n\nThe transition from state newtrans[1] to state newtrans[2]\nThis transition occures when cond is true and the current state is newtrans[1]\n\nExamples\n\njulia> fsm = @FSM nstate (uno, dos, tres); # create a FSM\n\njulia> transadd!(fsm, (@wireexpr b1 == b2), @tstate uno => dos); # transition from \"uno\" to \"dos\" when \"b1 == b2\"\n\njulia> vshow(fsmconv(Case, fsm));\ncase (nstate)\n    uno: begin\n        if ((b1 == b2)) begin\n            nstate <= dos;\n        end\n    end\n    dos: begin\n        \n    end\n    tres: begin\n        \n    end\nendcase\ntype: Case\n\n\n\n\n\n","category":"function"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"As shown above cond is the condition to be true when the transition occurs, and as newtrans argument you assign a Pair object of strings, \"srcstate\" => \"deststate\". You may instead call macro @tstate srcstate => deststate.","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"@tstate","category":"page"},{"location":"fsm.html#VerilogWriter.@tstate","page":"Finite State Machines","title":"VerilogWriter.@tstate","text":"@tstate(arg)\n\nHelper macro for argument in transadd!. \n\nConvert a pair of variables to a pair of strings.\n\njulia> @tstate a => b\n\"a\" => \"b\"\n\njulia> m = @FSM machine s1, s2;\n\njulia> transadd!(m, (@wireexpr b), @tstate s1 => s2);\n\njulia> vshow(m)\nreg machine;\n\nlocalparam s1 = 0;\nlocalparam s2 = 1;\n\ncase (machine)\n    s1: begin\n        if (b) begin\n            machine <= s2;\n        end\n    end\n    s2: begin\n        \n    end\nendcase\ntype: FSM\n\n\n\n\n\n","category":"macro"},{"location":"fsm.html#Generate-Condition-to-be-True-when-Transition-Occurs","page":"Finite State Machines","title":"Generate Condition to be True when Transition Occurs","text":"","category":"section"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"After adding transition rules you may generate wireexpr which would be true only when the transition occurs.","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"transcond","category":"page"},{"location":"fsm.html#VerilogWriter.transcond","page":"Finite State Machines","title":"VerilogWriter.transcond","text":"transcond(m::FSM, states::Pair{String, String})\n\nGet the wireexpr whose value should be true iff the state of  the FSM changes from states[1] to states[2].\n\nExamples\n\njulia> m = @FSM fsm s1, s2, s3; transadd!(m, (@wireexpr b1 == TCOND), @tstate s1=>s2); vshow(fsmconv(Case, m));\ncase (fsm)\n    s1: begin\n        if ((b1 == TCOND)) begin\n            fsm <= s2;\n        end\n    end\n    s2: begin\n        \n    end\n    s3: begin\n        \n    end\nendcase\ntype: Case\n\njulia> t = transcond(m, @tstate s1 => s2); vshow(t);\n((fsm == s1) && (b1 == TCOND))\ntype: Wireexpr\n\njulia> t = transcond(m, @tstate s2 => s1);\nERROR: transition rule not registered for \"s2\" => \"s1\".\n\n\n\n\n\n","category":"function"},{"location":"fsm.html#Convert-from-FSM-to-Verilog-Codes","page":"Finite State Machines","title":"Convert from FSM to Verilog Codes","text":"","category":"section"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"We offer methods to generate several components in verilog, which compose FSM structure.","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"They are ","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"A case statement for transition between states\nreg declaration that holds the current state information.\nlocalparams each of which represents one state in the FSM.","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"fsmconv","category":"page"},{"location":"fsm.html#VerilogWriter.fsmconv","page":"Finite State Machines","title":"VerilogWriter.fsmconv","text":"fsmconv(::Type{Case}, x::FSM)\n\nConvert FSM object into Case object.\n\n\n\n\n\nfsmconv(::Type{Case}, x::FSM, atype::Atype)\n\nAccept as an argument atype to be used in assignments inside  a case statement. Defaults to ff in the method fsmconv(::Type{Case}, x::FSM).\n\n\n\n\n\nfsmconv(::Type{Ifcontent}, x::FSM)\n\nConvert FSM logic to Ifcontent object.\n\nWhen vshow(fsmconv(Ifcontent, x)) is evaluated one  case block will be the only output.\n\n\n\n\n\nfsmconv(::Type{Onedecl}, x::FSM)\n\nGenerate one reg declaration in verilog that holds the state value at the time.\n\n\n\n\n\nfsmconv(::Type{Localparams}, x::FSM)\n\nGenerate localparams that declare the value which corresponds to each state.\n\n\n\n\n\n","category":"function"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"You may also prewiew all of these with vshow(x::FSM).","category":"page"},{"location":"fsm.html#Struct-FSM-Description","page":"Finite State Machines","title":"Struct FSM Description","text":"","category":"section"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"push!(LOAD_PATH,\"../../src/\")\nusing VerilogWriter","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"println(showfield(FSM)) # hide","category":"page"},{"location":"fsm.html","page":"Finite State Machines","title":"Finite State Machines","text":"FSM","category":"page"},{"location":"fsm.html#VerilogWriter.FSM","page":"Finite State Machines","title":"VerilogWriter.FSM","text":"Struct for a Finite State Machine, not the Flying Spaghetti Monster.\n\nEach column of matrices corresponds to the source state, and row for  the destination state. Not supposed to directly edit the content of matrices without using handlers.\n\n[\n    false false \n    true  false\n]\n\nin transvalid means transition from the 1st state to  the 2nd state is provided.\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference.html","page":"Reference","title":"Reference","text":"CurrentModule = VerilogWriter","category":"page"},{"location":"reference.html","page":"Reference","title":"Reference","text":"No detailed descriptions available yet.","category":"page"},{"location":"reference.html","page":"Reference","title":"Reference","text":"Still ?<function-name> on IJulia, Julia REPL will return docstrings for most of the functions, structs, and constant values in this module.","category":"page"},{"location":"index.html#What-You-Can-Do-with-VerilogWriter.jl","page":"Examples","title":"What You Can Do with VerilogWriter.jl","text":"","category":"section"},{"location":"index.html","page":"Examples","title":"Examples","text":"CurrentModule = VerilogWriter\nDocTestSetup = quote\n    using VerilogWriter\nend","category":"page"},{"location":"index.html#Convert-Verilog-like-Julia-Code-into-Objects","page":"Examples","title":"Convert Verilog-like Julia Code into Objects","text":"","category":"section"},{"location":"index.html","page":"Examples","title":"Examples","text":"julia> a = @portoneline @in x;\n\njulia> vshow(a);\ninput x\ntype: Oneport\n\njulia> b = @portoneline @out @reg 8 d1, d2;\n\njulia> vshow(b);\noutput reg [7:0] d1\ntype: Oneport\noutput reg [7:0] d2\ntype: Oneport","category":"page"},{"location":"index.html","page":"Examples","title":"Examples","text":"c = @always (\n    @posedge clk;\n    \n    d1 <= d2 + d3;\n    if b1 && b2\n        d4 <= d5 ^ d6 \n    else\n        d4 <= ~d4[7:0] \n    end\n)\nvshow(c)\n\n# output\n\nalways_ff @( posedge clk ) begin\n    d1 <= (d2 + d3);\n    if ((b1 && b2)) begin\n        d4 <= (d5 ^ d6);\n    end else begin\n        d4 <= ~d4[7:0];\n    end\nend\ntype: Alwayscontent","category":"page"},{"location":"index.html","page":"Examples","title":"Examples","text":"prs = @parameters splind = 5\n\nps = @ports (\n    @in clk, sig1, sig2;\n    @in 8 din, din2;\n    @out @reg 8 dout\n)\n\nds = @decls (\n    @reg 8 dbuf\n)\n\nproc = @always (\n    @posedge clk;\n\n    if sig2 && |(din2)\n        dbuf <= din \n    elseif sig1 ^ sig2\n        dout[7:splind] <= dbuf[7:splind]\n        dout[splind-1:0] <= din[splind-1:0]\n    else\n        dout <= ~din \n    end\n)\n\nmymod = Vmodule(\n    \"mymodule\",\n    prs,\n    ps,\n    ds,\n    Assign[],\n    [proc]\n)\n\nvshow(mymod, systemverilog=false)\n\n# output\n\nmodule mymodule #(\n    parameter splind = 5\n)(\n    input clk,\n    input sig1,\n    input sig2,\n    input [7:0] din,\n    input [7:0] din2,\n    output reg [7:0] dout\n);\n    reg [7:0] dbuf;\n\n    always @( posedge clk ) begin\n        if ((sig2 && |(din2))) begin\n            dbuf <= din;\n        end else if ((sig1 ^ sig2)) begin\n            dout[7:splind] <= dbuf[7:splind];\n            dout[(splind - 1):0] <= din[(splind - 1):0];\n        end else begin\n            dout <= ~din;\n        end\n    end\nendmodule\ntype: Vmodule","category":"page"},{"location":"index.html","page":"Examples","title":"Examples","text":"You may also create objects from constructors and apply some operations.","category":"page"},{"location":"index.html","page":"Examples","title":"Examples","text":"julia> c = Wireexpr(\"wire1\");\n\njulia> d = Wireexpr(\"wire2\");\n\njulia> e = @wireexpr wire3 << 5;\n\njulia> vshow((c & d) + e);\n((wire1 & wire2) + (wire3 << 5))\ntype: Wireexpr","category":"page"},{"location":"index.html#Embed-Generated-Objects-Back-into-Verilog-like-Codes","page":"Examples","title":"Embed Generated Objects Back into Verilog-like Codes","text":"","category":"section"},{"location":"index.html","page":"Examples","title":"Examples","text":"Using metaprogramming, you would do, for example, ","category":"page"},{"location":"index.html","page":"Examples","title":"Examples","text":"a = @always (\n    d1 = d2 + d3;\n    d4 = d4 & d5\n)\nb = always(:(\n    $(a);\n    if b1 == b2 \n        d6 = ~d7\n    end\n))\nvshow(b)\n\n# output\n\nalways_comb begin\n    d1 = (d2 + d3);\n    d4 = (d4 & d5);\n    if ((b1 == b2)) begin\n        d6 = ~d7;\n    end\nend\ntype: Alwayscontent","category":"page"},{"location":"index.html","page":"Examples","title":"Examples","text":"Note that you cannot use macros when embedding objects in Verilog-like codes.","category":"page"},{"location":"index.html","page":"Examples","title":"Examples","text":"One application of this syntax would be ","category":"page"},{"location":"index.html","page":"Examples","title":"Examples","text":"a = @ports (\n    @in 8 bus1, bus2;\n    @out 8 bus3\n)\nsend = Vmodule(\n    \"send\",\n    ports(:(\n        @in sendin;\n        $(a)\n    )),\n    Decls(),\n    Alwayscontent[]\n)\nrecv = Vmodule(\n    \"recv\",\n    ports(:(\n        @in recvin;\n        $(invports(a))\n    )),\n    Decls(),\n    Alwayscontent[]\n)\nvshow(send)\nprintln()\nvshow(recv)\n\n# output\n\nmodule send (\n    input sendin,\n    input [7:0] bus1,\n    input [7:0] bus2,\n    output [7:0] bus3\n);\n\nendmodule\ntype: Vmodule\n\nmodule recv (\n    input recvin,\n    output [7:0] bus1,\n    output [7:0] bus2,\n    input [7:0] bus3\n);\n\nendmodule\ntype: Vmodule","category":"page"},{"location":"index.html","page":"Examples","title":"Examples","text":"where you can construct Ports objects first and embed them in multiple modules.","category":"page"},{"location":"index.html#Wire-Width-Inference","page":"Examples","title":"Wire Width Inference","text":"","category":"section"},{"location":"index.html","page":"Examples","title":"Examples","text":"ds = @decls (\n    @wire dwire1;\n    @wire 10 dwire2\n)\n\nc = @ifcontent (\n    reg1 = 0;\n    reg2 = 0;\n    if dwire1\n        reg1 = dwire2[0] & dwire2[1]\n        reg2 = dwire2 + 1\n    end\n)\n\nenv = Vmodenv(\n    Parameters(),\n    Ports(),\n    Localparams(),\n    ds\n)","category":"page"},{"location":"index.html","page":"Examples","title":"Examples","text":"julia> autodecl(c); # fail in width inference with no additional information\nERROR: Wire width cannot be inferred for the following wires.\n1. dwire1\n2. reg2 = dwire2\n\njulia> d, _ = autodecl(c, env); vshow(d); # using information in `env`\nreg reg1;\nreg [9:0] reg2;\ntype: Decls","category":"page"},{"location":"index.html#Easy-construction-of-Finite-State-Machines","page":"Examples","title":"Easy construction of Finite State Machines","text":"","category":"section"},{"location":"index.html","page":"Examples","title":"Examples","text":"julia> fsm = @FSM nstate (uno, dos, tres); # create a new Finite State Machine\n\njulia> transadd!(fsm, (@wireexpr b1 == b2), @tstate uno => dos); # transition from \"uno\" to \"dos\"\n\njulia> transadd!(fsm, (@wireexpr b3), @tstate uno => tres); # \"uno\" to \"tres\"\n\njulia> transadd!(fsm, (@wireexpr b4), \"dos\" => \"uno\"); # \"dos\" to \"uno\"\n\njulia> vshow(fsm);\nreg [1:0] nstate;\n\nlocalparam uno = 0;\nlocalparam dos = 1;\nlocalparam tres = 2;\n\ncase (nstate)\n    uno: begin\n        if ((b1 == b2)) begin\n            nstate <= dos;\n        end else if (b3) begin\n            nstate <= tres;\n        end\n    end\n    dos: begin\n        if (b4) begin\n            nstate <= uno;\n        end\n    end\n    tres: begin\n        \n    end\nendcase\ntype: FSM","category":"page"},{"location":"index.html","page":"Examples","title":"Examples","text":"You may need to include the case statement inside an always block.","category":"page"},{"location":"inference.html#Basic-Automation","page":"Basic Automation","title":"Basic Automation","text":"","category":"section"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"CurrentModule = VerilogWriter\nDocTestSetup = quote\n    using VerilogWriter\nend","category":"page"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"using VerilogWriter","category":"page"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"We offer some tools to automatically add additional information inferred from a given Verilog-like codes.","category":"page"},{"location":"inference.html#Reset-in-Always-Blocks","page":"Basic Automation","title":"Reset in Always Blocks","text":"","category":"section"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"Given a content of always blocks, you may automatically reset all wires which appear at the LHS in the block.","category":"page"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"autoreset","category":"page"},{"location":"inference.html#VerilogWriter.autoreset","page":"Basic Automation","title":"VerilogWriter.autoreset","text":"autoreset(x::Ifcontent; clk=Wireexpr(\"CLK\"), rst=Wireexpr(\"RST\"), edge=posedge)\n\nGiven x::Ifcontent, returns always_ff/always block that  resets every wire/regs appear at Lhs of x.\n\nExample\n\nc = @ifcontent (\n    r1 <= r2;\n    if b1 \n        r2 <= 0\n        r3 <= r3 + r4\n    else \n        r3 <= 0\n    end\n) \nr = autoreset(c; clk=(@wireexpr clk), rst=(@wireexpr ~resetn))\nvshow(r)\n\n# output\n\nalways_ff @( posedge clk ) begin\n    if (~resetn) begin\n        r1 <= 0;\n        r2 <= 0;\n        r3 <= 0;\n    end else begin\n        r1 <= r2;\n        if (b1) begin\n            r2 <= 0;\n            r3 <= (r3 + r4);\n        end else begin\n            r3 <= 0;\n        end\n    end\nend\ntype: Alwayscontent\n\n\n\n\n\nautoreset(x::Alwayscontent; clk=defclk, rst=defrst, edge=posedge)\n\nAutomatically reset wires which appear in x::Alwayscontent.\n\nSensitivity list in the original Alwayscontent will be ignored.\n\n\n\n\n\n","category":"function"},{"location":"inference.html#Automatic-Wire-Declaration","page":"Basic Automation","title":"Automatic Wire Declaration","text":"","category":"section"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"autodecl","category":"page"},{"location":"inference.html#VerilogWriter.autodecl","page":"Basic Automation","title":"VerilogWriter.autodecl","text":"autodecl(x, env::Vmodenv)\n\nDeclare wires in x which are not yet declared in env. Raise error when not enough information to determine width of all wires is given.\n\nType of x is restricted to the type wireextract! accepts.\n\nExamples\n\nInference Success\n\npts = @ports (\n        @in 16 din;\n        @in b1\n)\nenv = Vmodenv(pts)\n\nc = @ifcontent (\n    reg1 = 0;\n    reg2 = din;\n    if b1 \n        reg1 = din[10:7]\n    end\n) \n\nnewds, _ = autodecl(c, env)\nvshow(newds)\n\n# output\n\nreg [3:0] reg1;\nreg [15:0] reg2;\ntype: Decls\n\nYou may also declare ports/wires beforehand whose width is unknown.\n\nWhen declaring ports/wires without specifying its bit width, assign -1 as its width.\n\nps = @ports (\n    @in 2 x;\n    @in -1 y;\n    @out @reg A z\n) \nds = @decls (\n    @wire -1 w1;\n    @wire B w2\n)\n\nab = @always (\n    z <= r1 + r2 + r3;\n    r4 <= (y & w1) << r1[1:0];\n    r5 <= y + w2\n)\nenv = Vmodenv(Parameters(), ps, Localparams(), ds)\nd, newenv = autodecl(ab.content, env)\n\nvshow(newenv)\nprintln()\nvshow(d)\n\n# output\n\ninput [1:0] x\ninput [B-1:0] y\noutput reg [A-1:0] z\n\nwire [B-1:0] w1;\nwire [B-1:0] w2;\ntype: Vmodenv\n\nreg [A-1:0] r1;\nreg [A-1:0] r2;\nreg [A-1:0] r3;\nreg [B-1:0] r4;\nreg [B-1:0] r5;\ntype: Decls\n\nFail in Inference\n\nc = @ifcontent (\n    reg1 = 0;\n    reg2 = din;\n    if b1 \n        reg1 = din[10:7]\n    end\n) \n\nautodecl(c)\n\n# output\n\nERROR: Wire width cannot be inferred for the following wires.\n1. b1\n2. reg2 = din\n\n\n\n\n\nautodecl(x)\n\nCall autodecl under an empty environment.\n\n\n\n\n\n","category":"function"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"env in an argument for autodecl is of type Vmodenv.","category":"page"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"println(showfield(Vmodenv)) # hide","category":"page"},{"location":"inference.html","page":"Basic Automation","title":"Basic Automation","text":"Vmodenv","category":"page"},{"location":"inference.html#VerilogWriter.Vmodenv","page":"Basic Automation","title":"VerilogWriter.Vmodenv","text":"Environment in which wire width inference is done.\n\n\n\n\n\n","category":"type"}]
}
