<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic Structs · VerilogWriter Document</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">VerilogWriter Document</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Examples</a></li><li><a class="tocitem" href="intro.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="structs.html">Basic Structs</a><ul class="internal"><li><a class="tocitem" href="#Structs-Description"><span>Structs Description</span></a></li><li><a class="tocitem" href="#Converter-Functions/Macros"><span>Converter Functions/Macros</span></a></li><li><a class="tocitem" href="#List-of-Converter-Functions/Macros"><span>List of Converter Functions/Macros</span></a></li><li><a class="tocitem" href="#Embedding-Objects"><span>Embedding Objects</span></a></li><li><a class="tocitem" href="#Other-Functions"><span>Other Functions</span></a></li></ul></li><li><a class="tocitem" href="inference.html">Basic Automation</a></li><li><a class="tocitem" href="fsm.html">Finite State Machines</a></li><li><a class="tocitem" href="reference.html">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="structs.html">Basic Structs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="structs.html">Basic Structs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/master/docs/src/structs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Component-Structs"><a class="docs-heading-anchor" href="#Component-Structs">Component Structs</a><a id="Component-Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Component-Structs" title="Permalink"></a></h1><h2 id="Structs-Description"><a class="docs-heading-anchor" href="#Structs-Description">Structs Description</a><a id="Structs-Description-1"></a><a class="docs-heading-anchor-permalink" href="#Structs-Description" title="Permalink"></a></h2><p>This module offers several structs that contain a structure of Verilog components, major ones of which are listed below. </p><ul><li><a href="structs.html#Parameters">Parameters</a><ul><li><a href="structs.html#Oneparam">Oneparam</a></li></ul></li><li><a href="structs.html#Ports">Ports</a><ul><li><a href="structs.html#Oneport">Oneport</a><ul><li><a href="structs.html#Portdirec">Portdirec</a></li><li><a href="structs.html#Wiretype">Wiretype</a></li></ul></li></ul></li><li><a href="structs.html#Localparams">Localparams</a><ul><li><a href="structs.html#Onelocalparam">Onelocalparam</a></li></ul></li><li><a href="structs.html#Wireexpr">Wireexpr</a><ul><li><a href="structs.html#Wireop">Wireop</a></li></ul></li><li><a href="structs.html#Decls">Decls</a><ul><li><a href="structs.html#Onedecl">Onedecl</a></li></ul></li><li><a href="structs.html#Assign">Assign</a></li><li><a href="structs.html#Alwayscontent">Alwayscontent</a><ul><li><a href="structs.html#Alassign">Alassign</a></li><li><a href="structs.html#Ifelseblock">Ifelseblock</a><ul><li><a href="structs.html#Ifcontent">Ifcontent</a></li></ul></li><li><a href="structs.html#Atype">Atype</a></li><li><a href="structs.html#Edge">Edge</a></li></ul></li><li><a href="structs.html#Vmodinst">Vmodinst</a></li><li><a href="structs.html#Vmodule">Vmodule</a></li></ul><h3 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Parameters(val::Vector{Oneparam})</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Parameters" href="#VerilogWriter.Parameters"><code>VerilogWriter.Parameters</code></a> — <span class="docstring-category">Type</span></header><section><div><p>List of parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L140">source</a></section></article><h4 id="Oneparam"><a class="docs-heading-anchor" href="#Oneparam">Oneparam</a><a id="Oneparam-1"></a><a class="docs-heading-anchor-permalink" href="#Oneparam" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Oneparam(name::String, val::Wireexpr)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Oneparam" href="#VerilogWriter.Oneparam"><code>VerilogWriter.Oneparam</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parameter in verilog.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L132-L134">source</a></section></article><h3 id="Ports"><a class="docs-heading-anchor" href="#Ports">Ports</a><a id="Ports-1"></a><a class="docs-heading-anchor-permalink" href="#Ports" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Ports(val::Vector{Oneport})</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Ports" href="#VerilogWriter.Ports"><code>VerilogWriter.Ports</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Gather multiple ports.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L183">source</a></section></article><h4 id="Oneport"><a class="docs-heading-anchor" href="#Oneport">Oneport</a><a id="Oneport-1"></a><a class="docs-heading-anchor-permalink" href="#Oneport" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Oneport(direc::Portdirec, decl::Onedecl)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Oneport" href="#VerilogWriter.Oneport"><code>VerilogWriter.Oneport</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represent a single port declaration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L174">source</a></section></article><h4 id="Portdirec"><a class="docs-heading-anchor" href="#Portdirec">Portdirec</a><a id="Portdirec-1"></a><a class="docs-heading-anchor-permalink" href="#Portdirec" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Enum pin pout</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Portdirec" href="#VerilogWriter.Portdirec"><code>VerilogWriter.Portdirec</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Port direction object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L145">source</a></section></article><h4 id="Wiretype"><a class="docs-heading-anchor" href="#Wiretype">Wiretype</a><a id="Wiretype-1"></a><a class="docs-heading-anchor-permalink" href="#Wiretype" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Enum wire reg logic</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wiretype" href="#VerilogWriter.Wiretype"><code>VerilogWriter.Wiretype</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wiretype object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L148">source</a></section></article><h3 id="Localparams"><a class="docs-heading-anchor" href="#Localparams">Localparams</a><a id="Localparams-1"></a><a class="docs-heading-anchor-permalink" href="#Localparams" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Localparams(val::Vector{Onelocalparam})</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Localparams" href="#VerilogWriter.Localparams"><code>VerilogWriter.Localparams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multiple localparams.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L157">source</a></section></article><h4 id="Onelocalparam"><a class="docs-heading-anchor" href="#Onelocalparam">Onelocalparam</a><a id="Onelocalparam-1"></a><a class="docs-heading-anchor-permalink" href="#Onelocalparam" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Onelocalparam(name::String, val::Wireexpr)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Onelocalparam" href="#VerilogWriter.Onelocalparam"><code>VerilogWriter.Onelocalparam</code></a> — <span class="docstring-category">Type</span></header><section><div><p>One localparam.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L151">source</a></section></article><h3 id="Wireexpr"><a class="docs-heading-anchor" href="#Wireexpr">Wireexpr</a><a id="Wireexpr-1"></a><a class="docs-heading-anchor-permalink" href="#Wireexpr" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Wireexpr(operation::Wireop, name::String, subnodes::Vector{Wireexpr}, bitwidth::Int64, value::Int64)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr" href="#VerilogWriter.Wireexpr"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wire expressions in verilog. </p><p>Contains unnecessary information to handle all the wires in the same type. </p><p>One motivation to avoid making different types of  wires (e.g. using parametric types) is that it seemed beneficial to have multiple wires in a vector, and that  it is sometime a disadvantage in performance to use  abstract types when creating vectors.</p><p>Some operators on wires in Verilog, which are listed in <code>Enum Wireop</code>,  are overloaded for <code>Wireexpr</code>. Note that reduction operators (unary <code>&amp;, |, ^</code>) are not in Julia,  and logical and, or (<code>&amp;&amp;, ||</code>) can be applied only for booleans in Julia, thus  are not available as an operator for <code>Wireexpr</code> objects.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w1 = @wireexpr x + y;

julia&gt; w2 = @wireexpr z;

julia&gt; vshow(w1 &amp; w2);
((x + y) &amp; z)
type: Wireexpr

julia&gt; w3 = @wireexpr x;

julia&gt; w4 = @wireexpr y &amp;&amp; z; # &amp;&amp; is available inside `@wireexpr` and `wireexpr` methods.

julia&gt; vshow(w3 | w4)
(x | (y &amp;&amp; z))
type: Wireexpr</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L79-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{String}" href="#VerilogWriter.Wireexpr-Tuple{String}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(n::String)</code></pre><p>Case where no slice is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vconstructors.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{Symbol}" href="#VerilogWriter.Wireexpr-Tuple{Symbol}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(n::Symbol)</code></pre><p>Convert Symbol to String and construct Wireexpr.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vconstructors.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{Int64}" href="#VerilogWriter.Wireexpr-Tuple{Int64}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(n::Int)</code></pre><p>Literal of Integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vconstructors.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{Wireop, Vararg{Wireexpr}}" href="#VerilogWriter.Wireexpr-Tuple{Wireop, Vararg{Wireexpr}}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(op::Wireop, w::Wireexpr...)</code></pre><p>Apply an operation of <code>w</code> wires.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = @wireexpr a; b = @wireexpr b;

julia&gt; c = Wireexpr(add, a, b); # equivalent to wireexpr(:($(a) + $(b)))

julia&gt; vshow(c);
(a + b)
type: Wireexpr

julia&gt; d = Wireexpr(redor, a); vshow(d); # wireexpr(:(|($(a))))
|(a)
type: Wireexpr</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vconstructors.jl#L96-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{Wireop, Vector{Wireexpr}}" href="#VerilogWriter.Wireexpr-Tuple{Wireop, Vector{Wireexpr}}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(op::Wireop, v::Vector{Wireexpr})</code></pre><p>Apply an operation on wires in <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vconstructors.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Union{Tuple{T}, Tuple{String, T}} where T&lt;:Union{Int64, Wireexpr}" href="#VerilogWriter.Wireexpr-Union{Tuple{T}, Tuple{String, T}} where T&lt;:Union{Int64, Wireexpr}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(n::String, msb::T) where {T &lt;: Union{Int, Wireexpr}}</code></pre><p>Get one bit at <code>msb</code> from <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vconstructors.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Union{Tuple{T2}, Tuple{T1}, Tuple{String, T1, T2}} where {T1&lt;:Union{Int64, Wireexpr}, T2&lt;:Union{Int64, Wireexpr}}" href="#VerilogWriter.Wireexpr-Union{Tuple{T2}, Tuple{T1}, Tuple{String, T1, T2}} where {T1&lt;:Union{Int64, Wireexpr}, T2&lt;:Union{Int64, Wireexpr}}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(n::String, msb::T1, lsb::T2) where {T1 &lt;: Union{Int, Wireexpr}, T2 &lt;: Union{Int, Wireexpr}}</code></pre><p>Slice of <code>n</code> from <code>msb</code> to <code>lsb</code>.</p><p>Index for wires can be Int or Wireexpr.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vconstructors.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{Int64, Int64}" href="#VerilogWriter.Wireexpr-Tuple{Int64, Int64}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(w::Int, n::Int)</code></pre><p>Literal with width specification, printed in the decimal format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vconstructors.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{Wireexpr}" href="#VerilogWriter.Wireexpr-Tuple{Wireexpr}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(expr::Wireexpr)</code></pre><p>Return the argument itself, used in slice construction to make it possible to apply the same method to msb as Int and as Wireexpr.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vconstructors.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{}" href="#VerilogWriter.Wireexpr-Tuple{}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr()</code></pre><p>Create an empty expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vconstructors.jl#L82-L86">source</a></section></article><h4 id="Wireop"><a class="docs-heading-anchor" href="#Wireop">Wireop</a><a id="Wireop-1"></a><a class="docs-heading-anchor-permalink" href="#Wireop" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Enum add minus mul vdiv lshift rshift band bor bxor neg uminus redand redor redxor logieq leq lt land lor id slice literal ipselm</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireop" href="#VerilogWriter.Wireop"><code>VerilogWriter.Wireop</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Verilog operators.</p><p>Unary <code>&amp;, |</code> does not exist so explicitly call as function e.g. <code>&amp;(wire), |(wire)</code> (&amp; behaves in a wickedmanner...?), and are only available inside quoted expressions. Xor in verilog <code>^</code> is in Julia exponential operator, and the difference in an association exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L1-L9">source</a></section></article><h3 id="Decls"><a class="docs-heading-anchor" href="#Decls">Decls</a><a id="Decls-1"></a><a class="docs-heading-anchor-permalink" href="#Decls" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Decls(val::Vector{Onedecl})</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Decls" href="#VerilogWriter.Decls"><code>VerilogWriter.Decls</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multiple wire declarations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L169">source</a></section></article><h4 id="Onedecl"><a class="docs-heading-anchor" href="#Onedecl">Onedecl</a><a id="Onedecl-1"></a><a class="docs-heading-anchor-permalink" href="#Onedecl" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Onedecl(wtype::Wiretype, width::Wireexpr, name::String)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Onedecl" href="#VerilogWriter.Onedecl"><code>VerilogWriter.Onedecl</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represent one wire declaration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L162">source</a></section></article><h3 id="Assign"><a class="docs-heading-anchor" href="#Assign">Assign</a><a id="Assign-1"></a><a class="docs-heading-anchor-permalink" href="#Assign" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Assign(lhs::Wireexpr, rhs::Wireexpr)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Assign" href="#VerilogWriter.Assign"><code>VerilogWriter.Assign</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Assign one statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L294">source</a></section></article><h3 id="Alwayscontent"><a class="docs-heading-anchor" href="#Alwayscontent">Alwayscontent</a><a id="Alwayscontent-1"></a><a class="docs-heading-anchor-permalink" href="#Alwayscontent" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Alwayscontent(atype::Atype, sens::Sensitivity, content::Ifcontent)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Alwayscontent" href="#VerilogWriter.Alwayscontent"><code>VerilogWriter.Alwayscontent</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represent always blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L285">source</a></section></article><h4 id="Alassign"><a class="docs-heading-anchor" href="#Alassign">Alassign</a><a id="Alassign-1"></a><a class="docs-heading-anchor-permalink" href="#Alassign" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Alassign(lhs::Wireexpr, rhs::Wireexpr, atype::Atype)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Alassign" href="#VerilogWriter.Alassign"><code>VerilogWriter.Alassign</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Assign statement inside always blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L193">source</a></section></article><h4 id="Ifelseblock"><a class="docs-heading-anchor" href="#Ifelseblock">Ifelseblock</a><a id="Ifelseblock-1"></a><a class="docs-heading-anchor-permalink" href="#Ifelseblock" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Ifelseblock(conds::Vector{Wireexpr}, contents::Vector{Ifcontent})</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Ifelseblock" href="#VerilogWriter.Ifelseblock"><code>VerilogWriter.Ifelseblock</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Container of an if-else block. Parametrized by <code>T</code> for mutual recursion. Used as <code>Ifelseblock = Ifelseblock_inner{Case}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L224-L227">source</a></section></article><h5 id="Ifcontent"><a class="docs-heading-anchor" href="#Ifcontent">Ifcontent</a><a id="Ifcontent-1"></a><a class="docs-heading-anchor-permalink" href="#Ifcontent" title="Permalink"></a></h5><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Ifcontent(assigns::Vector{Alassign}, ifelseblocks::Vector{Ifelseblock}, cases::Vector{Case})</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Ifcontent" href="#VerilogWriter.Ifcontent"><code>VerilogWriter.Ifcontent</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Container of one if-block (, one elseif block, or one else block).</p><p>Parametrized by <code>T, U</code> only for mutual recursion with <code>Ifelseblock</code> and <code>Case</code>, thus used as <code>Ifcontent_inner{Ifelseblock, Case}</code>, which is aliased as <code>Ifcontent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L200-L205">source</a></section></article><h4 id="Atype"><a class="docs-heading-anchor" href="#Atype">Atype</a><a id="Atype-1"></a><a class="docs-heading-anchor-permalink" href="#Atype" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Enum ff comb aunknown</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Atype" href="#VerilogWriter.Atype"><code>VerilogWriter.Atype</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type of always blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L188">source</a></section></article><h4 id="Edge"><a class="docs-heading-anchor" href="#Edge">Edge</a><a id="Edge-1"></a><a class="docs-heading-anchor-permalink" href="#Edge" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Enum posedge negedge unknownedge</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Edge" href="#VerilogWriter.Edge"><code>VerilogWriter.Edge</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Edge in sensitivity lists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L276">source</a></section></article><h3 id="Vmodinst"><a class="docs-heading-anchor" href="#Vmodinst">Vmodinst</a><a id="Vmodinst-1"></a><a class="docs-heading-anchor-permalink" href="#Vmodinst" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Vmodinst(vmodname::String, instname::String, params::Vector{Pair{String, Wireexpr}}, ports::Vector{Pair{String, Wireexpr}}, wildconn::Bool)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Vmodinst" href="#VerilogWriter.Vmodinst"><code>VerilogWriter.Vmodinst</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Vmodinst</code></pre><p>Represents module instantiation.</p><pre><code class="language-julia hljs">i = Vmodinst(
    &quot;mod1&quot;,
    &quot;u1&quot;,
    [
        &quot;A&quot; =&gt; Wireexpr(15)
    ],
    [
        &quot;p1&quot; =&gt; (@wireexpr x &lt;&lt; 1),
        &quot;p2&quot; =&gt; (@wireexpr y)
    ]
)
vshow(i)

# output

mod1 #(
    .A(15)
) u1 (
    .p1((x &lt;&lt; 1)),
    .p2(y)
);
type: Vmodinst</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L300-L329">source</a></section></article><h3 id="Vmodule"><a class="docs-heading-anchor" href="#Vmodule">Vmodule</a><a id="Vmodule-1"></a><a class="docs-heading-anchor-permalink" href="#Vmodule" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Vmodule(name::String, params::Parameters, ports::Ports, locparams::Localparams, decls::Decls, insts::Vector{Vmodinst}, assigns::Vector{Assign}, always::Vector{Alwayscontent})</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Vmodule" href="#VerilogWriter.Vmodule"><code>VerilogWriter.Vmodule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents one verilog module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructs.jl#L342">source</a></section></article><h2 id="Converter-Functions/Macros"><a class="docs-heading-anchor" href="#Converter-Functions/Macros">Converter Functions/Macros</a><a id="Converter-Functions/Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Converter-Functions/Macros" title="Permalink"></a></h2><p>As in previous examples we offer functions and macros to convert Julia syntax into certain structs described above. You may use these instead of calling constructors.</p><p>All the functions listed below accept <code>Expr</code> object as its argument (e.g. :(x = 10), see <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#Expressions-and-evaluation">Julia Documents</a> for more information.), and that is why variables inside the argument <code>Expr</code> object do not have to be declared anywhere else in the source code. The syntaxes each function requires in a argument <code>Expr</code> objects are also described below (or may be easily inferred from the examples here and <a href="intro.html#Brief-Introduction">Brief Introduction</a>).</p><p>As you see in <a href="intro.html#Brief-Introduction">Brief Introduction</a> there are macros that do the same thing as functions listed below (and both macro and function has the same name). As macros take <code>Expr</code> object as its argument, you can write codes in a slightly more simple manner with macros. For example,</p><pre><code class="nohighlight hljs">always(:(
    @posedge clk; 

    w1 &lt;= w2;
    if b1 == b2 
        w3 &lt;= w4
    end
))</code></pre><p>is equivalent to </p><pre><code class="nohighlight hljs">@always (
    @posedge clk; 

    w1 &lt;= w2;
    if b1 == b2 
        w3 &lt;= w4
    end
)</code></pre><p>(be care full not to foreget <code>(one space)</code> between macros and <code>(</code>, i.e. <code>@macro(a,b)</code> and <code>@macro (a,b)</code> are different.)</p><p>But sometimes there are things what macros cannot do (for now), an example is having <code>for</code> loop inside expressions.</p><pre><code class="language-Julia hljs">d = always(:(
    if b1 
        $([:($(Symbol(&quot;x$i&quot;)) = $(Symbol(&quot;y$i&quot;))) for i in 1:3]...)
    end
))
vshow(d)</code></pre><p>and this outputs</p><pre><code class="nohighlight hljs">always_comb begin
    if (b1) begin
        x1 = y1;
        x2 = y2;
        x3 = y3;
    end
end
type: Alwayscontent</code></pre><h2 id="List-of-Converter-Functions/Macros"><a class="docs-heading-anchor" href="#List-of-Converter-Functions/Macros">List of Converter Functions/Macros</a><a id="List-of-Converter-Functions/Macros-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-Converter-Functions/Macros" title="Permalink"></a></h2><p>Written inside parentheses are the types of objects the functions return.</p><ul><li><a href="structs.html#parameters">parameters</a> (<a href="structs.html#Parameters">Parameters</a>)<ul><li><a href="structs.html#oneparam">oneparam</a> (<a href="structs.html#Oneparam">Oneparam</a>)</li></ul></li><li><a href="structs.html#ports">ports</a> (<a href="structs.html#Ports">Ports</a>)<ul><li><a href="structs.html#portoneline">portoneline</a> (<a href="structs.html#Oneport">Oneport</a>)</li></ul></li><li><a href="structs.html#wireexpr">wireexpr</a> (<a href="structs.html#Wireexpr">Wireexpr</a>)</li><li><a href="structs.html#localparams">localparams</a> (<a href="structs.html#Localparams">Localparams</a>)<ul><li><a href="structs.html#onelocalparam">onelocalparam</a> (<a href="structs.html#Onelocalparam">Onelocalparam</a>)</li></ul></li><li><a href="structs.html#decls">decls</a> (<a href="structs.html#Decls">Decls</a>)<ul><li><a href="structs.html#decloneline">decloneline</a> (<a href="structs.html#Onedecl">Onedecl</a>)</li></ul></li><li><a href="structs.html#always">always</a> (<a href="structs.html#Alwayscontent">Alwayscontent</a>)<ul><li><a href="structs.html#oneblock">oneblock</a>  (<a href="structs.html#Ifelseblock">Ifelseblock</a>,<a href="structs.html#Alassign">Alassign</a>)<ul><li><a href="structs.html#ifcontent">ifcontent</a></li></ul></li></ul></li></ul><h3 id="parameters"><a class="docs-heading-anchor" href="#parameters">parameters</a><a id="parameters-1"></a><a class="docs-heading-anchor-permalink" href="#parameters" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.parameters-Tuple{Expr}" href="#VerilogWriter.parameters-Tuple{Expr}"><code>VerilogWriter.parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameters(expr::Expr)</code></pre><p>Multiple parameters.</p><p>Using <code>convert</code> and <code>localparams</code> inside.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">v = parameters(:(
    x = 10;
    y = 20;
    z = 30
))
vshow(v)

# output

#(
    parameter x = 10,
    parameter y = 20,
    parameter z = 30
)
type: Parameters</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L48-L73">source</a></section></article><h4 id="oneparam"><a class="docs-heading-anchor" href="#oneparam">oneparam</a><a id="oneparam-1"></a><a class="docs-heading-anchor-permalink" href="#oneparam" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneparam-Tuple{Expr}" href="#VerilogWriter.oneparam-Tuple{Expr}"><code>VerilogWriter.oneparam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneparam(expr::Expr)</code></pre><p>One parameter. </p><p><strong>Syntax</strong></p><p><strong><code>&lt;paramname&gt; = &lt;val::Int&gt;</code></strong></p><pre><code class="language-julia-repl hljs">julia&gt; vshow(oneparam(:(x = 10)));
parameter x = 10
type: Oneparam</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L10-L23">source</a></section></article><h3 id="ports"><a class="docs-heading-anchor" href="#ports">ports</a><a id="ports-1"></a><a class="docs-heading-anchor-permalink" href="#ports" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ports-Tuple{Expr}" href="#VerilogWriter.ports-Tuple{Expr}"><code>VerilogWriter.ports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ports(expr::Expr)</code></pre><p>Convert Julia AST into port declarations as <a href="structs.html#Ports">Ports</a> object.</p><p><strong>Syntax</strong></p><p><strong><code>&lt;portoneline&gt;[;&lt;portoneline&gt;;...]</code></strong></p><p>Multiple lines of <a href="structs.html#VerilogWriter.portoneline-Tuple{Expr}"><code>portoneline</code></a> expressions  separated by <code>;</code> can be accepted. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs">pp = ports(:(
    @in p1;
    @in @wire 8 p2, p3, p4;
    @out @reg 2 p5, p6
))

vshow(pp)

# output

(
    input p1,
    input [7:0] p2,
    input [7:0] p3,
    input [7:0] p4,
    output reg [1:0] p5,
    output reg [1:0] p6
);
type: Ports</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L1133-L1165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ports-Tuple{Vector{Oneport}}" href="#VerilogWriter.ports-Tuple{Vector{Oneport}}"><code>VerilogWriter.ports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ports(expr::Vector{Oneport})</code></pre><p>Insertion through metaprogramming.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">a = @portoneline @in 8 d1, d2, d3
b = ports(:(
    @in d0;
    $(a);
    @out @reg 8 dout
))
vshow(b)

# output

(
    input d0,
    input [7:0] d1,
    input [7:0] d2,
    input [7:0] d3,
    output reg [7:0] dout
);
type: Ports</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L1170-L1195">source</a></section></article><h4 id="portoneline"><a class="docs-heading-anchor" href="#portoneline">portoneline</a><a id="portoneline-1"></a><a class="docs-heading-anchor-permalink" href="#portoneline" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.portoneline-Tuple{Expr}" href="#VerilogWriter.portoneline-Tuple{Expr}"><code>VerilogWriter.portoneline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">portoneline(expr::Expr)</code></pre><p>Parse Julia AST to one line of port declaration as <a href="structs.html#Oneport">Oneport</a>.</p><p><strong>Syntax</strong></p><p><strong><code>@in &lt;wirename&gt;</code>, <code>@out &lt;wirename&gt;</code></strong></p><p>One port declaration of width 1.</p><p><strong><code>@in/@out &lt;wirename1, wirename2, ...&gt;</code></strong></p><p>Multiple port declaration of width 1 in one line.</p><p><strong><code>@in/@out &lt;width&gt; &lt;wirename1[, wirename2, ...]&gt;</code></strong></p><p>Port declarations of width <code>&lt;width&gt;</code>.</p><p><strong><code>@in/@out @&lt;wiretype&gt; [&lt;width&gt;] &lt;wirename1[, wirename2, ...]&gt;</code></strong></p><p>Port declaration with wiretypes [of width <code>&lt;width&gt;</code>].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p1 = portoneline(:(@in din));

julia&gt; vshow(p1);
input din
type: Oneport

julia&gt; p2 = portoneline(:(@out din1, din2, din3)); vshow(p2);
output din1
type: Oneport
output din2
type: Oneport
output din3
type: Oneport

julia&gt; p3 = portoneline(:(@in 8 din)); vshow(p3);
input [7:0] din
type: Oneport

julia&gt; p4 = portoneline(:(@out @reg 8 dout)); vshow(p4);
output reg [7:0] dout
type: Oneport

julia&gt; p5 = portoneline(:(@out (A+B)&lt;&lt;2 x, y)); vshow(p5); # width with parameter
output [((A + B) &lt;&lt; 2)-1:0] x
type: Oneport
output [((A + B) &lt;&lt; 2)-1:0] y
type: Oneport</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L1019-L1067">source</a></section></article><h3 id="wireexpr"><a class="docs-heading-anchor" href="#wireexpr">wireexpr</a><a id="wireexpr-1"></a><a class="docs-heading-anchor-permalink" href="#wireexpr" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireexpr-Tuple{Expr}" href="#VerilogWriter.wireexpr-Tuple{Expr}"><code>VerilogWriter.wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireexpr(expr::Expr)</code></pre><p>Parse one wire expression. Be sure to put &#39;two e&#39;s&#39; in wir&#39;ee&#39;xpr, not &#39;wirexpr&#39;.</p><p><strong>Syntax</strong></p><p>Part of what can be done in Verilog can be accepted,  such as <code>din[7:0]</code>, <code>(w1 + w2) &lt;&lt; 5</code></p><p><strong><code>&lt;wirename&gt;</code></strong></p><p>One wire, without slicing or bit-selecting.</p><p><strong><code>&lt;val::Int&gt;</code>, <code>&lt;val::hex&gt;</code>, <code>&lt;val::bin&gt;</code></strong></p><p>Literals, e.g. <code>5</code>, <code>0x1f</code>, <code>0b10</code>.</p><p><strong><code>&lt;wire&gt; &lt;op&gt; &lt;wire&gt;</code>, <code>&lt;op&gt; &lt;wire&gt;</code></strong></p><p>Unary and binary operators.  For reduction operators (unary <code>&amp;, |, ^</code>), since these are  not operators in Julia, write it in the form of function  call explicitly, i.e. <code>&amp;(wire)</code>, <code>|(wire)</code> instead of doing <code>^wire</code>. Note that we use <code>^</code> as xor just as in Verilog, though this is not  a xor operator in Julia.</p><p><strong><code>&lt;wire&gt;[&lt;wire&gt;:&lt;wire&gt;]</code>, <code>&lt;wire&gt;[&lt;wire&gt;]</code></strong></p><p>Bit select and slicing as in Verilog/SystemVerilog. Does not reject even if both wires in <code>[&lt;wire&gt;:&lt;wire&gt;]</code> are not of constant value.</p><p><strong><code>wire[&lt;wire&gt;-:&lt;wire&gt;]</code></strong></p><p>Indexed part select. Does not reject even if <code>&lt;wire&gt;</code> after <code>-:</code> is not of constant value. As using <code>-</code> operator and <code>:</code> (quote) in Julia syntax,  no spaces between <code>&lt;wire&gt;(here)-:(and here)&lt;wire&gt;</code> are allowed,  and <code>&lt;wire&gt;</code> after <code>-:</code> should in most cases be put inside parentheses.</p><p>Note that because <code>:</code> (quote) is used inside quote,  you (for now) cannot embed objects here through Metaprogramming.</p><p>e.g. <code>w = (@wireexpr w); oneblock(:(x[A-:($w)] &lt;= y))</code> is not  allowed. </p><p>In such cases use constructors instead.</p><pre><code class="language-julia-repl hljs">julia&gt; e = Wireexpr(ipselm, @wireexpr(x), @wireexpr(A), @wireexpr(w));

julia&gt; vshow(oneblock(:($(e) &lt;= y)));
x[A -: w] &lt;= y;
type: Alassign</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = wireexpr(:(w)); vshow(w);
w
type: Wireexpr

julia&gt; w = wireexpr(:(w1 &amp; &amp;(w2) )); vshow(w);
(w1 &amp; &amp;(w2))
type: Wireexpr

julia&gt; w = wireexpr(:(w[i:0])); vshow(w);
w[i:0]
type: Wireexpr

julia&gt; w = @wireexpr w[(P*Q)-:(R+10)]; vshow(w);
w[(P * Q) -: (R + 10)]
type: Wireexpr
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L646-L717">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireexpr-Tuple{Wireexpr}" href="#VerilogWriter.wireexpr-Tuple{Wireexpr}"><code>VerilogWriter.wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireexpr(expr::Wireexpr)</code></pre><p>Insertion through metaprogramming.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = @wireexpr x + y;

julia&gt; e = :(a + |($(w) &amp; z));

julia&gt; ans = wireexpr(e); vshow(ans);
(a + |(((x + y) &amp; z)))
type: Wireexpr</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L722-L736">source</a></section></article><h3 id="localparams"><a class="docs-heading-anchor" href="#localparams">localparams</a><a id="localparams-1"></a><a class="docs-heading-anchor-permalink" href="#localparams" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.localparams-Tuple{Expr}" href="#VerilogWriter.localparams-Tuple{Expr}"><code>VerilogWriter.localparams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localparams(expr::Expr)</code></pre><p>Multiple localparams.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = localparams(:(x = 10)); vshow(p);
localparam x = 10;
type: Localparams</code></pre><pre><code class="language-julia hljs">p = localparams(:(
    a = 111;
    b = 222;
    c = 333
))
vshow(p)

# output

localparam a = 111;
localparam b = 222;
localparam c = 333;
type: Localparams</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L132-L157">source</a></section></article><h4 id="onelocalparam"><a class="docs-heading-anchor" href="#onelocalparam">onelocalparam</a><a id="onelocalparam-1"></a><a class="docs-heading-anchor-permalink" href="#onelocalparam" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.onelocalparam-Tuple{Expr}" href="#VerilogWriter.onelocalparam-Tuple{Expr}"><code>VerilogWriter.onelocalparam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">onelocalparam(expr::Expr)</code></pre><p>One localparam object. The syntax is the same as <code>oneparam</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vshow(onelocalparam(:(x = 100)))
localparam x = 100;
type: Onelocalparam</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L97-L107">source</a></section></article><h3 id="decls"><a class="docs-heading-anchor" href="#decls">decls</a><a id="decls-1"></a><a class="docs-heading-anchor-permalink" href="#decls" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decls-Tuple{Expr}" href="#VerilogWriter.decls-Tuple{Expr}"><code>VerilogWriter.decls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decls(expr::Expr)</code></pre><p>Parse Julia AST into wire declaration section object <a href="structs.html#Decls">Decls</a>.</p><p><strong>Syntax</strong></p><p><strong><code>&lt;onedecl&gt;[;&lt;onedecl&gt;;...]</code></strong></p><p>Multiple <a href="structs.html#decloneline">decloneline</a> expressions which are concatenated  by <code>;</code> can be accepted.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">d = decls(:(
    @wire w1;
    @reg 8 w2,w3,w4;
    @logic 32 w5
))
vshow(d)

# output

wire w1;
reg [7:0] w2;
reg [7:0] w3;
reg [7:0] w4;
logic [31:0] w5;
type: Decls</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L1373-L1401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decls-Tuple{Vector{Onedecl}}" href="#VerilogWriter.decls-Tuple{Vector{Onedecl}}"><code>VerilogWriter.decls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decls(expr::Vector{Onedecl})</code></pre><p>For insertion with metaprogramming.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">a = @decloneline @reg 8 x1, x2
b = decls(:(
    $(a);
    @wire y1, y2
))
vshow(b)

# output

reg [7:0] x1;
reg [7:0] x2;
wire y1;
wire y2;
type: Decls</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L1424-L1445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decls-Tuple{Vararg{Decls}}" href="#VerilogWriter.decls-Tuple{Vararg{Decls}}"><code>VerilogWriter.decls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decls(expr::Decls...)</code></pre><p>For interpolation of <code>Decls</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L1415-L1419">source</a></section></article><h4 id="decloneline"><a class="docs-heading-anchor" href="#decloneline">decloneline</a><a id="decloneline-1"></a><a class="docs-heading-anchor-permalink" href="#decloneline" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decloneline-Tuple{Expr}" href="#VerilogWriter.decloneline-Tuple{Expr}"><code>VerilogWriter.decloneline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decloneline(expr::Expr)</code></pre><p>Parse Julia AST into wire declaration as Vector{<a href="structs.html#Onedecl">Onedecl</a>}.</p><p>The number of <code>Onedecl</code> objects returned may differ  according to the number of wires declared in one line  (e.g. <code>input dout</code> &lt;=&gt; <code>input din1, din2, din3</code>).</p><p><strong>Syntax</strong></p><p>Similar to that of <a href="structs.html#portoneline">portoneline</a>.</p><p><strong><code>@wire/@reg/@logic [&lt;width&gt;] &lt;wirename1&gt;[, &lt;wirename2&gt;,...]</code></strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = decloneline(:(@reg 10 d1)); vshow(d);
reg [9:0] d1;
type: Onedecl

julia&gt; d = decloneline(:(@logic 8 d1,d2,d3)); vshow(d);
logic [7:0] d1;
type: Onedecl
logic [7:0] d2;
type: Onedecl
logic [7:0] d3;
type: Onedecl

julia&gt; d = decloneline(:(@wire A &gt;&gt; 2 w1, w2)); vshow(d);
wire [(A &gt;&gt; 2)-1:0] w1;
type: Onedecl
wire [(A &gt;&gt; 2)-1:0] w2;
type: Onedecl</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L1268-L1301">source</a></section></article><h3 id="always"><a class="docs-heading-anchor" href="#always">always</a><a id="always-1"></a><a class="docs-heading-anchor-permalink" href="#always" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.always-Tuple{Expr}" href="#VerilogWriter.always-Tuple{Expr}"><code>VerilogWriter.always</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">always(expr::Expr)</code></pre><p>Parse AST into always block as <a href="structs.html#Alwayscontent">Alwayscontent</a> using <code>ralways</code>.</p><p>Also infers type of always using <code>addatype!</code>.</p><p><strong>Syntax</strong></p><p><strong><code>&lt;oneblock&gt;;&lt;oneblock&gt;[;&lt;oneblock&gt;;...]</code></strong></p><p><code>&lt;oneblock&gt;</code> is the expression that can be parsed by <a href="structs.html#oneblock">oneblock</a>. <code>;</code> in between <code>&lt;oneblock&gt;</code>s are strictly needed.</p><p><strong><code>@posedge &lt;wirename&gt;; &lt;ifelsestatements&gt;/&lt;assignments&gt;</code></strong></p><p>Set sensitivity list using macro syntax. <code>@negedge</code> is also possible.  You must put <code>@posegde/@negedge</code> statement at the beginning, and only once.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">a1 = always(:(
    w1 = w2;
    if b2 
        w1 = w3 
    end
))
vshow(a1)

# output

always_comb begin
    w1 = w2;
    if (b2) begin
        w1 = w3;
    end
end
type: Alwayscontent</code></pre><pre><code class="language-julia hljs">a1 = always(:(
    @posedge clk;
    
    if b1 == b2
        w1 &lt;= w2 + w3 
    else
        w1 &lt;= ~w1 
    end
))
vshow(a1)

# output

always_ff @( posedge clk ) begin
    if ((b1 == b2)) begin
        w1 &lt;= (w2 + w3);
    end else begin
        w1 &lt;= ~w1;
    end
end
type: Alwayscontent</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructhandlers.jl#L25-L86">source</a></section></article><h4 id="oneblock"><a class="docs-heading-anchor" href="#oneblock">oneblock</a><a id="oneblock-1"></a><a class="docs-heading-anchor-permalink" href="#oneblock" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneblock-Tuple{Expr}" href="#VerilogWriter.oneblock-Tuple{Expr}"><code>VerilogWriter.oneblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneblock(expr::Expr)</code></pre><p>Parse AST in Julia grammar to one if-else statement or  one assignment inside always blocks in Verilog,  which are <a href="structs.html#Ifelseblock">Ifelseblock</a> and <a href="structs.html#Alassign">Alassign</a>, respectively. </p><p>As using Julia expression and Julia parser as if  it is of Verilog, there can be difference in grammatical matters  between what can be given as the <code>expr</code> and real Verilog  (e.g. operator precedence of <code>&lt;=</code>).</p><p><strong>Syntax</strong></p><p><strong><code>&lt;wirename1&gt; = &lt;wireoperation&gt;</code></strong></p><p>One blocking assignment. (Note that bit width cannot be  specified yet, nor can it be printed.) <code>&lt;wireoperation&gt;</code> is a expression accepted by <a href="structs.html#wireexpr">wireexpr</a>.</p><p><strong>If-else statement</strong></p><pre><code class="nohighlight hljs">if &lt;wireoperation&gt;
    &lt;oneassignment&gt;
    &lt;oneassignment&gt;
    ...
elseif &lt;wireoperation&gt; 
    &lt;oneassignment&gt;
    &lt;ifelsestatement&gt;
    ...
else
    &lt;ifelsestatement&gt;
    ...
end</code></pre><p>If-else statement written in &#39;Julia syntax&#39;, not in Verilog  syntax, can be accepted. <code>else</code> block and <code>elseif</code> are not compulsory. Since <code>if</code> <code>end</code> are at the top level no <code>;</code> inside if-else statement is needed. Nested if-else statement can be also accepted as in usual Julia.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a1 = oneblock(:(w1 &lt;= w2)); 

julia&gt; vshow(a1);
w1 &lt;= w2;
type: Alassign

julia&gt; a2 = oneblock(:(w3 = w4 + ~w2)); vshow(a2);
w3 = (w4 + ~w2);
type: Alassign</code></pre><pre><code class="language-julia hljs">a3 = oneblock(:(
    if b1 == b2
        w5 = ~w6
        w7 = w8 
    elseif b2 
        w9 = w9 + w10
    else
        if b3 
            w11 = w12 
        end
    end
))
vshow(a3)

# output

if ((b1 == b2)) begin
    w5 = ~w6;
    w7 = w8;
end else if (b2) begin
    w9 = (w9 + w10);
end else begin
    if (b3) begin
        w11 = w12;
    end
end
type: Ifelseblock</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L221-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneblock-Tuple{T} where T&lt;:Union{Alassign, Ifelseblock}" href="#VerilogWriter.oneblock-Tuple{T} where T&lt;:Union{Alassign, Ifelseblock}"><code>VerilogWriter.oneblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneblock(expr::T) where {T &lt;: Union{Alassign, Ifelseblock}}</code></pre><p>For insertion through metaprogramming.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">a = @oneblock r = s &amp; t
b = @oneblock (
    if b 
        x = y 
    else
        x = z
    end
)
c = always(:(
    p = q;
    $(a);
    $(b)
))
vshow(c)

# output

always_comb begin
    p = q;
    r = (s &amp; t);
    if (b) begin
        x = y;
    end else begin
        x = z;
    end
end
type: Alwayscontent</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L305-L339">source</a></section></article><h4 id="ifcontent"><a class="docs-heading-anchor" href="#ifcontent">ifcontent</a><a id="ifcontent-1"></a><a class="docs-heading-anchor-permalink" href="#ifcontent" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ifcontent-Tuple{Expr}" href="#VerilogWriter.ifcontent-Tuple{Expr}"><code>VerilogWriter.ifcontent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ifcontent(x::Expr)</code></pre><p>Convert into <code>Ifcontent</code> what is convertible to <code>Alwayscontent</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">x = @ifcontent (
    a = b;
    if b 
        x = c
    else
        x = d 
    end
)
vshow(x)

# output

a = b;
if (b) begin
    x = c;
end else begin
    x = d;
end
type: Ifcontent</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/rawparser.jl#L966-L993">source</a></section></article><h2 id="Embedding-Objects"><a class="docs-heading-anchor" href="#Embedding-Objects">Embedding Objects</a><a id="Embedding-Objects-1"></a><a class="docs-heading-anchor-permalink" href="#Embedding-Objects" title="Permalink"></a></h2><p>You can embed generated objects back into Verilog-like codes. Note that because we ask you to make use of metaprogramming (<a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#man-expression-interpolation"><code>interpolation</code></a> in particular), macros cannot be used for the purpose. </p><p>By embedding objects as Julia AST, you can construct new objects that contain the information of embedded objects.</p><p>Every object (offered in this package) can be embedded almost anywhere it seems to be possible.</p><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; a = @portoneline @in clk;

julia&gt; b = ports(:($(a); @out 8 dout)); vshow(b);
(
    input clk,
    output [7:0] dout
);
type: Ports

julia&gt; a = @ports (@in clk; @out 8 dout);

julia&gt; b = ports(:(@in resetn; $(a))); vshow(b);
(
    input resetn,
    input clk,
    output [7:0] dout
);
type: Ports

julia&gt; a = @wireexpr (x + y) &amp; z;

julia&gt; b = always(:(lhs = $(a) | w)); vshow(b);
always_comb begin
    lhs = (((x + y) &amp; z) | w);
end
type: Alwayscontent</code></pre><h2 id="Other-Functions"><a class="docs-heading-anchor" href="#Other-Functions">Other Functions</a><a id="Other-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Functions" title="Permalink"></a></h2><h3 id="vshow"><a class="docs-heading-anchor" href="#vshow">vshow</a><a id="vshow-1"></a><a class="docs-heading-anchor-permalink" href="#vshow" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.vshow-Tuple{Any}" href="#VerilogWriter.vshow-Tuple{Any}"><code>VerilogWriter.vshow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vshow(x; systemverilog=true)</code></pre><p>Print the structs in <code>VerilogWriter.jl</code> in a readable  format (except for enums). When <code>systemverilog=false</code>, output <code>always</code>, <code>always @*</code>  instead of <code>always_ff</code>, <code>always_comb</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/textutils.jl#L24-L31">source</a></section></article><h3 id="invports"><a class="docs-heading-anchor" href="#invports">invports</a><a id="invports-1"></a><a class="docs-heading-anchor-permalink" href="#invports" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.invports" href="#VerilogWriter.invports"><code>VerilogWriter.invports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">invports(ps::Ports)</code></pre><p>Return <a href="structs.html#Ports">Ports</a> object whose directions are reversed from <code>ps</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">pts = @ports (
    @in 8 bus1, bus2;
    @out @reg bus3
)
ipts = invports(pts)
vshow(pts)
vshow(ipts)

# output

(
    input [7:0] bus1,
    input [7:0] bus2,
    output reg bus3
);
type: Ports
(
    output [7:0] bus1,
    output [7:0] bus2,
    input bus3
);
type: Ports</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructhandlers.jl#L121-L152">source</a></section></article><h3 id="declmerge"><a class="docs-heading-anchor" href="#declmerge">declmerge</a><a id="declmerge-1"></a><a class="docs-heading-anchor-permalink" href="#declmerge" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.declmerge" href="#VerilogWriter.declmerge"><code>VerilogWriter.declmerge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">declmerge(d::Parameters...)</code></pre><p>Merge multiple <code>Parameters</code> objects into one <code>Parameters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructhandlers.jl#L169-L173">source</a></section><section><div><pre><code class="nohighlight hljs">declmerge(d::Decls...)</code></pre><p>Merge multiple <code>Decls</code> objects into one <code>Decls</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructhandlers.jl#L169-L173">source</a></section><section><div><pre><code class="nohighlight hljs">declmerge(d::Localparams...)</code></pre><p>Merge multiple <code>Localparams</code> objects into one <code>Localparams</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructhandlers.jl#L169-L173">source</a></section><section><div><pre><code class="nohighlight hljs">declmerge(d::Ports...)</code></pre><p>Merge multiple <code>Ports</code> objects into one <code>Ports</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/513bf2f400784fa51e1a4bd7a3bc38a06b82bca6/src/vstructhandlers.jl#L169-L173">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="intro.html">« Introduction</a><a class="docs-footer-nextpage" href="inference.html">Basic Automation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Friday 9 September 2022 13:46">Friday 9 September 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
