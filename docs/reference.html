<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · VerilogWriter Document</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">VerilogWriter Document</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Examples</a></li><li><a class="tocitem" href="intro.html">Introduction</a></li><li><a class="tocitem" href="structs.html">Basic Structs</a></li><li><a class="tocitem" href="inference.html">Basic Automation</a></li><li><a class="tocitem" href="fsm.html">Finite State Machines</a></li><li class="is-active"><a class="tocitem" href="reference.html">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="reference.html">Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="reference.html">Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>All docstrings are listed below.</p><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.eachfieldconstruct-Tuple{Any}" href="#VerilogWriter.eachfieldconstruct-Tuple{Any}"><code>VerilogWriter.eachfieldconstruct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachfieldconstruct(strc)</code></pre><p>Make contructors for <code>struct strc</code>.</p><p><strong>Example</strong></p><p>For </p><pre><code class="nohighlight hljs">struct S 
a::A
b::B
...
end</code></pre><p>constructors</p><pre><code class="nohighlight hljs">S(x::A) = S(x, B(),...)
S(x::B) = S(A(), x,...)</code></pre><p>will be generated. Note that <code>A(), B()</code> should  return appropriate objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/codegenfunc.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.explicitCallop" href="#VerilogWriter.explicitCallop"><code>VerilogWriter.explicitCallop</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Must be explicitly called as function e.g. <code>|(wire1)</code>, <code>&amp;(wire2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.noJuliaop" href="#VerilogWriter.noJuliaop"><code>VerilogWriter.noJuliaop</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>&amp;&amp;</code> and <code>||</code> are invalid identifier in julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wirenoname" href="#VerilogWriter.wirenoname"><code>VerilogWriter.wirenoname</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>name == &quot;&quot; for no name (intermediate node)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wirevalinvalid" href="#VerilogWriter.wirevalinvalid"><code>VerilogWriter.wirevalinvalid</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>-1 for Int field of Wireexpr which should not contain any data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Alassign" href="#VerilogWriter.Alassign"><code>VerilogWriter.Alassign</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Assign statement inside always blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Alwayscontent" href="#VerilogWriter.Alwayscontent"><code>VerilogWriter.Alwayscontent</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represent always blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Assign" href="#VerilogWriter.Assign"><code>VerilogWriter.Assign</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Assign one statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Atype" href="#VerilogWriter.Atype"><code>VerilogWriter.Atype</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type of always blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Case" href="#VerilogWriter.Case"><code>VerilogWriter.Case</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">case (cnd)
    cnd1: begin
        foo1
    end
    cnd2: begin
        foo2
    end
    ...
endcase</code></pre><p>converts to</p><pre><code class="nohighlight hljs">Case(cnd, [
    (cnd1 =&gt; foo1),
    (cnd2 =&gt; foo2),
    ...
])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L244-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Decls" href="#VerilogWriter.Decls"><code>VerilogWriter.Decls</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multiple wire declarations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Edge" href="#VerilogWriter.Edge"><code>VerilogWriter.Edge</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Edge in sensitivity lists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Ifcontent_inner" href="#VerilogWriter.Ifcontent_inner"><code>VerilogWriter.Ifcontent_inner</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Container of one if-block (, one elseif block, or one else block).</p><p>Parametrized by <code>T, U</code> only for mutual recursion with <code>Ifelseblock</code> and <code>Case</code>, thus used as <code>Ifcontent_inner{Ifelseblock, Case}</code>, which is aliased as <code>Ifcontent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L203-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Ifelseblock_inner" href="#VerilogWriter.Ifelseblock_inner"><code>VerilogWriter.Ifelseblock_inner</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Container of an if-else block. Parametrized by <code>T</code> for mutual recursion. Used as <code>Ifelseblock = Ifelseblock_inner{Case}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L227-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Localparams" href="#VerilogWriter.Localparams"><code>VerilogWriter.Localparams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multiple localparams.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Onedecl" href="#VerilogWriter.Onedecl"><code>VerilogWriter.Onedecl</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represent one wire declaration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Onelocalparam" href="#VerilogWriter.Onelocalparam"><code>VerilogWriter.Onelocalparam</code></a> — <span class="docstring-category">Type</span></header><section><div><p>One localparam.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Oneparam" href="#VerilogWriter.Oneparam"><code>VerilogWriter.Oneparam</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parameter in verilog.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L132-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Oneport" href="#VerilogWriter.Oneport"><code>VerilogWriter.Oneport</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represent a single port declaration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Parameters" href="#VerilogWriter.Parameters"><code>VerilogWriter.Parameters</code></a> — <span class="docstring-category">Type</span></header><section><div><p>List of parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Portdirec" href="#VerilogWriter.Portdirec"><code>VerilogWriter.Portdirec</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Port direction object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Ports" href="#VerilogWriter.Ports"><code>VerilogWriter.Ports</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Gather multiple ports.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Sensitivity" href="#VerilogWriter.Sensitivity"><code>VerilogWriter.Sensitivity</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Sensitivity list for always blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Vmodinst" href="#VerilogWriter.Vmodinst"><code>VerilogWriter.Vmodinst</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Vmodinst</code></pre><p>Represents module instantiation.</p><pre><code class="language-julia hljs">i = Vmodinst(
    &quot;mod1&quot;,
    &quot;u1&quot;,
    [
        &quot;A&quot; =&gt; Wireexpr(15)
    ],
    [
        &quot;p1&quot; =&gt; (@wireexpr x &lt;&lt; 1),
        &quot;p2&quot; =&gt; (@wireexpr y)
    ]
)
vshow(i)

# output

mod1 #(
    .A(15)
) u1 (
    .p1((x &lt;&lt; 1)),
    .p2(y)
);
type: Vmodinst</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L303-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Vmodule" href="#VerilogWriter.Vmodule"><code>VerilogWriter.Vmodule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents one verilog module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr" href="#VerilogWriter.Wireexpr"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wire expressions in verilog. </p><p>Contains unnecessary information to handle all the wires in the same type. </p><p>One motivation to avoid making different types of  wires (e.g. using parametric types) is that it seemed beneficial to have multiple wires in a vector, and that  it is sometime a disadvantage in performance to use  abstract types when creating vectors.</p><p>Some operators on wires in Verilog, which are listed in <code>Enum Wireop</code>,  are overloaded for <code>Wireexpr</code>. Note that reduction operators (unary <code>&amp;, |, ^</code>) are not in Julia,  and logical and, or (<code>&amp;&amp;, ||</code>) can be applied only for booleans in Julia, thus  are not available as an operator for <code>Wireexpr</code> objects.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w1 = @wireexpr x + y;

julia&gt; w2 = @wireexpr z;

julia&gt; vshow(w1 &amp; w2);
((x + y) &amp; z)
type: Wireexpr

julia&gt; w3 = @wireexpr x;

julia&gt; w4 = @wireexpr y &amp;&amp; z; # &amp;&amp; is available inside `@wireexpr` and `wireexpr` methods.

julia&gt; vshow(w3 | w4)
(x | (y &amp;&amp; z))
type: Wireexpr</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L79-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireop" href="#VerilogWriter.Wireop"><code>VerilogWriter.Wireop</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Verilog operators.</p><p>Unary <code>&amp;, |</code> does not exist so explicitly call as function e.g. <code>&amp;(wire), |(wire)</code> (&amp; behaves in a wickedmanner...?), and are only available inside quoted expressions. Xor in verilog <code>^</code> is in Julia exponential operator, and the difference in an association exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wiretype" href="#VerilogWriter.Wiretype"><code>VerilogWriter.Wiretype</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wiretype object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructs.jl#L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Localparams}, Parameters}" href="#Base.convert-Tuple{Type{Localparams}, Parameters}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert parameters and localparams with each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/baseutils.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Onelocalparam}, Oneparam}" href="#Base.convert-Tuple{Type{Onelocalparam}, Oneparam}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert oneparam and onelocalparam with each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/baseutils.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Oneparam}, Onelocalparam}" href="#Base.convert-Tuple{Type{Oneparam}, Onelocalparam}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert oneparam and onelocalparam with each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/baseutils.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Parameters}, Localparams}" href="#Base.convert-Tuple{Type{Parameters}, Localparams}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert parameters and localparams with each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/baseutils.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hash-Tuple{Wireexpr, UInt64}" href="#Base.hash-Tuple{Wireexpr, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.hash(x::Wireexpr, h::UInt)</code></pre><p>Hash for <code>Wireexpr</code> to make it acceptable as keys for <code>Dict</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/baseutils.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isequal-Tuple{Wireexpr, Wireexpr}" href="#Base.isequal-Tuple{Wireexpr, Wireexpr}"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:isequal(uno::Wireexpr, dos::Wireexpr)</code></pre><p>Equality for <code>Wireexpr</code>.</p><p>Note that <code>Base.:(==)</code> for Wireexpr is defined to create a new Wireexpr object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/baseutils.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate-Tuple{Wireexpr}" href="#Base.iterate-Tuple{Wireexpr}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iterate(x::Wireexpr)</code></pre><p>Needed to deal with some return value that may be  either Wireexpr or Vector{Wireexpr}. May cause type instability, but it is already inevitable in parsing AST.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/baseutils.jl#L25-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.TAB" href="#VerilogWriter.TAB"><code>VerilogWriter.TAB</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>TAB as 4 spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/textutils.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.indent-Tuple{Any}" href="#VerilogWriter.indent-Tuple{Any}"><code>VerilogWriter.indent</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Indent <code>txt</code> with spaces of length <span>$eachspalen*depth$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/textutils.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.newlineconcat-Tuple{Any, Any}" href="#VerilogWriter.newlineconcat-Tuple{Any, Any}"><code>VerilogWriter.newlineconcat</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Concatenate <code>uno</code> and <code>dos</code> with &#39;\n&#39; inserted inbetween.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/textutils.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.showfield-Tuple{Any}" href="#VerilogWriter.showfield-Tuple{Any}"><code>VerilogWriter.showfield</code></a> — <span class="docstring-category">Method</span></header><section><div><p>for documentation of structs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/textutils.jl#L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.space-Tuple{Int64}" href="#VerilogWriter.space-Tuple{Int64}"><code>VerilogWriter.space</code></a> — <span class="docstring-category">Method</span></header><section><div><p>generate spaces of length <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/textutils.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.spacewrap-Tuple{Any}" href="#VerilogWriter.spacewrap-Tuple{Any}"><code>VerilogWriter.spacewrap</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Wrap <code>txt</code> with space of length <code>width</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/textutils.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.vshow-Tuple{Any}" href="#VerilogWriter.vshow-Tuple{Any}"><code>VerilogWriter.vshow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vshow(x; systemverilog=true)</code></pre><p>Print the structs in <code>VerilogWriter.jl</code> in a readable  format (except for enums). When <code>systemverilog=false</code>, output <code>always</code>, <code>always @*</code>  instead of <code>always_ff</code>, <code>always_comb</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/textutils.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.addatype!-Tuple{Alwayscontent}" href="#VerilogWriter.addatype!-Tuple{Alwayscontent}"><code>VerilogWriter.addatype!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addatype!(x::Alwayscontent)</code></pre><p>Infer type of always block (combinational or sequential) and add the information to <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructhandlers.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.always-Tuple{Expr}" href="#VerilogWriter.always-Tuple{Expr}"><code>VerilogWriter.always</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">always(expr::Expr)</code></pre><p>Parse AST into always block as <a href="structs.html#Alwayscontent">Alwayscontent</a> using <code>ralways</code>.</p><p>Also infers type of always using <code>addatype!</code>.</p><p><strong>Syntax</strong></p><p><strong><code>&lt;oneblock&gt;;&lt;oneblock&gt;[;&lt;oneblock&gt;;...]</code></strong></p><p><code>&lt;oneblock&gt;</code> is the expression that can be parsed by <a href="structs.html#oneblock">oneblock</a>. <code>;</code> in between <code>&lt;oneblock&gt;</code>s are strictly needed.</p><p><strong><code>@posedge &lt;wirename&gt;; &lt;ifelsestatements&gt;/&lt;assignments&gt;</code></strong></p><p>Set sensitivity list using macro syntax. <code>@negedge</code> is also possible.  You must put <code>@posegde/@negedge</code> statement at the beginning, and only once.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">a1 = always(:(
    w1 = w2;
    if b2 
        w1 = w3 
    end
))
vshow(a1)

# output

always_comb begin
    w1 = w2;
    if (b2) begin
        w1 = w3;
    end
end
type: Alwayscontent</code></pre><pre><code class="language-julia hljs">a1 = always(:(
    @posedge clk;
    
    if b1 == b2
        w1 &lt;= w2 + w3 
    else
        w1 &lt;= ~w1 
    end
))
vshow(a1)

# output

always_ff @( posedge clk ) begin
    if ((b1 == b2)) begin
        w1 &lt;= (w2 + w3);
    end else begin
        w1 &lt;= ~w1;
    end
end
type: Alwayscontent</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructhandlers.jl#L25-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.declmerge-Tuple{Vararg{Decls}}" href="#VerilogWriter.declmerge-Tuple{Vararg{Decls}}"><code>VerilogWriter.declmerge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">declmerge(d::Decls...)</code></pre><p>Merge multiple <code>Decls</code> objects into one <code>Decls</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructhandlers.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.declmerge-Tuple{Vararg{Localparams}}" href="#VerilogWriter.declmerge-Tuple{Vararg{Localparams}}"><code>VerilogWriter.declmerge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">declmerge(d::Localparams...)</code></pre><p>Merge multiple <code>Localparams</code> objects into one <code>Localparams</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructhandlers.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.declmerge-Tuple{Vararg{Parameters}}" href="#VerilogWriter.declmerge-Tuple{Vararg{Parameters}}"><code>VerilogWriter.declmerge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">declmerge(d::Parameters...)</code></pre><p>Merge multiple <code>Parameters</code> objects into one <code>Parameters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructhandlers.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.declmerge-Tuple{Vararg{Ports}}" href="#VerilogWriter.declmerge-Tuple{Vararg{Ports}}"><code>VerilogWriter.declmerge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">declmerge(d::Ports...)</code></pre><p>Merge multiple <code>Ports</code> objects into one <code>Ports</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructhandlers.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.declmergegen-Tuple{}" href="#VerilogWriter.declmergegen-Tuple{}"><code>VerilogWriter.declmergegen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">declmergegen()</code></pre><p>Declare <code>declmerge</code> for multiple types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructhandlers.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ifadd!-Tuple{Ifelseblock, Any, Any}" href="#VerilogWriter.ifadd!-Tuple{Ifelseblock, Any, Any}"><code>VerilogWriter.ifadd!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ifadd!(ifblock::Ifelseblock, cond, ifcont)</p><p>Add <code>cond</code> and <code>ifcont</code> at the head of <code>ifblock</code>.</p><p>Intended to add if-clause to <code>Ifelseblock</code> constructed from elseif-clause (because elseif-clause often parses first).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructhandlers.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.invport-Tuple{Oneport}" href="#VerilogWriter.invport-Tuple{Oneport}"><code>VerilogWriter.invport</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invport(onep::Oneport)</code></pre><p>Return <a href="structs.html#Oneport">Oneport</a> object whose directions are reversed from <code>onep</code>. Wiretype information (<code>reg</code>, <code>wire</code>, <code>logic</code>) is  lost when inverted for <code>reg</code> cannot be at input port.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructhandlers.jl#L105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.invports-Tuple{Ports}" href="#VerilogWriter.invports-Tuple{Ports}"><code>VerilogWriter.invports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invports(ps::Ports)</code></pre><p>Return <a href="structs.html#Ports">Ports</a> object whose directions are reversed from <code>ps</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">pts = @ports (
    @in 8 bus1, bus2;
    @out @reg bus3
)
ipts = invports(pts)
vshow(pts)
vshow(ipts)

# output

(
    input [7:0] bus1,
    input [7:0] bus2,
    output reg bus3
);
type: Ports
(
    output [7:0] bus1,
    output [7:0] bus2,
    input bus3
);
type: Ports</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructhandlers.jl#L121-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.@sym2wire-Tuple{Expr}" href="#VerilogWriter.@sym2wire-Tuple{Expr}"><code>VerilogWriter.@sym2wire</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@sym2wire(arg::Expr)</code></pre><p>Declare new <code>Wireexpr</code>s of name <code>arg...</code>, respectively.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @sym2wire x, y, z;

julia&gt; vshow(y);
y
type: Wireexpr</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructhandlers.jl#L194-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.@sym2wire-Tuple{Symbol}" href="#VerilogWriter.@sym2wire-Tuple{Symbol}"><code>VerilogWriter.@sym2wire</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@sym2wire(arg::Symbol)</code></pre><p>Declare new <code>Wireexpr</code> of name <code>arg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vstructhandlers.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{Int64}" href="#VerilogWriter.Wireexpr-Tuple{Int64}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(n::Int)</code></pre><p>Literal of Integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vconstructors.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{Integer, Integer}" href="#VerilogWriter.Wireexpr-Tuple{Integer, Integer}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(w::Integer, n::Integer)</code></pre><p>Literal with width specification, printed in the decimal format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vconstructors.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{String}" href="#VerilogWriter.Wireexpr-Tuple{String}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(n::String)</code></pre><p>Case where no slice is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vconstructors.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{Symbol}" href="#VerilogWriter.Wireexpr-Tuple{Symbol}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(n::Symbol)</code></pre><p>Convert Symbol to String and construct Wireexpr.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vconstructors.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{Wireexpr}" href="#VerilogWriter.Wireexpr-Tuple{Wireexpr}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(expr::Wireexpr)</code></pre><p>Return the argument itself, used in slice construction to make it possible to apply the same method to msb as Int and as Wireexpr.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vconstructors.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{Wireop, Vararg{Wireexpr}}" href="#VerilogWriter.Wireexpr-Tuple{Wireop, Vararg{Wireexpr}}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(op::Wireop, w::Wireexpr...)</code></pre><p>Apply an operation of <code>w</code> wires.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = @wireexpr a; b = @wireexpr b;

julia&gt; c = Wireexpr(add, a, b); # equivalent to wireexpr(:($(a) + $(b)))

julia&gt; vshow(c);
(a + b)
type: Wireexpr

julia&gt; d = Wireexpr(redor, a); vshow(d); # wireexpr(:(|($(a))))
|(a)
type: Wireexpr</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vconstructors.jl#L102-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{Wireop, Vector{Wireexpr}}" href="#VerilogWriter.Wireexpr-Tuple{Wireop, Vector{Wireexpr}}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(op::Wireop, v::Vector{Wireexpr})</code></pre><p>Apply an operation on wires in <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vconstructors.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Tuple{}" href="#VerilogWriter.Wireexpr-Tuple{}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr()</code></pre><p>Create an empty expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vconstructors.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Union{Tuple{T2}, Tuple{T1}, Tuple{String, T1, T2}} where {T1&lt;:Union{Int64, Wireexpr}, T2&lt;:Union{Int64, Wireexpr}}" href="#VerilogWriter.Wireexpr-Union{Tuple{T2}, Tuple{T1}, Tuple{String, T1, T2}} where {T1&lt;:Union{Int64, Wireexpr}, T2&lt;:Union{Int64, Wireexpr}}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(n::String, msb::T1, lsb::T2) where {T1 &lt;: Union{Int, Wireexpr}, T2 &lt;: Union{Int, Wireexpr}}</code></pre><p>Slice of <code>n</code> from <code>msb</code> to <code>lsb</code>.</p><p>Index for wires can be Int or Wireexpr.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vconstructors.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr-Union{Tuple{T}, Tuple{String, T}} where T&lt;:Union{Int64, Wireexpr}" href="#VerilogWriter.Wireexpr-Union{Tuple{T}, Tuple{String, T}} where T&lt;:Union{Int64, Wireexpr}"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wireexpr(n::String, msb::T) where {T &lt;: Union{Int, Wireexpr}}</code></pre><p>Get one bit at <code>msb</code> from <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/vconstructors.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.blockconvable" href="#VerilogWriter.blockconvable"><code>VerilogWriter.blockconvable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Types to which AST of <code>block</code> can be converted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.blockconv-Tuple{Any, Any, Any, Val{Ifcontent}}" href="#VerilogWriter.blockconv-Tuple{Any, Any, Any, Val{Ifcontent}}"><code>VerilogWriter.blockconv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blockconv(vas, vif, vwire, ::Val{Ifcontent})</code></pre><p>Convert lists of <code>Alassign</code>, <code>Ifelseblock</code>, and <code>Wireexpr</code>  to a single <code>Ifcontent</code>. <code>Wireexpr</code> is supposed to be empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L490-L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.blockconv-Tuple{Any, Any, Any, Val{Ifelseblock}}" href="#VerilogWriter.blockconv-Tuple{Any, Any, Any, Val{Ifelseblock}}"><code>VerilogWriter.blockconv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blockconv(vas, vif, vwire, ::Val{Ifelseblock})</code></pre><p>Convert lists of <code>Alassign</code>, <code>Ifelseblock</code>, and <code>Wireexpr</code>  to a single <code>Ifelseblock</code> (whose <code>conds</code> is empty). <code>Wireexpr</code> is supposed to be empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L478-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.blockconv-Tuple{Any, Any, Any, Val{Wireexpr}}" href="#VerilogWriter.blockconv-Tuple{Any, Any, Any, Val{Wireexpr}}"><code>VerilogWriter.blockconv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blockconv(vas, vif, vwire, ::Val{Wireexpr})</code></pre><p>Convert input to a single Wireexpr. </p><p>It is expected that both <code>vas::Vector{Alassign}</code> and <code>vif::Vector{Ifelseblock}</code> are empty, and vwire is of length 1. Only applied to <code>block</code> at <code>elseif.args[1]</code>  (condition of elseif-clause).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L501-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decloneline-Tuple{Expr}" href="#VerilogWriter.decloneline-Tuple{Expr}"><code>VerilogWriter.decloneline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decloneline(expr::Expr)</code></pre><p>Parse Julia AST into wire declaration as Vector{<a href="structs.html#Onedecl">Onedecl</a>}.</p><p>The number of <code>Onedecl</code> objects returned may differ  according to the number of wires declared in one line  (e.g. <code>input dout</code> &lt;=&gt; <code>input din1, din2, din3</code>).</p><p><strong>Syntax</strong></p><p>Similar to that of <a href="structs.html#portoneline">portoneline</a>.</p><p><strong><code>@wire/@reg/@logic [&lt;width&gt;] &lt;wirename1&gt;[, &lt;wirename2&gt;,...]</code></strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = decloneline(:(@reg 10 d1)); vshow(d);
reg [9:0] d1;
type: Onedecl

julia&gt; d = decloneline(:(@logic 8 d1,d2,d3)); vshow(d);
logic [7:0] d1;
type: Onedecl
logic [7:0] d2;
type: Onedecl
logic [7:0] d3;
type: Onedecl

julia&gt; d = decloneline(:(@wire A &gt;&gt; 2 w1, w2)); vshow(d);
wire [(A &gt;&gt; 2)-1:0] w1;
type: Onedecl
wire [(A &gt;&gt; 2)-1:0] w2;
type: Onedecl</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1268-L1301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decloneline-Union{Tuple{T}, Tuple{Ref{T}}} where T" href="#VerilogWriter.decloneline-Union{Tuple{T}, Tuple{Ref{T}}} where T"><code>VerilogWriter.decloneline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decloneline(expr::Ref{T}) where {T}</code></pre><p>For macro call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1366-L1370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decloneline_inner-Tuple{Any, Wireexpr, Expr}" href="#VerilogWriter.decloneline_inner-Tuple{Any, Wireexpr, Expr}"><code>VerilogWriter.decloneline_inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decloneline_inner(wt, wid::Wireexpr, vars::Expr)</code></pre><p>Declaration of multiple wires (e.g. <code>logic x, y, z</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1347-L1351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decloneline_inner-Tuple{Any, Wireexpr, Symbol}" href="#VerilogWriter.decloneline_inner-Tuple{Any, Wireexpr, Symbol}"><code>VerilogWriter.decloneline_inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decloneline_inner(wt, wid::Wireexpr, var::Symbol)</code></pre><p>Declaration of a single wire (e.g. <code>wire [1:0] d1</code>, <code>reg clk</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1338-L1342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decls-Tuple{Expr, Val{:block}}" href="#VerilogWriter.decls-Tuple{Expr, Val{:block}}"><code>VerilogWriter.decls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decls(expr::Expr, ::Val{:block})</code></pre><p>Multiple lines of wire declarations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1462-L1466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decls-Tuple{Expr, Val{:macrocall}}" href="#VerilogWriter.decls-Tuple{Expr, Val{:macrocall}}"><code>VerilogWriter.decls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decls(expr::Expr, ::Val{:macrocall})</code></pre><p>Parse single line of declaration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1453-L1457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decls-Tuple{Expr}" href="#VerilogWriter.decls-Tuple{Expr}"><code>VerilogWriter.decls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decls(expr::Expr)</code></pre><p>Parse Julia AST into wire declaration section object <a href="structs.html#Decls">Decls</a>.</p><p><strong>Syntax</strong></p><p><strong><code>&lt;onedecl&gt;[;&lt;onedecl&gt;;...]</code></strong></p><p>Multiple <a href="structs.html#decloneline">decloneline</a> expressions which are concatenated  by <code>;</code> can be accepted.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">d = decls(:(
    @wire w1;
    @reg 8 w2,w3,w4;
    @logic 32 w5
))
vshow(d)

# output

wire w1;
reg [7:0] w2;
reg [7:0] w3;
reg [7:0] w4;
logic [31:0] w5;
type: Decls</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1376-L1404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decls-Tuple{Vararg{Decls}}" href="#VerilogWriter.decls-Tuple{Vararg{Decls}}"><code>VerilogWriter.decls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decls(expr::Decls...)</code></pre><p>For interpolation of <code>Decls</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1418-L1422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decls-Tuple{Vararg{Vector{Onedecl}}}" href="#VerilogWriter.decls-Tuple{Vararg{Vector{Onedecl}}}"><code>VerilogWriter.decls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decls(expr::Vector{Onedecl}...)</code></pre><p>For interpolation of a single vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1409-L1413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decls-Tuple{Vector{Onedecl}}" href="#VerilogWriter.decls-Tuple{Vector{Onedecl}}"><code>VerilogWriter.decls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decls(expr::Vector{Onedecl})</code></pre><p>For insertion with metaprogramming.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">a = @decloneline @reg 8 x1, x2
b = decls(:(
    $(a);
    @wire y1, y2
))
vshow(b)

# output

reg [7:0] x1;
reg [7:0] x2;
wire y1;
wire y2;
type: Decls</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1427-L1448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decls-Union{Tuple{T}, Tuple{Ref{T}}} where T" href="#VerilogWriter.decls-Union{Tuple{T}, Tuple{Ref{T}}} where T"><code>VerilogWriter.decls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decls(expr::Ref{T}) where {T}</code></pre><p>For macro calls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1488-L1492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ifcontent-Tuple{Expr}" href="#VerilogWriter.ifcontent-Tuple{Expr}"><code>VerilogWriter.ifcontent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ifcontent(x::Expr)</code></pre><p>Convert into <code>Ifcontent</code> what is convertible to <code>Alwayscontent</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">x = @ifcontent (
    a = b;
    if b 
        x = c
    else
        x = d 
    end
)
vshow(x)

# output

a = b;
if (b) begin
    x = c;
end else begin
    x = d;
end
type: Ifcontent</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L966-L993">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ifcontent-Union{Tuple{T}, Tuple{Ref{T}}} where T" href="#VerilogWriter.ifcontent-Union{Tuple{T}, Tuple{Ref{T}}} where T"><code>VerilogWriter.ifcontent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ifcontent(x::Ref{T}) where {T}</code></pre><p>For macro call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1000-L1004">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.localparams-Tuple{Expr}" href="#VerilogWriter.localparams-Tuple{Expr}"><code>VerilogWriter.localparams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localparams(expr::Expr)</code></pre><p>Multiple localparams.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = localparams(:(x = 10)); vshow(p);
localparam x = 10;
type: Localparams</code></pre><pre><code class="language-julia hljs">p = localparams(:(
    a = 111;
    b = 222;
    c = 333
))
vshow(p)

# output

localparam a = 111;
localparam b = 222;
localparam c = 333;
type: Localparams</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L132-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.localparams-Union{Tuple{T}, Tuple{Ref{T}}} where T" href="#VerilogWriter.localparams-Union{Tuple{T}, Tuple{Ref{T}}} where T"><code>VerilogWriter.localparams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localparams(expr::Ref{T}) where {T}</code></pre><p>For macro call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L183-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneblock-Tuple{Any, Val{:(=)}}" href="#VerilogWriter.oneblock-Tuple{Any, Val{:(=)}}"><code>VerilogWriter.oneblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneblock(expr, ::Val{:(=)})</code></pre><p>Assignment in Julia, stands for combinational assignment in Verilog.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L348-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneblock-Tuple{Any, Val{:&lt;=}, Val{:call}}" href="#VerilogWriter.oneblock-Tuple{Any, Val{:&lt;=}, Val{:call}}"><code>VerilogWriter.oneblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneblock(expr, ::Val{:&lt;=})</code></pre><p>Parse <code>expr</code> whose head is <code>call</code> and <code>expr.args[1]</code> is <code>&lt;=</code>.</p><p>Parse as a comparison opertor in Julia, interpret as  sequential assignment in Verilog.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L367-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneblock-Tuple{Any, Val{:call}}" href="#VerilogWriter.oneblock-Tuple{Any, Val{:call}}"><code>VerilogWriter.oneblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneblock(expr, ::Val{:call})</code></pre><p>Dispatch methods of <code>oneblock</code> according to <code>expr.args[1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L358-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneblock-Tuple{Any, Val{:elseif}}" href="#VerilogWriter.oneblock-Tuple{Any, Val{:elseif}}"><code>VerilogWriter.oneblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneblock(expr, ::Val{:elseif})</code></pre><p>Parse <code>expr</code> into <code>Ifelseblock</code> where <code>expr</code> is elseif-clause.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L517-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneblock-Tuple{Expr}" href="#VerilogWriter.oneblock-Tuple{Expr}"><code>VerilogWriter.oneblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneblock(expr::Expr)</code></pre><p>Parse AST in Julia grammar to one if-else statement or  one assignment inside always blocks in Verilog,  which are <a href="structs.html#Ifelseblock">Ifelseblock</a> and <a href="structs.html#Alassign">Alassign</a>, respectively. </p><p>As using Julia expression and Julia parser as if  it is of Verilog, there can be difference in grammatical matters  between what can be given as the <code>expr</code> and real Verilog  (e.g. operator precedence of <code>&lt;=</code>).</p><p><strong>Syntax</strong></p><p><strong><code>&lt;wirename1&gt; = &lt;wireoperation&gt;</code></strong></p><p>One blocking assignment. (Note that bit width cannot be  specified yet, nor can it be printed.) <code>&lt;wireoperation&gt;</code> is a expression accepted by <a href="structs.html#wireexpr">wireexpr</a>.</p><p><strong>If-else statement</strong></p><pre><code class="nohighlight hljs">if &lt;wireoperation&gt;
    &lt;oneassignment&gt;
    &lt;oneassignment&gt;
    ...
elseif &lt;wireoperation&gt; 
    &lt;oneassignment&gt;
    &lt;ifelsestatement&gt;
    ...
else
    &lt;ifelsestatement&gt;
    ...
end</code></pre><p>If-else statement written in &#39;Julia syntax&#39;, not in Verilog  syntax, can be accepted. <code>else</code> block and <code>elseif</code> are not compulsory. Since <code>if</code> <code>end</code> are at the top level no <code>;</code> inside if-else statement is needed. Nested if-else statement can be also accepted as in usual Julia.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a1 = oneblock(:(w1 &lt;= w2)); 

julia&gt; vshow(a1);
w1 &lt;= w2;
type: Alassign

julia&gt; a2 = oneblock(:(w3 = w4 + ~w2)); vshow(a2);
w3 = (w4 + ~w2);
type: Alassign</code></pre><pre><code class="language-julia hljs">a3 = oneblock(:(
    if b1 == b2
        w5 = ~w6
        w7 = w8 
    elseif b2 
        w9 = w9 + w10
    else
        if b3 
            w11 = w12 
        end
    end
))
vshow(a3)

# output

if ((b1 == b2)) begin
    w5 = ~w6;
    w7 = w8;
end else if (b2) begin
    w9 = (w9 + w10);
end else begin
    if (b3) begin
        w11 = w12;
    end
end
type: Ifelseblock</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L221-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneblock-Tuple{T} where T&lt;:Union{Alassign, Ifelseblock}" href="#VerilogWriter.oneblock-Tuple{T} where T&lt;:Union{Alassign, Ifelseblock}"><code>VerilogWriter.oneblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneblock(expr::T) where {T &lt;: Union{Alassign, Ifelseblock}}</code></pre><p>For insertion through metaprogramming.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">a = @oneblock r = s &amp; t
b = @oneblock (
    if b 
        x = y 
    else
        x = z
    end
)
c = always(:(
    p = q;
    $(a);
    $(b)
))
vshow(c)

# output

always_comb begin
    p = q;
    r = (s &amp; t);
    if (b) begin
        x = y;
    end else begin
        x = z;
    end
end
type: Alwayscontent</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L305-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneblock-Tuple{T} where T&lt;:Union{Int64, Symbol}" href="#VerilogWriter.oneblock-Tuple{T} where T&lt;:Union{Int64, Symbol}"><code>VerilogWriter.oneblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneblock(expr::T) where {T &lt;: Union{Symbol, Int}}</code></pre><p>Convert <code>expr</code> to <code>Wireexpr</code>. Needed in parsing <code>block</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L202-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneblock-Tuple{UInt8}" href="#VerilogWriter.oneblock-Tuple{UInt8}"><code>VerilogWriter.oneblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneblock(expr::UInt8)</code></pre><p>UInt8 may be given when user writes e.g. 0b10, 0x1f. Used when parsing <code>block</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L211-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneblock-Union{Tuple{T}, Tuple{Any, Val{:block}, Val{T}}} where T&lt;:Union{Wireexpr, Ifcontent, Ifelseblock}" href="#VerilogWriter.oneblock-Union{Tuple{T}, Tuple{Any, Val{:block}, Val{T}}} where T&lt;:Union{Wireexpr, Ifcontent, Ifelseblock}"><code>VerilogWriter.oneblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneblock(expr, ::Val{:block}, ::Val{T}) where {T &lt;: blockconvable}</code></pre><p>Parse <code>expr</code> (which is <code>block</code>) into <code>T</code>. <code>block</code> appears at various nodes, thus need to explicitly indicate which type the return value should be. Types that is allowed as return value is in <a href="reference.html#VerilogWriter.blockconvable"><code>blockconvable</code></a>.</p><p>See also <a href="reference.html#VerilogWriter.blockconv-Tuple{Any, Any, Any, Val{Ifcontent}}"><code>blockconv</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L398-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneblock-Union{Tuple{T}, Tuple{Any, Val{:elseif}, Val{T}}} where T&lt;:Union{Wireexpr, Ifcontent, Ifelseblock}" href="#VerilogWriter.oneblock-Union{Tuple{T}, Tuple{Any, Val{:elseif}, Val{T}}} where T&lt;:Union{Wireexpr, Ifcontent, Ifelseblock}"><code>VerilogWriter.oneblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneblock(expr, ::Val{:elseif}, ::Val{T}) where {T &lt;: blockconvable}</code></pre><p>When given <code>Val{T}</code> as the third argument, if <code>expr</code> is not <code>block</code>  (= if the second argument is not <code>Val{:block}</code>), ignore <code>Val{T}</code>.</p><p>This is needed in <code>oneblock(expr, ::Val{:elseif})</code>,  for <code>expr</code>, whose <code>expr.head == :elseif</code>, can have either  <code>block</code> or <code>elseif</code> as its <code>expr.args[3]</code>. Checks that the return value is of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L383-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneblock-Union{Tuple{T}, Tuple{Any, Val{T}}} where T&lt;:Union{Wireexpr, Ifcontent, Ifelseblock}" href="#VerilogWriter.oneblock-Union{Tuple{T}, Tuple{Any, Val{T}}} where T&lt;:Union{Wireexpr, Ifcontent, Ifelseblock}"><code>VerilogWriter.oneblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneblock(expr, ::Val{T}) where {T &lt;: blockconvable}</code></pre><p>Helper method to make it possible to dispatch <code>oneblock</code> without giving <code>expr.head</code> as an argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L448-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneblock-Union{Tuple{T}, Tuple{Ref{T}}} where T" href="#VerilogWriter.oneblock-Union{Tuple{T}, Tuple{Ref{T}}} where T"><code>VerilogWriter.oneblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneblock(expr::Ref{T}) where {T}</code></pre><p>Dereference and parse <code>expr</code> given by user. Helper function  for macro <code>@oneblock</code>.</p><p>See also <a href="reference.html#VerilogWriter.@oneblock-Tuple{Any}"><code>@oneblock</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L557-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.onelocalparam-Tuple{Expr}" href="#VerilogWriter.onelocalparam-Tuple{Expr}"><code>VerilogWriter.onelocalparam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">onelocalparam(expr::Expr)</code></pre><p>One localparam object. The syntax is the same as <code>oneparam</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vshow(onelocalparam(:(x = 100)))
localparam x = 100;
type: Onelocalparam</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L97-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.onelocalparam-Union{Tuple{T}, Tuple{Ref{T}}} where T" href="#VerilogWriter.onelocalparam-Union{Tuple{T}, Tuple{Ref{T}}} where T"><code>VerilogWriter.onelocalparam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">onelocalparam(expr::Ref{T}) where {T}</code></pre><p>For macro call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneparam-Tuple{Expr}" href="#VerilogWriter.oneparam-Tuple{Expr}"><code>VerilogWriter.oneparam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneparam(expr::Expr)</code></pre><p>One parameter. </p><p><strong>Syntax</strong></p><p><strong><code>&lt;paramname&gt; = &lt;val::Int&gt;</code></strong></p><pre><code class="language-julia-repl hljs">julia&gt; vshow(oneparam(:(x = 10)));
parameter x = 10
type: Oneparam</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L10-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.oneparam-Union{Tuple{T}, Tuple{Ref{T}}} where T" href="#VerilogWriter.oneparam-Union{Tuple{T}, Tuple{Ref{T}}} where T"><code>VerilogWriter.oneparam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneparam(expr::Ref{T}) where {T}</code></pre><p>For macro call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.parameters-Tuple{Expr}" href="#VerilogWriter.parameters-Tuple{Expr}"><code>VerilogWriter.parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameters(expr::Expr)</code></pre><p>Multiple parameters.</p><p>Using <code>convert</code> and <code>localparams</code> inside.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">v = parameters(:(
    x = 10;
    y = 20;
    z = 30
))
vshow(v)

# output

#(
    parameter x = 10,
    parameter y = 20,
    parameter z = 30
)
type: Parameters</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L48-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.parameters-Union{Tuple{T}, Tuple{Ref{T}}} where T" href="#VerilogWriter.parameters-Union{Tuple{T}, Tuple{Ref{T}}} where T"><code>VerilogWriter.parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameters(expr::Ref{T}) where {T}</code></pre><p>For macro call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.pdirecsym-Tuple{Any}" href="#VerilogWriter.pdirecsym-Tuple{Any}"><code>VerilogWriter.pdirecsym</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pdirecsym(sym)</code></pre><p>Convert  symbols <code>@in, @out</code> to <code>pin, pout (::Portdirec)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1082-L1086">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.portoneline-Tuple{Expr}" href="#VerilogWriter.portoneline-Tuple{Expr}"><code>VerilogWriter.portoneline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">portoneline(expr::Expr)</code></pre><p>Parse Julia AST to one line of port declaration as <a href="structs.html#Oneport">Oneport</a>.</p><p><strong>Syntax</strong></p><p><strong><code>@in &lt;wirename&gt;</code>, <code>@out &lt;wirename&gt;</code></strong></p><p>One port declaration of width 1.</p><p><strong><code>@in/@out &lt;wirename1, wirename2, ...&gt;</code></strong></p><p>Multiple port declaration of width 1 in one line.</p><p><strong><code>@in/@out &lt;width&gt; &lt;wirename1[, wirename2, ...]&gt;</code></strong></p><p>Port declarations of width <code>&lt;width&gt;</code>.</p><p><strong><code>@in/@out @&lt;wiretype&gt; [&lt;width&gt;] &lt;wirename1[, wirename2, ...]&gt;</code></strong></p><p>Port declaration with wiretypes [of width <code>&lt;width&gt;</code>].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p1 = portoneline(:(@in din));

julia&gt; vshow(p1);
input din
type: Oneport

julia&gt; p2 = portoneline(:(@out din1, din2, din3)); vshow(p2);
output din1
type: Oneport
output din2
type: Oneport
output din3
type: Oneport

julia&gt; p3 = portoneline(:(@in 8 din)); vshow(p3);
input [7:0] din
type: Oneport

julia&gt; p4 = portoneline(:(@out @reg 8 dout)); vshow(p4);
output reg [7:0] dout
type: Oneport

julia&gt; p5 = portoneline(:(@out (A+B)&lt;&lt;2 x, y)); vshow(p5); # width with parameter
output [((A + B) &lt;&lt; 2)-1:0] x
type: Oneport
output [((A + B) &lt;&lt; 2)-1:0] y
type: Oneport</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1019-L1067">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.portoneline-Union{Tuple{T}, Tuple{Ref{T}}} where T" href="#VerilogWriter.portoneline-Union{Tuple{T}, Tuple{Ref{T}}} where T"><code>VerilogWriter.portoneline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">portoneline(expr::Ref{T}) where {T}</code></pre><p>For macro call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1115-L1119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ports-Tuple{Expr, Val{:block}}" href="#VerilogWriter.ports-Tuple{Expr, Val{:block}}"><code>VerilogWriter.ports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ports(expr::Expr, ::Val{:block})</code></pre><p>Contain multiple lines of port declaration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1223-L1227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ports-Tuple{Expr, Val{:macrocall}}" href="#VerilogWriter.ports-Tuple{Expr, Val{:macrocall}}"><code>VerilogWriter.ports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ports(expr::Expr, ::Val{:macrocall})</code></pre><p>Contain only single line declaration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1214-L1218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ports-Tuple{Expr}" href="#VerilogWriter.ports-Tuple{Expr}"><code>VerilogWriter.ports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ports(expr::Expr)</code></pre><p>Convert Julia AST into port declarations as <a href="structs.html#Ports">Ports</a> object.</p><p><strong>Syntax</strong></p><p><strong><code>&lt;portoneline&gt;[;&lt;portoneline&gt;;...]</code></strong></p><p>Multiple lines of <a href="reference.html#VerilogWriter.portoneline-Tuple{Expr}"><code>portoneline</code></a> expressions  separated by <code>;</code> can be accepted. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs">pp = ports(:(
    @in p1;
    @in @wire 8 p2, p3, p4;
    @out @reg 2 p5, p6
))

vshow(pp)

# output

(
    input p1,
    input [7:0] p2,
    input [7:0] p3,
    input [7:0] p4,
    output reg [1:0] p5,
    output reg [1:0] p6
);
type: Ports</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1133-L1165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ports-Tuple{Vararg{Ports}}" href="#VerilogWriter.ports-Tuple{Vararg{Ports}}"><code>VerilogWriter.ports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ports(expr::Ports...)</code></pre><p>Interpolation of one Vector{Ports}, nothing else given. e.g. ports(:([ports(:(#= none:1 =# @in(6, x))), ports(:(#= none:1 =# @in(y)))]...))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1200-L1205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ports-Tuple{Vector{Oneport}}" href="#VerilogWriter.ports-Tuple{Vector{Oneport}}"><code>VerilogWriter.ports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ports(expr::Vector{Oneport})</code></pre><p>Insertion through metaprogramming.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">a = @portoneline @in 8 d1, d2, d3
b = ports(:(
    @in d0;
    $(a);
    @out @reg 8 dout
))
vshow(b)

# output

(
    input d0,
    input [7:0] d1,
    input [7:0] d2,
    input [7:0] d3,
    output reg [7:0] dout
);
type: Ports</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1170-L1195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ports-Union{Tuple{T}, Tuple{Ref{T}}} where T" href="#VerilogWriter.ports-Union{Tuple{T}, Tuple{Ref{T}}} where T"><code>VerilogWriter.ports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ports(expr::Ref{T}) where {T}</code></pre><p>For macro call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1249-L1253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ralways-Tuple{Expr, Val{:block}}" href="#VerilogWriter.ralways-Tuple{Expr, Val{:block}}"><code>VerilogWriter.ralways</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ralways(expr::Expr, ::Val{:block})</code></pre><p>Convert multiple ifelse-blocks and assigns to one always-block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L895-L899">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ralways-Tuple{Expr}" href="#VerilogWriter.ralways-Tuple{Expr}"><code>VerilogWriter.ralways</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ralways(expr::Expr)</code></pre><p>Convert Julia AST to Verilog always-block. </p><p>Does not infer type of alwaysblock here. Dispatches methods here according to <code>expr.head</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L844-L851">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ralways-Union{Tuple{T}, Tuple{Expr, T}} where T&lt;:Val" href="#VerilogWriter.ralways-Union{Tuple{T}, Tuple{Expr, T}} where T&lt;:Val"><code>VerilogWriter.ralways</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ralways(expr::Expr, ::T) where {T &lt;: Val}</code></pre><p>The case where <code>expr.head</code> is not <code>block</code>, which means <code>expr</code> is one assign (inside always-block) or if-else block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L864-L869">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ralways-Union{Tuple{T}, Tuple{Ref{T}}} where T" href="#VerilogWriter.ralways-Union{Tuple{T}, Tuple{Ref{T}}} where T"><code>VerilogWriter.ralways</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ralways(expr::Ref{T}) where {T}</code></pre><p>For macro call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L956-L960">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ralwayswithSensitivity-Tuple{Any}" href="#VerilogWriter.ralwayswithSensitivity-Tuple{Any}"><code>VerilogWriter.ralwayswithSensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ralwayswithSensitivity(expr)</code></pre><p>Parse always block with sensitivity list (e.g. @posedge clk).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L874-L878">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.removelinenumbernode-Union{Tuple{T}, Tuple{Vector{T}}} where T" href="#VerilogWriter.removelinenumbernode-Union{Tuple{T}, Tuple{Vector{T}}} where T"><code>VerilogWriter.removelinenumbernode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">removelinenumbernode(args::Vector{T}) where {T}</code></pre><p>Remove <code>LineNumberNode</code> from <code>args</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireexpr-Tuple{Any, Val{:(:)}, Val{:call}}" href="#VerilogWriter.wireexpr-Tuple{Any, Val{:(:)}, Val{:call}}"><code>VerilogWriter.wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireexpr(expr, ::Val{:(:)}, ::Val{:call})</code></pre><p>Parse wire slice with range object, e.g. <code>x[a:b]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L745-L749">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireexpr-Tuple{Any, Val{:quote}}" href="#VerilogWriter.wireexpr-Tuple{Any, Val{:quote}}"><code>VerilogWriter.wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireexpr(expr, ::Val{:quote})</code></pre><p>For indexed part select.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L579-L583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireexpr-Tuple{Any, Val{:ref}}" href="#VerilogWriter.wireexpr-Tuple{Any, Val{:ref}}"><code>VerilogWriter.wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireexpr(expr, ::Val{:ref})</code></pre><p>Bit select or slice of wires, e.g. <code>x[1]</code> and <code>x[p:1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L594-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireexpr-Tuple{Expr, Val{:&amp;}}" href="#VerilogWriter.wireexpr-Tuple{Expr, Val{:&amp;}}"><code>VerilogWriter.wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireexpr(expr::Expr, ::Val{:&amp;})</code></pre><p>Unary <code>&amp;</code> parses differently from <code>|(wire)</code> and <code>^(wire)</code>. What is <code>&amp;(wire)</code> originally used for in Julia?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L808-L813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireexpr-Tuple{Expr}" href="#VerilogWriter.wireexpr-Tuple{Expr}"><code>VerilogWriter.wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireexpr(expr::Expr)</code></pre><p>Parse one wire expression. Be sure to put &#39;two e&#39;s&#39; in wir&#39;ee&#39;xpr, not &#39;wirexpr&#39;.</p><p><strong>Syntax</strong></p><p>Part of what can be done in Verilog can be accepted,  such as <code>din[7:0]</code>, <code>(w1 + w2) &lt;&lt; 5</code></p><p><strong><code>&lt;wirename&gt;</code></strong></p><p>One wire, without slicing or bit-selecting.</p><p><strong><code>&lt;val::Int&gt;</code>, <code>&lt;val::hex&gt;</code>, <code>&lt;val::bin&gt;</code></strong></p><p>Literals, e.g. <code>5</code>, <code>0x1f</code>, <code>0b10</code>.</p><p><strong><code>&lt;wire&gt; &lt;op&gt; &lt;wire&gt;</code>, <code>&lt;op&gt; &lt;wire&gt;</code></strong></p><p>Unary and binary operators.  For reduction operators (unary <code>&amp;, |, ^</code>), since these are  not operators in Julia, write it in the form of function  call explicitly, i.e. <code>&amp;(wire)</code>, <code>|(wire)</code> instead of doing <code>^wire</code>. Note that we use <code>^</code> as xor just as in Verilog, though this is not  a xor operator in Julia.</p><p><strong><code>&lt;wire&gt;[&lt;wire&gt;:&lt;wire&gt;]</code>, <code>&lt;wire&gt;[&lt;wire&gt;]</code></strong></p><p>Bit select and slicing as in Verilog/SystemVerilog. Does not reject even if both wires in <code>[&lt;wire&gt;:&lt;wire&gt;]</code> are not of constant value.</p><p><strong><code>wire[&lt;wire&gt;-:&lt;wire&gt;]</code></strong></p><p>Indexed part select. Does not reject even if <code>&lt;wire&gt;</code> after <code>-:</code> is not of constant value. As using <code>-</code> operator and <code>:</code> (quote) in Julia syntax,  no spaces between <code>&lt;wire&gt;(here)-:(and here)&lt;wire&gt;</code> are allowed,  and <code>&lt;wire&gt;</code> after <code>-:</code> should in most cases be put inside parentheses.</p><p>Note that because <code>:</code> (quote) is used inside quote,  you (for now) cannot embed objects here through Metaprogramming.</p><p>e.g. <code>w = (@wireexpr w); oneblock(:(x[A-:($w)] &lt;= y))</code> is not  allowed. </p><p>In such cases use constructors instead.</p><pre><code class="language-julia-repl hljs">julia&gt; e = Wireexpr(ipselm, @wireexpr(x), @wireexpr(A), @wireexpr(w));

julia&gt; vshow(oneblock(:($(e) &lt;= y)));
x[A -: w] &lt;= y;
type: Alassign</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = wireexpr(:(w)); vshow(w);
w
type: Wireexpr

julia&gt; w = wireexpr(:(w1 &amp; &amp;(w2) )); vshow(w);
(w1 &amp; &amp;(w2))
type: Wireexpr

julia&gt; w = wireexpr(:(w[i:0])); vshow(w);
w[i:0]
type: Wireexpr

julia&gt; w = @wireexpr w[(P*Q)-:(R+10)]; vshow(w);
w[(P * Q) -: (R + 10)]
type: Wireexpr
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L646-L717">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireexpr-Tuple{QuoteNode}" href="#VerilogWriter.wireexpr-Tuple{QuoteNode}"><code>VerilogWriter.wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireexpr(expr::QuoteNode)</code></pre><p>For indexed part select.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L570-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireexpr-Tuple{Wireexpr}" href="#VerilogWriter.wireexpr-Tuple{Wireexpr}"><code>VerilogWriter.wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireexpr(expr::Wireexpr)</code></pre><p>Insertion through metaprogramming.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = @wireexpr x + y;

julia&gt; e = :(a + |($(w) &amp; z));

julia&gt; ans = wireexpr(e); vshow(ans);
(a + |(((x + y) &amp; z)))
type: Wireexpr</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L722-L736">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireexpr-Union{Tuple{T}, Tuple{Any, T, Val{:call}}} where T&lt;:Union{Val{:&lt;&lt;}, Val{:&amp;}, Val{:||}, Val{:&amp;&amp;}, Val{:*}, Val{:/}, Val{:&lt;=}, Val{:|}, Val{:&gt;&gt;}, Val{:-}, Val{:^}, Val{:&lt;}, Val{:+}, Val{:(==)}}" href="#VerilogWriter.wireexpr-Union{Tuple{T}, Tuple{Any, T, Val{:call}}} where T&lt;:Union{Val{:&lt;&lt;}, Val{:&amp;}, Val{:||}, Val{:&amp;&amp;}, Val{:*}, Val{:/}, Val{:&lt;=}, Val{:|}, Val{:&gt;&gt;}, Val{:-}, Val{:^}, Val{:&lt;}, Val{:+}, Val{:(==)}}"><code>VerilogWriter.wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireexpr(expr, ::T, ::Val{:call}) where {T &lt;: binopvals}</code></pre><p>Parse binary operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L772-L776">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireexpr-Union{Tuple{T}, Tuple{Any, T, Val{:call}}} where T&lt;:Union{Val{:|}, Val{:&amp;}, Val{:^}, Val{:-}}" href="#VerilogWriter.wireexpr-Union{Tuple{T}, Tuple{Any, T, Val{:call}}} where T&lt;:Union{Val{:|}, Val{:&amp;}, Val{:^}, Val{:-}}"><code>VerilogWriter.wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireexpr(expr, ::T, ::Val{:call}) where {T &lt;: arityambigVals}</code></pre><p>Disambiguate symbols in <code>arityambigVals</code> between  unary and binary operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L792-L797">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireexpr-Union{Tuple{T}, Tuple{Any, T, Val{:call}}} where T&lt;:Union{Val{:~}, Val{:-}, Val{:^}, Val{:|}, Val{:&amp;}}" href="#VerilogWriter.wireexpr-Union{Tuple{T}, Tuple{Any, T, Val{:call}}} where T&lt;:Union{Val{:~}, Val{:-}, Val{:^}, Val{:|}, Val{:&amp;}}"><code>VerilogWriter.wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireexpr(expr, ::T, ::Val{:call}) where {T &lt;: unaopvals}</code></pre><p>Parse unary operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L762-L766">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wtypesym-Tuple{Symbol}" href="#VerilogWriter.wtypesym-Tuple{Symbol}"><code>VerilogWriter.wtypesym</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wtypesym(wt::Symbol)</code></pre><p>Given either of symbols <code>@wire, @reg, @logic</code>, return  <code>wire, reg, logic (::Wiretype)</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1321-L1326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.@decloneline-Tuple{Any}" href="#VerilogWriter.@decloneline-Tuple{Any}"><code>VerilogWriter.@decloneline</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@decloneline(arg)</code></pre><p>Macro version of <code>decloneline</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1357-L1361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.@decls-Tuple{Any}" href="#VerilogWriter.@decls-Tuple{Any}"><code>VerilogWriter.@decls</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@decls(arg)</code></pre><p>Macro version of <code>decls</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1497-L1501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.@ifcontent-Tuple{Any}" href="#VerilogWriter.@ifcontent-Tuple{Any}"><code>VerilogWriter.@ifcontent</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@ifcontent(arg)</code></pre><p>Macro call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1009-L1013">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.@localparams-Tuple{Any}" href="#VerilogWriter.@localparams-Tuple{Any}"><code>VerilogWriter.@localparams</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@localparams(arg)</code></pre><p>Macro version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L192-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.@oneblock-Tuple{Any}" href="#VerilogWriter.@oneblock-Tuple{Any}"><code>VerilogWriter.@oneblock</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@oneblock(arg)</code></pre><p>Parse <code>arg</code> (which is AST) using macro. Uses reference  to prevent <code>arg</code> being evaluated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L547-L552">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.@onelocalparam-Tuple{Any}" href="#VerilogWriter.@onelocalparam-Tuple{Any}"><code>VerilogWriter.@onelocalparam</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@onelocalparam(arg)</code></pre><p>Macro call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.@oneparam-Tuple{Any}" href="#VerilogWriter.@oneparam-Tuple{Any}"><code>VerilogWriter.@oneparam</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@oneparam(arg)</code></pre><p>Macro call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.@parameters-Tuple{Any}" href="#VerilogWriter.@parameters-Tuple{Any}"><code>VerilogWriter.@parameters</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@parameters(arg)</code></pre><p>Macro call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.@portoneline-Tuple{Any}" href="#VerilogWriter.@portoneline-Tuple{Any}"><code>VerilogWriter.@portoneline</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@portoneline(arg)</code></pre><p>Macro version of <code>portoneline</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1124-L1128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.@ports-Tuple{Any}" href="#VerilogWriter.@ports-Tuple{Any}"><code>VerilogWriter.@ports</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@ports(arg)</code></pre><p>Macro version of <code>ports</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L1258-L1262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.@ralways-Tuple{Any}" href="#VerilogWriter.@ralways-Tuple{Any}"><code>VerilogWriter.@ralways</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@ralways(arg)</code></pre><p><code>ralways</code> macro version. </p><p>Not supposed to be used in most cases,  <code>@always</code> and <code>always</code> are often better.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/rawparser.jl#L944-L951">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.atypealways-Tuple{Ifcontent}" href="#VerilogWriter.atypealways-Tuple{Ifcontent}"><code>VerilogWriter.atypealways</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atypealways(x::Ifcontent)</code></pre><p>Infer type of always-block (into always<em>ff or always</em>comb).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/alwaysinference.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.atypealways-Union{Tuple{T}, Tuple{Vector{T}}} where T" href="#VerilogWriter.atypealways-Union{Tuple{T}, Tuple{Vector{T}}} where T"><code>VerilogWriter.atypealways</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atypealways(x::Vector{T}) where {T}</code></pre><p>Infer type of always-block from a vector of <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/alwaysinference.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.punsolved" href="#VerilogWriter.punsolved"><code>VerilogWriter.punsolved</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>value to be returned when parameter value cannot be solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/paramsolve.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireop-Tuple{Int64, Int64}" href="#VerilogWriter.Wireop-Tuple{Int64, Int64}"><code>VerilogWriter.Wireop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(cls::Wireop)(uno::Int, dos::Int)</code></pre><p>Operators in <code>wbinop</code> are now callable.</p><p>Used in calculating parameters, for <code>Wireexpr</code> is used inside parameter objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/paramsolve.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireop-Tuple{Int64}" href="#VerilogWriter.Wireop-Tuple{Int64}"><code>VerilogWriter.Wireop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(cls::Wireop)(uno::Int)</code></pre><p><code>uminus</code>, whose type is <code>Wireop</code> is now callable.</p><p>Used in calculating parameters, for <code>Wireexpr</code> is used inside parameter objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/paramsolve.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.paramcalc-Tuple{Wireexpr, Any}" href="#VerilogWriter.paramcalc-Tuple{Wireexpr, Any}"><code>VerilogWriter.paramcalc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">paramcalc(w::Wireexpr, ans)</code></pre><p>Evaluate paramter whose rhs is <code>w</code> under <code>ans</code> returned from <code>paramsolve</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/paramsolve.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.paramcalc-Tuple{Wireexpr}" href="#VerilogWriter.paramcalc-Tuple{Wireexpr}"><code>VerilogWriter.paramcalc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">paramcalc(w::Wireexpr)</code></pre><p>Evaluate <code>w</code> under empty environment, for debugging.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/paramsolve.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.paramsolve-Tuple{Parameters, Localparams}" href="#VerilogWriter.paramsolve-Tuple{Parameters, Localparams}"><code>VerilogWriter.paramsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">paramsolve(prm::Parameters, lprm::Localparams)</code></pre><p>Using <code>prm</code> and <code>lprm</code>, calculate all parameters&#39; rhs, which is a  <code>Wireexpr</code>, and determine the constant value corresponds to each parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/paramsolve.jl#L115-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.paramsolvecore!-Tuple{String, Any, Any}" href="#VerilogWriter.paramsolvecore!-Tuple{String, Any, Any}"><code>VerilogWriter.paramsolvecore!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">paramsolvecore!(n::String, ans, alldict)</code></pre><p>Prepare for the computation of the parameter named <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/paramsolve.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.paramsolvecore_inner!-Tuple{Any, Dict{String, Int64}, Dict{String, Wireexpr}, Dict{String, Bool}}" href="#VerilogWriter.paramsolvecore_inner!-Tuple{Any, Dict{String, Int64}, Dict{String, Wireexpr}, Dict{String, Bool}}"><code>VerilogWriter.paramsolvecore_inner!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">paramsolvecore_inner!(w, ans::Dict{String, Int}, alldict::Dict{String, Wireexpr}, visited::Dict{String, Bool})</code></pre><p>Return the constant value of <code>w::Wireexpr</code>.</p><p>If the value for <code>w</code> has not been calculated, recursively (with depth-first-search)  evaluate the parameters which appear at rhs of <code>w</code>, and update <code>ans</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/paramsolve.jl#L46-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.fsmconv-Tuple{Type{Case}, FSM, Atype}" href="#VerilogWriter.fsmconv-Tuple{Type{Case}, FSM, Atype}"><code>VerilogWriter.fsmconv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fsmconv(::Type{Case}, x::FSM, atype::Atype)</code></pre><p>Accept as an argument <code>atype</code> to be used in assignments inside  a case statement. Defaults to <code>ff</code> in the method <code>fsmconv(::Type{Case}, x::FSM)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/fsm.jl#L246-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.fsmconv-Tuple{Type{Case}, FSM}" href="#VerilogWriter.fsmconv-Tuple{Type{Case}, FSM}"><code>VerilogWriter.fsmconv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fsmconv(::Type{Case}, x::FSM)</code></pre><p>Convert <code>FSM</code> object into <code>Case</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/fsm.jl#L237-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.fsmconv-Tuple{Type{Ifcontent}, FSM}" href="#VerilogWriter.fsmconv-Tuple{Type{Ifcontent}, FSM}"><code>VerilogWriter.fsmconv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fsmconv(::Type{Ifcontent}, x::FSM)</code></pre><p>Convert <code>FSM</code> logic to <code>Ifcontent</code> object.</p><p>When <code>vshow(fsmconv(Ifcontent, x))</code> is evaluated one  case block will be the only output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/fsm.jl#L271-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.fsmconv-Tuple{Type{Localparams}, FSM}" href="#VerilogWriter.fsmconv-Tuple{Type{Localparams}, FSM}"><code>VerilogWriter.fsmconv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fsmconv(::Type{Localparams}, x::FSM)</code></pre><p>Generate localparams that declare the value which corresponds to each state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/fsm.jl#L298-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.fsmconv-Tuple{Type{Onedecl}, FSM}" href="#VerilogWriter.fsmconv-Tuple{Type{Onedecl}, FSM}"><code>VerilogWriter.fsmconv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fsmconv(::Type{Onedecl}, x::FSM)</code></pre><p>Generate one <code>reg</code> declaration in verilog that holds the state value at the time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/fsm.jl#L287-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.transadd!-Tuple{FSM, Wireexpr, Pair{String, String}}" href="#VerilogWriter.transadd!-Tuple{FSM, Wireexpr, Pair{String, String}}"><code>VerilogWriter.transadd!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transadd!(x::FSM, cond::Wireexpr, newtrans::Pair{String, String})</code></pre><p>Add a new transition rule for the state machine <code>x</code>.</p><p>The new rule here is:</p><ul><li>The transition from state <code>newtrans[1]</code> to state <code>newtrans[2]</code></li><li>This transition occures when <code>cond</code> is true and the current state is <code>newtrans[1]</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fsm = @FSM nstate (uno, dos, tres); # create a FSM

julia&gt; transadd!(fsm, (@wireexpr b1 == b2), @tstate uno =&gt; dos); # transition from &quot;uno&quot; to &quot;dos&quot; when &quot;b1 == b2&quot;

julia&gt; vshow(fsmconv(Case, fsm));
case (nstate)
    uno: begin
        if ((b1 == b2)) begin
            nstate &lt;= dos;
        end
    end
    dos: begin
        
    end
    tres: begin
        
    end
endcase
type: Case</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/fsm.jl#L133-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.transcond-Tuple{Any, Pair{String, String}}" href="#VerilogWriter.transcond-Tuple{Any, Pair{String, String}}"><code>VerilogWriter.transcond</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transcond(m::FSM, states::Pair{String, String})</code></pre><p>Get the <code>wireexpr</code> whose value should be <code>true</code> iff the state of  the FSM changes from <code>states[1]</code> to <code>states[2]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = @FSM fsm s1, s2, s3; transadd!(m, (@wireexpr b1 == TCOND), @tstate s1=&gt;s2); vshow(fsmconv(Case, m));
case (fsm)
    s1: begin
        if ((b1 == TCOND)) begin
            fsm &lt;= s2;
        end
    end
    s2: begin
        
    end
    s3: begin
        
    end
endcase
type: Case

julia&gt; t = transcond(m, @tstate s1 =&gt; s2); vshow(t);
((fsm == s1) &amp;&amp; (b1 == TCOND))
type: Wireexpr

julia&gt; t = transcond(m, @tstate s2 =&gt; s1);
ERROR: transition rule not registered for &quot;s2&quot; =&gt; &quot;s1&quot;.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/fsm.jl#L188-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.@FSM-Tuple{Any, Any}" href="#VerilogWriter.@FSM-Tuple{Any, Any}"><code>VerilogWriter.@FSM</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@FSM(mname, states)</code></pre><p>Create <code>FSM</code> with variables of (machine itself / states) names.</p><p>With the macro there is no need to explicitly make a string object for  machine/state names.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = @FSM m1 (s1, s2); # same as &quot;@FSM(m1, (s1, s2))&quot;

julia&gt; vshow(m)
reg m1;

localparam s1 = 0;
localparam s2 = 1;

case (m1)
    s1: begin
        
    end
    s2: begin
        
    end
endcase
type: FSM</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/fsm.jl#L57-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.@tstate-Tuple{Any}" href="#VerilogWriter.@tstate-Tuple{Any}"><code>VerilogWriter.@tstate</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@tstate(arg)</code></pre><p>Helper macro for argument in <code>transadd!</code>. </p><p>Convert a pair of variables to a pair of strings.</p><pre><code class="language-julia-repl hljs">julia&gt; @tstate a =&gt; b
&quot;a&quot; =&gt; &quot;b&quot;

julia&gt; m = @FSM machine s1, s2;

julia&gt; transadd!(m, (@wireexpr b), @tstate s1 =&gt; s2);

julia&gt; vshow(m)
reg machine;

localparam s1 = 0;
localparam s2 = 1;

case (machine)
    s1: begin
        if (b) begin
            machine &lt;= s2;
        end
    end
    s2: begin
        
    end
endcase
type: FSM</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/fsm.jl#L92-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.defclk" href="#VerilogWriter.defclk"><code>VerilogWriter.defclk</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Default value of clocking signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/autoreset.jl#L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.defrst" href="#VerilogWriter.defrst"><code>VerilogWriter.defrst</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Default value of resetting signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/autoreset.jl#L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.autoreset-Tuple{Alwayscontent}" href="#VerilogWriter.autoreset-Tuple{Alwayscontent}"><code>VerilogWriter.autoreset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autoreset(x::Alwayscontent; clk=defclk, rst=defrst, edge=posedge)</code></pre><p>Automatically reset wires which appear in <code>x::Alwayscontent</code>.</p><p>Sensitivity list in the original <code>Alwayscontent</code> will be ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/autoreset.jl#L135-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.autoreset-Tuple{Ifcontent}" href="#VerilogWriter.autoreset-Tuple{Ifcontent}"><code>VerilogWriter.autoreset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autoreset(x::Ifcontent; clk=Wireexpr(&quot;CLK&quot;), rst=Wireexpr(&quot;RST&quot;), edge=posedge)</code></pre><p>Given <code>x::Ifcontent</code>, returns <code>always_ff/always</code> block that  resets every <code>wire/reg</code>s appear at Lhs of <code>x</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">c = @ifcontent (
    r1 &lt;= r2;
    if b1 
        r2 &lt;= 0
        r3 &lt;= r3 + r4
    else 
        r3 &lt;= 0
    end
) 
r = autoreset(c; clk=(@wireexpr clk), rst=(@wireexpr ~resetn))
vshow(r)

# output

always_ff @( posedge clk ) begin
    if (~resetn) begin
        r1 &lt;= 0;
        r2 &lt;= 0;
        r3 &lt;= 0;
    end else begin
        r1 &lt;= r2;
        if (b1) begin
            r2 &lt;= 0;
            r3 &lt;= (r3 + r4);
        end else begin
            r3 &lt;= 0;
        end
    end
end
type: Alwayscontent</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/autoreset.jl#L82-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.lhsextract-Tuple{Alassign}" href="#VerilogWriter.lhsextract-Tuple{Alassign}"><code>VerilogWriter.lhsextract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lhsextract(x::Alassign)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/autoreset.jl#L24-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.lhsextract-Tuple{Case}" href="#VerilogWriter.lhsextract-Tuple{Case}"><code>VerilogWriter.lhsextract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lhsextract(x::Case)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/autoreset.jl#L43-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.lhsextract-Tuple{Ifcontent}" href="#VerilogWriter.lhsextract-Tuple{Ifcontent}"><code>VerilogWriter.lhsextract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lhsextract(x::Ifcontent)</code></pre><p>Extract all <code>Wireexpr</code>s on Lhs. May contain more than one identical <code>Wireexpr</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/autoreset.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.lhsextract-Tuple{Ifelseblock}" href="#VerilogWriter.lhsextract-Tuple{Ifelseblock}"><code>VerilogWriter.lhsextract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lhsextract(x::Ifelseblock)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/autoreset.jl#L31-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.lhsextractcore!-Tuple{Any, Any}" href="#VerilogWriter.lhsextractcore!-Tuple{Any, Any}"><code>VerilogWriter.lhsextractcore!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lhsextractcore!(ans, v)</code></pre><p>A helper function for <a href="reference.html#VerilogWriter.lhsextract-Tuple{Alassign}"><code>lhsextract</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/autoreset.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.lhsunify-Tuple{Vector{Wireexpr}}" href="#VerilogWriter.lhsunify-Tuple{Vector{Wireexpr}}"><code>VerilogWriter.lhsunify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lhsunify(wvec::Vector{Wireexpr})</code></pre><p>Remove identical wires contained in <code>wvec</code> more than once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/autoreset.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wirewidid" href="#VerilogWriter.wirewidid"><code>VerilogWriter.wirewidid</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>update julia to v1.8 and replace with <code>wirewidid::Int = 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wwinvalid" href="#VerilogWriter.wwinvalid"><code>VerilogWriter.wwinvalid</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Value which indicates that the <code>Wirewid</code> object does not have a valid value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Vmodenv-Tuple{}" href="#VerilogWriter.Vmodenv-Tuple{}"><code>VerilogWriter.Vmodenv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Vmodenv()</code></pre><p>Create an empty <code>Vmodenv</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.WirewidthUnresolved" href="#VerilogWriter.WirewidthUnresolved"><code>VerilogWriter.WirewidthUnresolved</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Error thrown when wire width inferenece is not possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.autodecl-Tuple{Any, Vmodenv}" href="#VerilogWriter.autodecl-Tuple{Any, Vmodenv}"><code>VerilogWriter.autodecl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodecl(x, env::Vmodenv)</code></pre><p>Declare wires in <code>x</code> which are not yet declared in <code>env</code>. Raise error when not enough information to determine width of all wires is given.</p><p>Type of <code>x</code> is restricted to the type <code>wireextract!</code> accepts.</p><p><strong>Examples</strong></p><p><strong>Inference Success</strong></p><pre><code class="language-julia hljs">pts = @ports (
        @in 16 din;
        @in b1
)
env = Vmodenv(pts)

c = @ifcontent (
    reg1 = 0;
    reg2 = din;
    if b1 
        reg1 = din[10:7]
    end
) 

newds, _ = autodecl(c, env)
vshow(newds)

# output

reg [3:0] reg1;
reg [15:0] reg2;
type: Decls</code></pre><p>You may also declare ports/wires beforehand whose width is unknown.</p><p>When declaring ports/wires without specifying its bit width, assign <code>-1</code> as its width.</p><pre><code class="language-julia hljs">ps = @ports (
    @in 2 x;
    @in -1 y;
    @out @reg A z
) 
ds = @decls (
    @wire -1 w1;
    @wire B w2
)

ab = @always (
    z &lt;= r1 + r2 + r3;
    r4 &lt;= (y &amp; w1) &lt;&lt; r1[1:0];
    r5 &lt;= y + w2
)
env = Vmodenv(Parameters(), ps, Localparams(), ds)
d, newenv = autodecl(ab.content, env)

vshow(newenv)
println()
vshow(d)

# output

input [1:0] x
input [B-1:0] y
output reg [A-1:0] z

wire [B-1:0] w1;
wire [B-1:0] w2;
type: Vmodenv

reg [A-1:0] r1;
reg [A-1:0] r2;
reg [A-1:0] r3;
reg [B-1:0] r4;
reg [B-1:0] r5;
type: Decls</code></pre><p><strong>Fail in Inference</strong></p><pre><code class="language-julia hljs">c = @ifcontent (
    reg1 = 0;
    reg2 = din;
    if b1 
        reg1 = din[10:7]
    end
) 

autodecl(c)

# output

ERROR: Wire width cannot be inferred for the following wires.
1. b1
2. reg2 = din</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L573-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.autodecl-Tuple{Any}" href="#VerilogWriter.autodecl-Tuple{Any}"><code>VerilogWriter.autodecl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodecl(x)</code></pre><p>Call <code>autodecl</code> under an empty environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L706-L710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.eqwidflatten!-Tuple{Wireexpr, Any, Any, Any, Vector{VerilogWriter.Wirewid}, Any, Any}" href="#VerilogWriter.eqwidflatten!-Tuple{Wireexpr, Any, Any, Any, Vector{VerilogWriter.Wirewid}, Any, Any}"><code>VerilogWriter.eqwidflatten!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eqwidflatten!(x::Wireexpr, envdicts, ansset, eqwids::Vector{Wirewid}, declonly, equality)</code></pre><p>Extract wires that appear inside <code>x</code> which are of the same width as <code>x</code> itself,  find <code>Wirewid</code> objects which correspond to the wire and push them into <code>eqwids</code>. When slice appears inside <code>x</code>, new Wirewid object is created and then added to <code>eqwids</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L231-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.extract2dreg-Tuple{Vector{Onedecl}}" href="#VerilogWriter.extract2dreg-Tuple{Vector{Onedecl}}"><code>VerilogWriter.extract2dreg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extract2dreg(x::Vector{Onedecl})</code></pre><p>Extract 2d regs as dict object from <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.findandpush_widunify!-Tuple{String, Any, Any, Any}" href="#VerilogWriter.findandpush_widunify!-Tuple{String, Any, Any, Any}"><code>VerilogWriter.findandpush_widunify!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findandpush_widunify!(newval::String, envdicts, ansset, widvars)</code></pre><p>Looking inside envdicts, add <code>newval</code> to <code>ansset</code> and <code>widvars</code> if <code>newval</code> is not in <code>envdicts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L182-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.portdeclupdated!-Tuple{Vmodenv, Dict{String, VerilogWriter.Wirewid}}" href="#VerilogWriter.portdeclupdated!-Tuple{Vmodenv, Dict{String, VerilogWriter.Wirewid}}"><code>VerilogWriter.portdeclupdated!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">portdeclupdated!(env::Vmodenv, ansset::Dict{String, Wirewid})</code></pre><p>When env contains ports/wire declarations of unknown width,  return new <code>Vmodenv</code> object whose bitwidth are all filled in.</p><p><code>ansset</code> is supposed to contain enough information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L533-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.separate_widunknown-Tuple{Vector{Onedecl}}" href="#VerilogWriter.separate_widunknown-Tuple{Vector{Onedecl}}"><code>VerilogWriter.separate_widunknown</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">separate_widunknown(v::Vector{Onedecl})</code></pre><p>Separate <code>Onedecls</code> into the group of wires whose width is already determined and the group of wires with unknown width.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.strwidunknown-Tuple{Any}" href="#VerilogWriter.strwidunknown-Tuple{Any}"><code>VerilogWriter.strwidunknown</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strwidunknown(widvars)</code></pre><p>Format <code>widvars</code>, returned from <a href="reference.html#VerilogWriter.widunify-Tuple{Vector{Wireexpr}, Vector{Tuple{Wireexpr, Wireexpr}}, Vmodenv}"><code>widunify</code></a>, to a string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L514-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.unifycore_widunify!-Union{Tuple{T}, Tuple{Vector{T}, Any, Any, Any, Any, Any, Any}} where T&lt;:Union{Tuple{Wireexpr, Wireexpr}, Wireexpr}" href="#VerilogWriter.unifycore_widunify!-Union{Tuple{T}, Tuple{Vector{T}, Any, Any, Any, Any, Any, Any}} where T&lt;:Union{Tuple{Wireexpr, Wireexpr}, Wireexpr}"><code>VerilogWriter.unifycore_widunify!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unifycore_widunify!(items::Vector{T}, envdicts, ansset, widvars, declonly, equality) where {T &lt;: Union{Wireexpr, Tuple{Wireexpr, Wireexpr}}}</code></pre><p>Called in <a href="reference.html#VerilogWriter.widunify-Tuple{Vector{Wireexpr}, Vector{Tuple{Wireexpr, Wireexpr}}, Vmodenv}"><code>widunify</code></a>, infer wire width from <code>equality</code> constraints.</p><p>To recursively look into <code>Wireexpr</code>s in <code>items</code>, push new equality  and declaration into <code>declonly</code> and <code>equality</code> given as arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L349-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.unknowndeclpush!-Tuple{Dict{String, VerilogWriter.Wirewid}, Dict{VerilogWriter.Wirewid, Vector{String}}, Ports, Decls}" href="#VerilogWriter.unknowndeclpush!-Tuple{Dict{String, VerilogWriter.Wirewid}, Dict{VerilogWriter.Wirewid, Vector{String}}, Ports, Decls}"><code>VerilogWriter.unknowndeclpush!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unknowndeclpush!(ansset::Dict{String, Wirewid}, widvars::Dict{Wirewid, Vector{String}}, ukports::Ports, ukdecls::Decls)</code></pre><p>Register ports/wire declarations of unknown width  to <code>ansset</code> and <code>widvars</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.widunify-Tuple{Vector{Wireexpr}, Vector{Tuple{Wireexpr, Wireexpr}}, Vmodenv}" href="#VerilogWriter.widunify-Tuple{Vector{Wireexpr}, Vector{Tuple{Wireexpr, Wireexpr}}, Vmodenv}"><code>VerilogWriter.widunify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">widunify(declonly::Vector{Wireexpr}, equality::Vector{Tuple{Wireexpr, Wireexpr}}, env::Vmodenv)</code></pre><p>Given <code>declonly</code> and <code>equality</code> from <a href="reference.html#VerilogWriter.wireextract-Tuple{Any}"><code>wireextract</code></a>,  infer width of wires which appear in the conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L441-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.widunify-Tuple{Vector{Wireexpr}, Vector{Tuple{Wireexpr, Wireexpr}}}" href="#VerilogWriter.widunify-Tuple{Vector{Wireexpr}, Vector{Tuple{Wireexpr, Wireexpr}}}"><code>VerilogWriter.widunify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">widunify(declonly::Vector{Wireexpr}, equality::Vector{Tuple{Wireexpr, Wireexpr}})</code></pre><p>Call <code>widunify</code> under an empty <code>env</code> (, where no ports, parameters,... are declared).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L493-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireextract!-Tuple{Alwayscontent, Any, Any}" href="#VerilogWriter.wireextract!-Tuple{Alwayscontent, Any, Any}"><code>VerilogWriter.wireextract!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireextract!(x::Alwayscontent, declonly, equality)</code></pre><p>For always content. Sensitivity in <code>x</code> will be ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireextract!-Tuple{Ifcontent, Any, Any}" href="#VerilogWriter.wireextract!-Tuple{Ifcontent, Any, Any}"><code>VerilogWriter.wireextract!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireextract!(x::Ifcontent, declonly, equality)</code></pre><p>Helper function for <a href="reference.html#VerilogWriter.wireextract-Tuple{Any}"><code>wireextract</code></a>.  Add constraints to <code>declonly</code> and <code>equality</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireextract!-Union{Tuple{T}, Tuple{Vector{T}, Any, Any}} where T&lt;:Union{Alwayscontent, Ifcontent}" href="#VerilogWriter.wireextract!-Union{Tuple{T}, Tuple{Vector{T}, Any, Any}} where T&lt;:Union{Alwayscontent, Ifcontent}"><code>VerilogWriter.wireextract!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireextract!(x::Vector{T}, declonly, equality) where {T &lt;: Union{Ifcontent, Alwayscontent}}</code></pre><p>For Vector{Ifcontent/Alwayscontent}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireextract-Tuple{Any}" href="#VerilogWriter.wireextract-Tuple{Any}"><code>VerilogWriter.wireextract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireextract(x)</code></pre><p>Extract <code>Wireexpr</code>s from <code>x::Ifcontent</code>, along with equality constraints of wire width.</p><p>Return <code>declonly::Vector{Wireexpr}</code>, which contains wires appear in  <code>x::Ifcontent</code>, and <code>equality::Vector{Tuple{Wireexpr, Wireexpr}}</code>,  which contains tuples of two <code>Wireexpr</code>s which are supposed to be of the same width.</p><p>Type of <code>x</code> is restricted in <code>wireextract!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wirepush_widunify!-Tuple{Wireexpr, Any, Any, Any}" href="#VerilogWriter.wirepush_widunify!-Tuple{Wireexpr, Any, Any, Any}"><code>VerilogWriter.wirepush_widunify!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wirepush_widunify!(w::Wireexpr, envdicts, ansset, widvars)</code></pre><p>Push every wire that appears inside <code>w</code> to <code>ansset</code> and <code>widvars</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/0cf68f0b281d2d0117a668d9eeddbdf9a87e5e28/src/widthinference.jl#L203-L207">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="fsm.html">« Finite State Machines</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Wednesday 21 September 2022 11:43">Wednesday 21 September 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
