<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Component structs · VerilogWriter Document</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">VerilogWriter Document</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Component structs</a><ul class="internal"><li><a class="tocitem" href="#Structs-Description"><span>Structs Description</span></a></li><li><a class="tocitem" href="#Converter-Functions/Macros"><span>Converter Functions/Macros</span></a></li><li><a class="tocitem" href="#List-of-Converter-Functions/Macros"><span>List of Converter Functions/Macros</span></a></li><li><a class="tocitem" href="#Other-Important-functions"><span>Other Important functions</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Component structs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Component structs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/master/docs/src/structs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Component-Structs"><a class="docs-heading-anchor" href="#Component-Structs">Component Structs</a><a id="Component-Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Component-Structs" title="Permalink"></a></h1><h2 id="Structs-Description"><a class="docs-heading-anchor" href="#Structs-Description">Structs Description</a><a id="Structs-Description-1"></a><a class="docs-heading-anchor-permalink" href="#Structs-Description" title="Permalink"></a></h2><p>This module offers several structs that contain a structure of Verilog components, major ones of which are listed below. </p><ul><li><a href="#Parameters">Parameters</a><ul><li><a href="#Oneparam">Oneparam</a></li></ul></li><li><a href="#Ports">Ports</a><ul><li><a href="#Oneport">Oneport</a><ul><li><a href="#Portdirec">Portdirec</a></li><li><a href="#Wiretype">Wiretype</a></li></ul></li></ul></li><li><a href="#Wireexpr">Wireexpr</a><ul><li><a href="#Wireop">Wireop</a></li></ul></li><li><a href="#Decls">Decls</a><ul><li><a href="#Onedecl">Onedecl</a></li></ul></li><li><a href="#Assign">Assign</a></li><li><a href="#Alwayscontent">Alwayscontent</a><ul><li><a href="#Alassign">Alassign</a></li><li><a href="#Ifelseblock">Ifelseblock</a><ul><li><a href="#Ifcontent">Ifcontent</a></li></ul></li><li><a href="#Atype">Atype</a></li><li><a href="#Edge">Edge</a></li></ul></li><li><a href="#Vmodule">Vmodule</a></li></ul><h3 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Parameters(val::Vector{Oneparam})</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Parameters" href="#VerilogWriter.Parameters"><code>VerilogWriter.Parameters</code></a> — <span class="docstring-category">Type</span></header><section><div><p>List of parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L9">source</a></section></article><h4 id="Oneparam"><a class="docs-heading-anchor" href="#Oneparam">Oneparam</a><a id="Oneparam-1"></a><a class="docs-heading-anchor-permalink" href="#Oneparam" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Oneparam(name::String, val::Int64)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Oneparam" href="#VerilogWriter.Oneparam"><code>VerilogWriter.Oneparam</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parameter in verilog.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L1-L3">source</a></section></article><h3 id="Ports"><a class="docs-heading-anchor" href="#Ports">Ports</a><a id="Ports-1"></a><a class="docs-heading-anchor-permalink" href="#Ports" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Ports(val::Vector{Oneport})</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Ports" href="#VerilogWriter.Ports"><code>VerilogWriter.Ports</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Gather multiple ports.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L29">source</a></section></article><h4 id="Oneport"><a class="docs-heading-anchor" href="#Oneport">Oneport</a><a id="Oneport-1"></a><a class="docs-heading-anchor-permalink" href="#Oneport" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Oneport(direc::Portdirec, wtype::Wiretype, width::Int64, name::String)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Oneport" href="#VerilogWriter.Oneport"><code>VerilogWriter.Oneport</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represent a single port declaration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L20">source</a></section></article><h4 id="Portdirec"><a class="docs-heading-anchor" href="#Portdirec">Portdirec</a><a id="Portdirec-1"></a><a class="docs-heading-anchor-permalink" href="#Portdirec" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Enum pin pout</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Portdirec" href="#VerilogWriter.Portdirec"><code>VerilogWriter.Portdirec</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Port direction object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L14">source</a></section></article><h4 id="Wiretype"><a class="docs-heading-anchor" href="#Wiretype">Wiretype</a><a id="Wiretype-1"></a><a class="docs-heading-anchor-permalink" href="#Wiretype" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Enum wire reg logic</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wiretype" href="#VerilogWriter.Wiretype"><code>VerilogWriter.Wiretype</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wiretype object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L17">source</a></section></article><h3 id="Wireexpr"><a class="docs-heading-anchor" href="#Wireexpr">Wireexpr</a><a id="Wireexpr-1"></a><a class="docs-heading-anchor-permalink" href="#Wireexpr" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Wireexpr(operation::Wireop, name::String, subnodes::Vector{Wireexpr}, bitwidth::Int64, value::Int64)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireexpr" href="#VerilogWriter.Wireexpr"><code>VerilogWriter.Wireexpr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wire expressions in verilog. </p><p>Contains unnecessary information to handle all the wires in the same type. </p><p>One motivation to avoid making different types of  wires (e.g. using parametric types) is that it seemed beneficial to have multiple wires in a vector, and that  it is sometime a disadvantage in performance to use  abstract types when creating vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L96-L107">source</a></section></article><h4 id="Wireop"><a class="docs-heading-anchor" href="#Wireop">Wireop</a><a id="Wireop-1"></a><a class="docs-heading-anchor-permalink" href="#Wireop" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Enum add minus lshift rshift band bor bxor neg uminus redand redor redxor leq land lor id slice literal hex dec</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Wireop" href="#VerilogWriter.Wireop"><code>VerilogWriter.Wireop</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Verilog operators.</p><p>Unary <code>&amp;, |</code> does not exists so explicitly call as function  e.g. <code>&amp;(wire), |(wire)</code> (&amp; behaves in a wickedmanner...?). Xor in verilog <code>^</code> is in Julia exponential operator, and the difference in association exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L34-L41">source</a></section></article><h3 id="Decls"><a class="docs-heading-anchor" href="#Decls">Decls</a><a id="Decls-1"></a><a class="docs-heading-anchor-permalink" href="#Decls" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Decls(val::Vector{Onedecl})</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Decls" href="#VerilogWriter.Decls"><code>VerilogWriter.Decls</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multiple wire declarations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L194">source</a></section></article><h4 id="Onedecl"><a class="docs-heading-anchor" href="#Onedecl">Onedecl</a><a id="Onedecl-1"></a><a class="docs-heading-anchor-permalink" href="#Onedecl" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Onedecl(wtype::Wiretype, width::Int64, name::String)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Onedecl" href="#VerilogWriter.Onedecl"><code>VerilogWriter.Onedecl</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represent one wire declaration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L187">source</a></section></article><h3 id="Assign"><a class="docs-heading-anchor" href="#Assign">Assign</a><a id="Assign-1"></a><a class="docs-heading-anchor-permalink" href="#Assign" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Assign(lhs::Wireexpr, rhs::Wireexpr)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Assign" href="#VerilogWriter.Assign"><code>VerilogWriter.Assign</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Assign one statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L181">source</a></section></article><h3 id="Alwayscontent"><a class="docs-heading-anchor" href="#Alwayscontent">Alwayscontent</a><a id="Alwayscontent-1"></a><a class="docs-heading-anchor-permalink" href="#Alwayscontent" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Alwayscontent(atype::Atype, edge::Edge, sensitive::Wireexpr, assigns::Vector{Alassign}, ifelseblocks::Vector{Ifelseblock})</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Alwayscontent" href="#VerilogWriter.Alwayscontent"><code>VerilogWriter.Alwayscontent</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represent always blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L172">source</a></section></article><h4 id="Alassign"><a class="docs-heading-anchor" href="#Alassign">Alassign</a><a id="Alassign-1"></a><a class="docs-heading-anchor-permalink" href="#Alassign" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Alassign(lhs::Wireexpr, rhs::Wireexpr, atype::Atype)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Alassign" href="#VerilogWriter.Alassign"><code>VerilogWriter.Alassign</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Assign statement inside always blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L121">source</a></section></article><h4 id="Ifelseblock"><a class="docs-heading-anchor" href="#Ifelseblock">Ifelseblock</a><a id="Ifelseblock-1"></a><a class="docs-heading-anchor-permalink" href="#Ifelseblock" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Ifelseblock(conds::Vector{Wireexpr}, contents::Vector{Ifcontent})</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Ifelseblock" href="#VerilogWriter.Ifelseblock"><code>VerilogWriter.Ifelseblock</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Container of an if-else block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L151-L153">source</a></section></article><h5 id="Ifcontent"><a class="docs-heading-anchor" href="#Ifcontent">Ifcontent</a><a id="Ifcontent-1"></a><a class="docs-heading-anchor-permalink" href="#Ifcontent" title="Permalink"></a></h5><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Ifcontent(assigns::Vector{Alassign}, ifelseblocks::Vector{Ifelseblock})</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Ifcontent" href="#VerilogWriter.Ifcontent"><code>VerilogWriter.Ifcontent</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Container of one if-block (, one elseif block, or one else block).</p><p>Parametrized by <code>T</code> only for mutual recursion with <code>Ifelseblock</code>,  thus used as <code>Ifcontent_inner{Ifelseblock}</code>, which is aliased as <code>Ifcontent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L128-L133">source</a></section></article><h4 id="Atype"><a class="docs-heading-anchor" href="#Atype">Atype</a><a id="Atype-1"></a><a class="docs-heading-anchor-permalink" href="#Atype" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Enum ff comb aunknown</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Atype" href="#VerilogWriter.Atype"><code>VerilogWriter.Atype</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type of always blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L118">source</a></section></article><h4 id="Edge"><a class="docs-heading-anchor" href="#Edge">Edge</a><a id="Edge-1"></a><a class="docs-heading-anchor-permalink" href="#Edge" title="Permalink"></a></h4><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Enum posedge negedge unknownedge</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Edge" href="#VerilogWriter.Edge"><code>VerilogWriter.Edge</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Edge in sensitivity lists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L169">source</a></section></article><h3 id="Vmodule"><a class="docs-heading-anchor" href="#Vmodule">Vmodule</a><a id="Vmodule-1"></a><a class="docs-heading-anchor-permalink" href="#Vmodule" title="Permalink"></a></h3><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Vmodule(name::String, params::Parameters, ports::Ports, decls::Decls, assigns::Vector{Assign}, always::Vector{Alwayscontent})</code></pre><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.Vmodule" href="#VerilogWriter.Vmodule"><code>VerilogWriter.Vmodule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents one verilog module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructs.jl#L199">source</a></section></article><h2 id="Converter-Functions/Macros"><a class="docs-heading-anchor" href="#Converter-Functions/Macros">Converter Functions/Macros</a><a id="Converter-Functions/Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Converter-Functions/Macros" title="Permalink"></a></h2><p>As in previous examples we offer functions and macros to convert Julia syntax into certain structs described above. You may use these instead of calling constructors.</p><p>All the functions listed below accept <code>Expr</code> object as its argument (e.g. :(x = 10), see <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#Expressions-and-evaluation">Julia Documents</a> for more information.), and that is why variables inside the argument <code>Expr</code> object do not have to be declared anywhere else in the source code. The syntaxes each function requires in a argument <code>Expr</code> objects are also described below (or may be easily inferred from the examples here and <a href="../#Brief-Introduction">Brief Introduction</a>).</p><p>As you see in <a href="../#Brief-Introduction">Brief Introduction</a> there are macros that do the same thing as functions listed below (and both macro and function has the same name). As macros take <code>Expr</code> object as its argument, you can write codes in a slightly more simple manner with macros. For example,</p><pre><code class="nohighlight hljs">always(:(
    @posedge clk; 

    w1 &lt;= w2;
    if b1 == b2 
        w3 &lt;= w4
    end
))</code></pre><p>is equivalent to </p><pre><code class="nohighlight hljs">@always (
    @posedge clk; 

    w1 &lt;= w2;
    if b1 == b2 
        w3 &lt;= w4
    end
)</code></pre><p>(be care full not to foreget <code>(one space)</code> between macros and <code>(</code>, i.e. <code>@macro(a;b)</code> and <code>@macro (a;b)</code> are different.)</p><p>But sometimes there are things what macros cannot do (at least to me it seems impossible in macros), an example is having <code>for</code> loop inside expressions.</p><pre><code class="language-Julia hljs">d = always(:(
    if b1 
        $([:($(Symbol(&quot;x$i&quot;)) = $(Symbol(&quot;y$i&quot;))) for i in 1:3]...)
    end
))
vshow(d)</code></pre><p>and this outputs</p><pre><code class="nohighlight hljs">always_comb begin
    if (b1) begin
        x1 = y1;
        x2 = y2;
        x3 = y3;
    end
end
type: Alwayscontent</code></pre><h2 id="List-of-Converter-Functions/Macros"><a class="docs-heading-anchor" href="#List-of-Converter-Functions/Macros">List of Converter Functions/Macros</a><a id="List-of-Converter-Functions/Macros-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-Converter-Functions/Macros" title="Permalink"></a></h2><p>Written inside parentheses are the types of objects the functions return.</p><ul><li><a href="#ports">ports</a> (<a href="#Ports">Ports</a>)<ul><li><a href="#portoneline">portoneline</a> (<a href="#Oneport">Oneport</a>)</li></ul></li><li><a href="#wireexpr">wireexpr</a> (<a href="#Wireexpr">Wireexpr</a>)</li><li><a href="#decls">decls</a> (<a href="#Decls">Decls</a>)<ul><li><a href="#decloneline">decloneline</a> (<a href="#Onedecl">Onedecl</a>)</li></ul></li><li><a href="#always">always</a> (<a href="#Alwayscontent">Alwayscontent</a>)<ul><li><a href="#roneblock">roneblock</a>  (<a href="#Ifelseblock">Ifelseblock</a>,<a href="#Alassign">Alassign</a>)</li></ul></li></ul><h3 id="ports"><a class="docs-heading-anchor" href="#ports">ports</a><a id="ports-1"></a><a class="docs-heading-anchor-permalink" href="#ports" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.ports-Tuple{Expr}" href="#VerilogWriter.ports-Tuple{Expr}"><code>VerilogWriter.ports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ports(expr::Expr)</code></pre><p>Convert Julia AST into port declarations as <a href="#Ports">Ports</a> object.</p><p><strong>Syntax</strong></p><p><strong><code>&lt;portoneline&gt;[;&lt;portoneline&gt;;...]</code></strong></p><p>Multiple lines of <a href="#VerilogWriter.portoneline-Tuple{Expr}"><code>portoneline</code></a> expressions  separated by <code>;</code> can be accepted. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs">pp = ports(:(
    @in p1;
    @in wire 8 p2, p3, p4;
    @out reg 2 p5, p6
))

vshow(pp)

# output

(
    input p1,
    input [7:0] p2,
    input [7:0] p3,
    input [7:0] p4,
    output reg [1:0] p5,
    output reg [1:0] p6
);

type: Ports</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/rawparser.jl#L786-L819">source</a></section></article><h4 id="portoneline"><a class="docs-heading-anchor" href="#portoneline">portoneline</a><a id="portoneline-1"></a><a class="docs-heading-anchor-permalink" href="#portoneline" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.portoneline-Tuple{Expr}" href="#VerilogWriter.portoneline-Tuple{Expr}"><code>VerilogWriter.portoneline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">portoneline(expr::Expr)</code></pre><p>Parse Julia AST to one line of port declaration as <a href="#Oneport">Oneport</a>.</p><p><strong>Syntax</strong></p><p><strong><code>@in &lt;wirename&gt;</code>, <code>@out &lt;wirename&gt;</code></strong></p><p>One port declaration of width 1.</p><p><strong><code>@in/@out &lt;wirename1, wirename2, ...&gt;</code></strong></p><p>Multiple port declaration of width 1 in one line.</p><p><strong><code>@in/@out &lt;width::Int&gt; &lt;wirename1[, wirename2, ...]&gt;</code></strong></p><p>Port declarations of width <code>&lt;width&gt;</code>.</p><p><strong><code>@in/@out &lt;wiretype&gt; [&lt;width::Int&gt;] &lt;wirename1[, wirename2, ...]&gt;</code></strong></p><p>Port declaration with wiretypes [of width <code>&lt;width&gt;</code>].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p1 = portoneline(:(@in din));

julia&gt; vshow(p1);
input din
type: Oneport

julia&gt; p2 = portoneline(:(@out din1, din2, din3)); vshow(p2);
output din1
type: Oneport
output din2
type: Oneport
output din3
type: Oneport

julia&gt; p3 = portoneline(:(@in 8 din)); vshow(p3);
input [7:0] din
type: Oneport

julia&gt; p4 = portoneline(:(@out reg 8 dout)); vshow(p4);
output reg [7:0] dout
type: Oneport</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/rawparser.jl#L583-L625">source</a></section></article><h3 id="wireexpr"><a class="docs-heading-anchor" href="#wireexpr">wireexpr</a><a id="wireexpr-1"></a><a class="docs-heading-anchor-permalink" href="#wireexpr" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.wireexpr-Tuple{Expr}" href="#VerilogWriter.wireexpr-Tuple{Expr}"><code>VerilogWriter.wireexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wireexpr(expr::Expr)</code></pre><p>Parse one wire expression. Be sure to put &#39;two e&#39;s&#39; in wir&#39;ee&#39;xpr, not &#39;wirexpr&#39;.</p><p><strong>Syntax</strong></p><p>Part of what can be done in Verilog can be accepted,  such as <code>din[7:0]</code>, <code>(w1 + w2) &lt;&lt; 5</code></p><p><strong><code>&lt;wirename&gt;</code></strong></p><p>One wire, without slicing or bit-selecting.</p><p><strong><code>&lt;val::Int&gt;</code>, <code>&lt;val::hex&gt;</code>, <code>&lt;val::bin&gt;</code></strong></p><p>Literals, e.g. <code>5</code>, <code>0x1f</code>, <code>0b10</code>.</p><p><strong><code>&lt;wire&gt; &lt;op&gt; &lt;wire&gt;</code>, <code>&lt;op&gt; &lt;wire&gt;</code></strong></p><p>Unary and binary operators.  For reduction operators (unary <code>&amp;, |, ^</code>), since these are  not operators in Julia, write it in the form of function  call explicitly, i.e. <code>&amp;(wire)</code>, <code>|(wire)</code> instead of doing <code>^wire</code>. Note that we use <code>^</code> as xor just as in Verilog, though this is not  a xor operator in Julia.</p><p><strong><code>&lt;wire&gt;[&lt;wire&gt;:&lt;wire&gt;]</code>, <code>&lt;wire&gt;[&lt;wire&gt;]</code></strong></p><p>Bit select and slicing as in Verilog/SystemVerilog.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = wireexpr(:(w)); vshow(w);
w
type: Wireexpr

julia&gt; w = wireexpr(:(w1 &amp; &amp;(w2) )); vshow(w);
(w1 &amp; &amp;(w2))
type: Wireexpr

julia&gt; w = wireexpr(:(w[i:0])); vshow(w);
w[i:0]
type: Wireexpr</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/rawparser.jl#L343-L383">source</a></section></article><h3 id="decls"><a class="docs-heading-anchor" href="#decls">decls</a><a id="decls-1"></a><a class="docs-heading-anchor-permalink" href="#decls" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decls-Tuple{Expr}" href="#VerilogWriter.decls-Tuple{Expr}"><code>VerilogWriter.decls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decls(expr::Expr)</code></pre><p>Parse Julia AST into wire declaration section object <a href="#Decls">Decls</a>.</p><p><strong>Syntax</strong></p><p><strong><code>&lt;onedecl&gt;[;&lt;onedecl&gt;;...]</code></strong></p><p>Multiple <a href="#decloneline">decloneline</a> expressions which are concatenated  by <code>;</code> can be accepted.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">d = decls(:(
    @wire w1;
    @reg 8 w2,w3,w4;
    @logic 32 w5
))
vshow(d)

# output

wire w1;
reg [7:0] w2;
reg [7:0] w3;
reg [7:0] w4;
logic [31:0] w5;
type: Decls</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/rawparser.jl#L989-L1017">source</a></section></article><h4 id="decloneline"><a class="docs-heading-anchor" href="#decloneline">decloneline</a><a id="decloneline-1"></a><a class="docs-heading-anchor-permalink" href="#decloneline" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.decloneline-Tuple{Expr}" href="#VerilogWriter.decloneline-Tuple{Expr}"><code>VerilogWriter.decloneline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decloneline(expr::Expr)</code></pre><p>Parse Julia AST into wire declaration as Vector{<a href="#Onedecl">Onedecl</a>}.</p><p>The number of <code>Onedecl</code> objects returned may differ  according to the number of wires declared in one line  (e.g. <code>input dout</code> &lt;=&gt; <code>input din1, din2, din3</code>).</p><p><strong>Syntax</strong></p><p>Similar to that of <a href="#portoneline">portoneline</a>.</p><p><strong><code>@wire/@reg/@logic [&lt;width&gt;] &lt;wirename1&gt;[, &lt;wirename2&gt;,...]</code></strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = decloneline(:(@reg 10 d1)); vshow(d);
reg [9:0] d1;
type: Onedecl

julia&gt; d = decloneline(:(@logic 8 d1,d2,d3)); vshow(d);
logic [7:0] d1;
type: Onedecl
logic [7:0] d2;
type: Onedecl
logic [7:0] d3;
type: Onedecl</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/rawparser.jl#L873-L901">source</a></section></article><h3 id="always"><a class="docs-heading-anchor" href="#always">always</a><a id="always-1"></a><a class="docs-heading-anchor-permalink" href="#always" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.always-Tuple{Expr}" href="#VerilogWriter.always-Tuple{Expr}"><code>VerilogWriter.always</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">always(expr::Expr)</code></pre><p>Parse AST into always block as <a href="#Alwayscontent">Alwayscontent</a>.</p><p><strong>Syntax</strong></p><p><strong><code>&lt;roneblock&gt;;&lt;roneblock&gt;[;&lt;roneblock&gt;;...]</code></strong></p><p><code>&lt;roneblock&gt;</code> is the expression that can be parsed by <a href="#roneblock">roneblock</a>. <code>;</code> in between <code>&lt;roneblock&gt;</code>s are strictly needed.</p><p><strong><code>@posedge &lt;wirename&gt;; &lt;ifelsestatements&gt;/&lt;assignments&gt;</code></strong></p><p>Set sensitivity list using macro syntax. <code>@negedge</code> is also possible.  You must put <code>@posegde/@negedge</code> statement at the beginning, and only once.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">a1 = always(:(
    w1 = w2;
    if b2 
        w1 = w3 
    end
))
vshow(a1)

# output

always_comb begin
    w1 = w2;
    if (b2) begin
        w1 = w3;
    end
end
type: Alwayscontent</code></pre><pre><code class="language-julia hljs">a1 = always(:(
    @posedge clk;
    
    if b1 == b2
        w1 &lt;= w2 + w3 
    else
        w1 &lt;= ~w1 
    end
))
vshow(a1)

# output

always_ff @( posedge clk ) begin
    if ((b1 == b2)) begin
        w1 &lt;= (w2 + w3);
    end else begin
        w1 &lt;= ~w1;
    end
end
type: Alwayscontent</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructhandlers.jl#L25-L84">source</a></section></article><h4 id="roneblock"><a class="docs-heading-anchor" href="#roneblock">roneblock</a><a id="roneblock-1"></a><a class="docs-heading-anchor-permalink" href="#roneblock" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.roneblock-Tuple{Expr}" href="#VerilogWriter.roneblock-Tuple{Expr}"><code>VerilogWriter.roneblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">roneblock(expr::Expr)</code></pre><p>Parse AST in Julia grammar to one if-else statement or  one assignment inside always blocks in Verilog,  which are <a href="#Ifelseblock">Ifelseblock</a> and <a href="#Alassign">Alassign</a>, respectively. </p><p>As using Julia expression and Julia parser as if  it is of Verilog, there can be difference in grammatical matters  between what can be given as the <code>expr</code> and real Verilog  (e.g. operator precedence of <code>&lt;=</code>).</p><p><strong>Syntax</strong></p><p><strong><code>&lt;wirename1&gt; = &lt;wireoperation&gt;</code></strong></p><p>One blocking assignment. (Note that bit width cannot be  specified yet, nor can it be printed.) <code>&lt;wireoperation&gt;</code> is a expression accepted by <a href="#wireexpr">wireexpr</a>.</p><p><strong>If-else statement</strong></p><pre><code class="nohighlight hljs">if &lt;wireoperation&gt;
    &lt;oneassignment&gt;
    &lt;oneassignment&gt;
    ...
elseif &lt;wireoperation&gt; 
    &lt;oneassignment&gt;
    &lt;ifelsestatement&gt;
    ...
else
    &lt;ifelsestatement&gt;
    ...
end</code></pre><p>If-else statement written in &#39;Julia syntax&#39;, not in Verilog  syntax, can be accepted. <code>else</code> block and <code>elseif</code> are not compulsory. Since <code>if</code> <code>end</code> are at the top level no <code>;</code> inside if-else statement is needed. Nested if-else statement can be also accepted as in usual Julia.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a1 = roneblock(:(w1 &lt;= w2)); 

julia&gt; vshow(a1);
w1 &lt;= w2;
type: Alassign

julia&gt; a2 = roneblock(:(w3 = w4 + ~w2)); vshow(a2);
w3 = (w4 + ~w2);
type: Alassign</code></pre><pre><code class="language-julia hljs">a3 = roneblock(:(
    if b1 == b2
        w5 = ~w6
        w7 = w8 
    elseif b2 
        w9 = w9 + w10
    else
        if b3 
            w11 = w12 
        end
    end
))
vshow(a3)

# output

if ((b1 == b2)) begin
    w5 = ~w6;
    w7 = w8;
end else if (b2) begin
    w9 = (w9 + w10);
end else begin
    if (b3) begin
        w11 = w12;
    end
end
type: Ifelseblock</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/rawparser.jl#L20-L99">source</a></section></article><h2 id="Other-Important-functions"><a class="docs-heading-anchor" href="#Other-Important-functions">Other Important functions</a><a id="Other-Important-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Important-functions" title="Permalink"></a></h2><h3 id="vshow"><a class="docs-heading-anchor" href="#vshow">vshow</a><a id="vshow-1"></a><a class="docs-heading-anchor-permalink" href="#vshow" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.vshow-Tuple{Any}" href="#VerilogWriter.vshow-Tuple{Any}"><code>VerilogWriter.vshow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vshow(x; systemverilog=true)</code></pre><p>Print the structs in <code>VerilogWriter.jl</code> in a readable  format (except for enums). When <code>systemverilog=false</code>, output <code>always</code>, <code>always @*</code>  instead of <code>always_ff</code>, <code>always_comb</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/textutils.jl#L23-L30">source</a></section></article><h3 id="invports"><a class="docs-heading-anchor" href="#invports">invports</a><a id="invports-1"></a><a class="docs-heading-anchor-permalink" href="#invports" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.invports" href="#VerilogWriter.invports"><code>VerilogWriter.invports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">invports(ps::Ports)</code></pre><p>Return <a href="#Ports">Ports</a> object whose directions are reversed from <code>ps</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">pts = @ports (
    @in 8 bus1, bus2;
    @out reg bus3
)
ipts = invports(pts)
vshow(pts)
vshow(ipts)

# output

(
    input [7:0] bus1,
    input [7:0] bus2,
    output reg bus3
);

type: Ports
(
    output [7:0] bus1,
    output [7:0] bus2,
    input bus3
);

type: Ports</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructhandlers.jl#L113-L146">source</a></section></article><h4 id="invport"><a class="docs-heading-anchor" href="#invport">invport</a><a id="invport-1"></a><a class="docs-heading-anchor-permalink" href="#invport" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="VerilogWriter.invport" href="#VerilogWriter.invport"><code>VerilogWriter.invport</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">invport(onep::Oneport)</code></pre><p>Return <a href="#Oneport">Oneport</a> object whose directions are reversed from <code>onep</code>. Wiretype information (<code>reg</code>, <code>wire</code>, <code>logic</code>) is  lost when inverted for <code>reg</code> cannot be at input port.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/t-f-marfil/VerilogWriter.jl/blob/29ff4fb793a91c82f3e4687c21a1abe5f05cf043/src/vstructhandlers.jl#L98-L104">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Sunday 31 July 2022 18:22">Sunday 31 July 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
